#requires -version 5
<#
.SYNOPSIS
NeverRed is a simple PowerShell script to download and install the latest version for several common enterprise Windows applications.
.DESCRIPTION
To update or download a software package just select a LastSetting.txt file (With parameter -ESfile) or select your Software out of the GUI.
A new folder for every single package will be created, together with a version file and a log file. If a new version is available
the script checks the version number and will update the package.

.NOTES
  Version:          2.10.42
  Author:           Manuel Winkel <www.deyda.net>
  Creation Date:    2021-01-29

  // NOTE: Purpose/Change
  2021-01-29        Initial Version
  2021-01-30        Error solved: No installation without parameters / Add WinSCP Install
  2021-01-31        Error solved: Installation Workspace App -> Wrong Variable / Error solved: Detection acute version 7-Zip -> Limitation of the results
  2021-02-01        Add Gui Mode as Standard
  2021-02-02        Add Install OpenJDK / Add Install VMware Tools / Add Install Oracle Java 8 / Add Install Adobe Reader DC
  2021-02-03        Addition of verbose comments. Chrome and Edge customization regarding disabling services and scheduled tasks.
  2021-02-04        Correction OracleJava8 detection / Add Environment Variable $env:evergreen for script path
  2021-02-12        Add Download Citrix Hypervisor Tools, Greenshot, Firefox, Foxit Reader & Filezilla / Correction Citrix Workspace Download & Install Folder / Adding Citrix Receiver Cleanup Utility
  2021-02-14        Change Adobe Acrobat DC Downloader
  2021-02-15        Change MS Teams Downloader / Correction GUI Select All / Add Download MS Apps 365 & Office 2019 Install Files / Add Uninstall and Install MS Apps 365 & Office 2019
  2021-02-18        Correction Code regarding location of scripts at MS365Apps and MSOffice2019. Removing Download Time Files.
  2021-02-19        Implementation of new GUI / Add choice of architecture option in 7-Zip / Add choice of language option in Adobe Reader DC / Add choice of architecture option in Citrix Hypervisor Tools / Add choice of release option in Citrix Workspace App (Merge LTSR and CR script part)
  2021-02-22        Add choice of architecture, language and channel (Latest and ESR) options in Mozilla Firefox / Add choice of language option in Foxit Reader / Add choice of architecture option in Google Chrome / Add choice of channel, architecture and language options in Microsoft 365 Apps / Add choice of architecture option in Microsoft Edge / Add choice of architecture and language options in Microsoft Office 2019 / Add choice of update ring option in Microsoft OneDrive
  2021-02-23        Correction Microsoft Edge Download / Google Chrome Version File
  2021-02-25        Set Mark Jump markers for better editing / Add choice of architecture and update ring options in Microsoft Teams / Add choice of architecture option in Notepad++ / Add choice of architecture option in openJDK / Add choice of architecture option in Oracle Java 8
  2021-02-26        Add choice of version type option in TreeSize / Add choice of version type option in VLC-Player / Add choice of version type option in VMware Tools / Fix installed version detection for x86 / x64 for Microsoft Edge, Google Chrome, 7-Zip, Citrix Hypervisor Tools, Mozilla Firefox, Microsoft365, Microsoft Teams, Microsoft Edge, Notepad++, openJDK, Oracle Java 8, VLC Player and VMware Tols/ Correction Foxit Reader gui variable / Correction version.txt for Microsoft Teams, Notepad++, openJDK, Oracle Java 8, VLC Player and VMware Tools
  2021-02-28        Implementation of LastSetting memory
  2021-03-02        Add Microsoft Teams Citrix Api Hook / Correction En dash Error
  2021-03-05        Adjustment regarding merge #122 (Get-AdobeAcrobatReader)
  2021-03-10        Fix Citrix Workspace App File / Adding advanced logging for Microsoft Teams installation
  2021-03-13        Adding advanced logging for BIS-F, Citrix Hypervisor Tools, Google Chrome, KeePass, Microsoft Edge, Mozilla Firefox, mRemoteNG, Open JDK and VLC Player installation / Adobe Reader Registry Filter Customization / New install parameter Foxit Reader
  2021-03-14        New Install Parameter Adobe Reader DC, Mozilla Firefox and Oracle Java 8 / GUI new Logo Location
  2021-03-15        New Install Parameter Microsoft Edge and Microsoft Teams / Post Setup Customization FSLogix, Microsoft Teams and Microsoft FSLogix
  2021-03-16        Fix Silent Installation of Foxit Reader / Delete Public Desktop Icon of Microsoft Teams, VLC Player and Foxit Reader / Add IrfanView in GUI / Add IrfanView Install and Download / Add Microsoft Teams Developer Ring
  2021-03-22        Add Comments / Add tag to find the places faster when new application is added / Change Install Logging function / Change Adobe Pro DC Download request
  2021-03-23        Added the possibility to delete Microsoft Teams AutoStart in the GUI / Change Microsoft Edge service to manual
  2021-03-24        Add Download Microsoft PowerShell, Microsoft .Net, RemoteDesktopManager, deviceTRUST and Zoom
  2021-03-25        Add Download Slack and ShareX / Add new Software to GUI
  2021-03-26        Add Pending Reboot Check / Add Install RemoteDesktopManager / Icon Delete Public Desktop for KeePass, mRemoteNG, WinSCP and VLC Player
  2021-03-29        Correction Microsoft FSLogix registry entries / Correction Microsoft OneDrive Installer / Add Install Microsoft .Net Framework, ShareX, Slack and Microsoft PowerShell / Correction Zoom and deviceTRUST Download
  2021-03-30        Add Install Zoom + Zoom Plugin for Citrix Receiver and deviceTRUST (Client, Host and Console)
  2021-04-06        Change to new Evergreen Commands
  2021-04-07        Change to faster download method
  2021-04-08        Change color scheme of the messages in Download section / New central MSI Install Function
  2021-04-09        Change color scheme of the messages in Install section
  2021-04-11        Implement new MSI Install Function
  2021-04-12        Correction eng dash
  2021-04-13        Change encoding to UTF-8withBOM / Correction displayed Current Version Install Adobe Reader DC
  2021-04-15        Add Microsoft Edge Dev and Beta Channel / Add Microsoft OneDrive ADM64
  2021-04-16        Script cleanup using the PSScriptAnalyzer suggestions / Add new version check with auto download
  2021-04-21        Customize Auto Update (TLS12 Error) / Teams AutoStart Kill registry query / Correction Teams Outlook Addin registration
  2021-04-22        Little customize to the auto update (Error with IE first launch error)
  2021-04-29        Correction Pending Reboot and AutoUpdate Script with List Parameter
  2021-04-30        Add PuTTY Download Function / Add Paint.Net, GIMP, Microsoft PowerToys, Microsoft Visual Studio 2019, Microsoft Visual Studio Code, PuTTY & TeamViewer
  2021-05-01        Adding the new parameter file to extend the parameter execution with a possibility of software selection. / Add auto update for parameter start (-list) with -file parameter / Add Machine Type Selection
  2021-05-02        Add Microsoft Teams User Based Download and Install / Add Visual Studio Code Per User Installer / Connect the Selection Machine Type Physical to Microsoft Teams User Based, Slack Per User and Visual Studio Code Per User
  2021-05-03        GUI Correction deviceTRUST / Add Zoom Full Client Install and Download / Connect the Selection Machine Type Physical to Zoom Full Client, OneDrive User Based and new install.xml file configuration for Microsoft365 Apps and Office 2019 without SharedComputerLicensing / Change download setting for Microsoft365 Apps and Office 2019 install files to Install section (Automated creation of the install.xml is still in the download area and can therefore be adjusted before downloading the install files) / Add Wireshark Download Function / Add Wireshark
  2021-05-05        Add Microsoft Azure Data Studio / Add Save Button
  2021-05-06        Add new LOG and NORESTART Parameter to deviceTRUST Client Install / Auto Create Shortcut on Desktop with ExecutioPolicy ByPass and Noexit Parameter
  2021-05-07        Version formatting customized / Change Oracle Java Version format
  2021-05-12        Implement new languages in Adobe Acrobat Reader DC / Debug No Putty PreRelease / Debug Oracle Java Version Output
  2021-05-18        Implement new Version request for Teams Developer Version / Add new Teams Exploration Version / Add ImageGlass
  2021-05-25        Correction Install GIMP version comparison / Correction OneDrive Machine Based Install / Correction M365 Install
  2021-06-02        Add FSLogix Channel Selection / Move FSLogix ADMX Files to the ADMX folder in Evergreen
  2021-06-11        Correction Notepad++ Download Version
  2021-06-14        Add uberAgent / Correction Foxit Reader Download and Install
  2021-07-02        Minor Update Correction Google Chrome & Microsoft365 Apps
  2021-07-05        Add Cisco Webex Meetings, ControlUp Agent & Console, MS SQL Server Management, MS AVD Remote Desktop, MS Power BI Desktop, Sumatra PDF Reader and RDAnalyzer Download
  2021-07-06        Wireshark download method changed from own to Evergreen / Add Cisco Webex Meetings, ControlUp Agent, MS SQL Server Management Studio Install
  2021-07-07        Correction Notepad++ Version / Add MS AVD Remote Desktop Install / Add Nevergreen PowerShell module
  2021-07-08        Add MS Power BI Desktop Install / Minor Update Correction Microsoft Teams
  2021-07-17        Error Correction FSLogix Installer search, if no preview version is available / Fix Adobe Reader DC update task disable / Fix Microsoft Edge update registry key
  2021-07-18        Activate Change User /Install in Virtual Machine Type Selection / Change Download Method for SumatraPDF
  2021-07-22        Correction MS Edge Download and Install
  2021-07-29        New Log for FW rules (Ray Davis) / Add MS Edge ADMX Download / Correction Citrix Workspace App Download
  2021-07-30        Add MS Office / MS 365 Apps / OneDrive / BISF / Google Chrome / Mozilla Firefox ADMX Download
  2021-08-03        Add Error Action to clean the output
  2021-08-16        Correction Microsoft FSLogix Install and IrfanView Download / Correction FW Log
  2021-08-17        Correction Sumatra PDF Download
  2021-08-18        Correction ADMX Copy MS Edge, Google Chrome, Mozilla Firefox, MS OneDrive and BIS-F / Add ADMX Download Zoom
  2021-08-19        Add ADMX Download Citrix Workspace App Current and LTSR / Add ADMX Download Adobe Acrobat Reader DC / Activate 64 Bit Download Acrobat Reader DC
  2021-08-20        Add Citrix Files, Microsoft Azure CLI, Microsoft Sysinternals, Nmap, TechSmith Snagit, TechSmith Camtasia, LogMeIn GoToMeeting, Git for Windows and Cisco Webex Teams Download
  2021-08-23        Changing the deviceTRUST download from own to Evergreen method / Delete Cisco Webex Meetings / Add WinMerge, PeaZip, Foxit PDF Editor and Microsoft Power BI Report Builder Download / Change Microsoft365 Apps Channels
  2021-08-24        Add 1Password Download / Add 1Password, Citrix Files, Microsoft Azure CLI, Nmap, TechSmith Camtasia, TechSmith SnagIt and Cisco Webex Teams Install
  2021-08-25        Change LogMeIn GoToMeeting to Xen and Local / Add LogMeIn GoToMeeting Xen and Local and Git for Windows Install
  2021-08-26        Add Foxit PDF Editor, WinMerge, Microsoft Power BI Report Builder and PeaZip Install
  2021-08-31        Correction Auto Update List File Parameter
  2021-09-04        Correction Language Parameter M365 Apps
  2021-09-14        Correction Install Parameter Adobe Acrobat Reader
  2021-09-17        Add KeePass Language Function / Add KeePass Language Download and Install / Add IrfanView Language Download and 
  2021-09-21        Add new GUI with second page / Add new variables from second page
  2021-09-22        Change 7 Zip and Adobe Reader DC to new variables
  2021-09-23        Change disable update task for Adobe Acrobat Reader DC, Pro and Google Chrome / Change Citrix Hypervisor, ControlUp Agent, Foxit PDF Editor, Foxit Reader, Git for Windows, Google Chrome, ImageGlass, IrfanView and deviceTRUST to new variables
  2021-09-24        Change KeePass, Microsoft .Net Framework, Microsoft 365 Apps, Microsoft AVD Remote Desktop Microsoft FSLogix, Microsoft Office 2019 and Microsoft Edge to new variables
  2021-09-25        Change Microsoft Power BI Desktop, Microsoft PowerShell Microsoft SQL Server Management Studio, Microsoft Visual Studio Code, Mozilla Firefox, Notepad ++, openJDK, OracleJava8 and Microsoft Teams to new variables / Add Microsoft Edge WebView2 Runtime
  2021-09-27        Change PeaZip, PuTTY, Slack, VLC Player, VMware Tools, TechSmith SnagIt, WinMerge, Wireshark and Sumatra PDF to new variables / Add Microsoft Project and Microsoft Visio to install.xml creation / Correction Sumatra PDF Reader download link / Change Microsoft Teams download / Add CleanUp Function
  2021-09-28        Add WhatIf Function to Download section / Add OpenFileDialog Function / Add Own Microsoft 365 Apps XML File
  2021-09-29        Add WhatIf Function to Install section / Kill -List Hardcoded Function
  2021-10-04        Add PDF Split & Merge Function / Add PDF Split & Merge Download
  2021-10-05        Correction Copy custom XML / Add PDF Split & Merge Install / Add Autodesk DWG TrueView Function / Add MindView 7 Function / Add Autodesk DWG TrueView Download and Install / Add MindView 7 Download and Install
  2021-10-06        Add Autodesk DWG TrueView, MindView 7 and PDF Split & Merge to GUI and LastSetting.txt
  2021-10-07        Correction Techsmith Camtasia Version / Correction WhatIf Mode
  2021-10-08        Change Machine Type to Installer Label
  2021-10-14        Correction Visio / Project Typo / Fix Microsoft365 Apps Channels
  2021-10-17        Correction Microsoft Teams Machine Based Download
  2021-10-18        Add GUIfile Parameter / Add Mode and Global Information / Add Single Install Type Definition for LogMeInGoToMeeting, Microsoft 365 Apps, Microsoft Visual Studio Code, Microsoft Azure Data Studio, Microsoft OneDrive, Microsoft Teams and Microsoft Office
  2021-10-19        Add Single Install Type Definition for Slack and Zoom / Add Microsoft Office 2021 LTSC / Change Microsoft Office and Microsoft 365 Apps ADMX Architecture / Add Open-Shell Menu Download and Install / Add pdfforge PDFCreator Download Function / Add pdfforge PDFCreator Download and Install / Add Total Commander Download Function / Add Total Commander Download and Install
  2021-10-21        Add Repository Mode
  2021-10-25        Add Start Menu Clean Up Mode
  2021-10-26        Correction Slack and Total Commander installed version detection
  2021-10-27        Correction Repository Mode Filezilla
  2021-10-28        Correction Slack and Zoom Download
  2021-10-29        Correction Oracle Java 8 Version / Change Paint.Net Downloader / Add Citrix Workspace App Web
  2021-11-01        Add Custom XML File for Microsoft Office
  2021-11-02        Add Microsoft Office Visio and Project / Add VCRedist PowerShell module / Add Microsoft Visual C++ Runtimes / Correction Google Chrome Version
  2021-11-03        Add $LASTEXITCODE / Add Install Log Messages
  2021-11-05        Add Acrobat DC ADMX Download / Add Oracle Java 8 Install Parameter
  2021-11-09        Add Microsoft Visual C++ 2022 / Delete Microsoft Visual C++ 2010 and 2019 / Split Zoom and Zoom Citrix HDX Media Plugin / Change Zoom to Nevergreen with Architecture Selection
  2021-11-11        Add Adobe Pro DC Install and Download
  2021-11-12        Add NoPSModuleCheck and NoUpdate Parameter
  2021-11-17        Add Mozilla Thunderbird download
  2021-11-18        Add Mozilla Thunderbird ADMX download / GUI Changes
  2021-11-21        Change Mozilla Firefox language selection to new method / Add language long name to Mozilla Firefox write-host
  2021-11-22        Add fallback loop to FSLogix and Powershell download if Preview or LTS don't exist / Add Mozilla Thunderbird, PDF24 Creator, WinRAR and additional Architecture selection to the GUI
  2021-11-23        Add Mozilla Thunderbird install / Add Adobe Pro DC Architecture selection / Add Google Chrome Channel selection / Split Google Chrome and Microsoft Edge installed version detection in the different channels / Add OpenJDK Package Release selection
  2021-11-24        Add PDF24 Creator download function, Download and Install section / Add Microsoft Edge reghack for the installation message "Microsoft Edge works best with the latest Windows Updates."
  2021-11-25        Add WinRAR download function, Download and Install section / Add Detail Architecture selection for Microsoft Azure Data Studio
  2021-11-26        Minor changes on the output / Add ControlUp Remote DX download function, Download and Install section / Add Cisco Webex Teams VDI Plugin download function, Download and Install section
  2021-12-02        Mozille Firefox Channel selection correction
  2021-12-06        Change Microsoft Teams downlaoder to filter msi / Add Microsoft FSLogix Channel Stable (Preferred by Deyda)
  2021-12-07        Change IrfanView download site / Additional filter parameter for Microsoft .Net Framework
  2021-12-08        Add Global Language Arabic, Chinese, Croatian, Czech, Hebrew, Hungarian, Romanian, Slovak, Slovenian, Turkish and Ukrainian / Add new language to KeePass and WinRAR download function / Add new language to Adobe Reader DC, IrfanView, Microsoft 365 Apps, Microsoft Office, Firefox, Thunderbird, Microsoft SQL Server Management Studio, Foxit PDF Editor and KeePass
  2021-12-10        Implement method to rewrite the language keys in the LastSetting.txt
  2021-12-13        Add RegKey for new script user (no update of the language keys at update)
  2021-12-16        Change language key update function
  2021-12-20        Correction deviceTRUST Install
  2021-12-27        New 7-Zip download function
  2022-01-10        Correction Teams User Based Download
  2022-01-12        Correction Microsoft PowerBI Desktop and Report Builder Version
  2022-01-13        Add disable GoToMeeting Update Schedulded Task / Correction 7-Zip Installer Function
  2022-02-03        Add new download function for Citrix WorkspaceApp Current Release (Web-Crawling) / Change download method to the new function
  2022-02-04        Correction Zoom HDX Media Plugin install
  2022-02-17        Rename Parameter -file to -ESfile / Change ImageGlass download
  2022-03-10        Correct the OneDrive update option
  2022-03-30        Correct the Google Chrome Version
  2022-03-31        Kill language correction
  2022-04-07        Correction Remode Desktop Manager Version
  2022-04-18        Correct the Microsoft Edge / Edge WebView2 Version
  2022-04-19        Change release from Microsoft Edge to Consumer (former Enterprise)
  2022-05-17        Add new x64 download links for Adobe Reader DC / Add download and install option for x64 Teamviewer
  2022-05-20        Change Regex for Remote Desktop Manager download / Add new option to download and install x64 and x86 Visual C++ Runtime at the same time
  2022-05-25        Add new option to download and install x64 and x86 openJDK at the same time
  2022-05-26        Correction auto restart after update with GUIFile Parameter
  2022-05-31        Add new option to download and install x64 and x86 Oracle Java 8 at the same time
  2022-06-01        Add Default Browser kill at Greenshot install
  2022-06-08        Correction PowerToys Download / Create Zoom VDI download function and correct the assignment / Add Ditto download function
  2022-06-10        Add Ditto install / Add Opera Browser download and install
  2022-06-17        Correction Mozilla Firefox CurrentVersion detection
  2022-06-20        Add XCA download and install
  2022-06-21        Correction Teamviewer download version
  2022-07-04        Correction msedge UviProcessExcludes reg entry / Add Ditto, Opera Browser and XCA to the GUI
  2022-07-06        Correction Microsoft Edge Registry
  2022-07-19        Renaming and correction auto update flow
  2022-08-04        Auto use PowerShell 7 when it is installed / Implement Global Log / Correction Microsoft PowerShell download
  2022-08-15        Add Microsoft PowerToys silent install parameter / Add new filter to PowerShell install detection
  2022-08-17        Add MUI to Adobe Acrobat Reader DC
  2022-08-23        Change Desktop detection
  2022-08-30        Suppress warning message at Zoom download
  2022-09-02        Change VMware Tools download methode / Add Chinese and Portuguese Language to Adobe Reader DC / Correction of x64 Adobe Reader DC download for several languages
  2022-09-08        Change MS PowerToys install behaviour / Correction XCA download
  2022-09-12        Error Action supress for Mozilla Firefox
  2022-10-27        Add No NeverRed Desktop Icon Option / Edit ControlUp Remote DX download function to although download the Microsoft AVD/RDP and VMware Horizon client / Edit ControlUp Remote DX download and install to the new function
  2022-10-28        Delete the Framework Path in the ControlUp Agent installer / Implemented the text fields for ControlUp Agent Auth Key, ControlUp Edge DX DevRegCode and Tenant Name / Make the text fields read and write in the folders of the programs / Delete Uber Agent / Change ControlUp Agent install with Auth Key
  2022-10-31        Add download function for ControlUp Edge DX Agent Manager / Add download and install of ControlUp Edge DX Agent Manager
  2022-11-03        Query adjusted so that only 1 result is returned for Mozilla Firefox
  2022-11-19        Correction Citrix Workspace App CR download
  2022-11-25        Implement Report Mode basic framework
  2022-11-27        Implement Report Mode for 1Password and 7-Zip
  2022-11-30        Implement Report Mode for Adobe Pro DC, Adobe Reader DC and Autodesk DWG TrueView
  2022-12-01        Implement Report Mode for BIS-F, Cisco Webex Teams and Citrix Files
  2022-12-02        Implement Report Mode for Citrix Hypervisor Tools, Citrix Workspace App, ControlUp Agent and ControlUp Edge DX
  2022-12-05        Implement Report Mode for ControlUp Remote DX, ControlUp Console, deviceTRUST and Ditto
  2022-12-07        Implement Report Mode for Filezilla, Foxit PDF Editor, Foxit Reader, GIMP, Git for Windows and Google Chrome
  2022-12-08        Implement Report Mode for GReenshot, IIS Crypto, ImageGlass, IrfanView, KeePass, LogMeIn GoToMeeting, Microsoft .Net Framework, Microsoft 365 Apps, Microsoft AVD Remote Desktop and Microsoft Azure CLI / Add Silent Warning to Microsoft AVD Remote Desktop download url search
  2022-12-11        Implement Report Mode for Microsoft Azure Data Studio, Microsoft Edge, Microsoft Edge WebView2, Microsoft FSLogix, Microsoft Office, Microsoft OneDrive, Microsoft Power BI Desktop, Microsoft Power BI Report Builder, Microsoft PowerShell, Microsoft PowerToys, Microsoft SQL Server Management Studio / Adaptation of the recognized versions for Microsoft SQL Server Management Studio to a uniform format
  2022-12-13        Implement Report Mode for Microsoft Sysinternals, Microsoft Teams, Microsoft Visual C++ Runtime, Microsoft Visual Studio 2019 and Microsoft Visual Studio Code
  2022-12-14        Implement Report Mode for MindView 7, Mozilla Firefox, Mozilla Thunderbird, mRemoteNG, Nmap, Notepad++, OpenJDK, Open-Shell Menu and Opera Browser
  2022-12-15        Implement Report Mode for Oracle Java 8, Paint.Net, PDF24 Creator, pdfforge PDFCreator, PDF Split & Merge, PeaZip and PuTTY
  2022-12-16        Implement Report Mode for Remote Desktop Manager, Remote Display Analyzer, Screenpresso, ShareX, Slack, Sumatra PDF and TeamViewer
  2022-12-17        Implement Report Mode for TechSmith Camtasia, TechSmith Snagit, Total Commander, TreeSize and VLC Player
  2022-12-18        Implement Report Mode for VMwareTools, WinMerge, WinRAR, WinSCP, Wireshark, XCA and Zoom
  2022-12-19        Correction 1Password install to not silent / Correction Autodesk DWG TrueView installer path / Correction BIS-F install version
  2022-12-20        Correction Installer for Cisco Webex Teams and Cisco Webex Teams VDI Plugin
  2022-12-21        Correction Cisco Webex Teams version
  2022-12-23        Correction Citrix Workspace App version / Correction Citrix Workspace App Current Release downloader function / Correction MS .Net Framework version / Correction MS Sysinternals version / Correction MindView download and version / Correction Mozilla ThunderBird download
  2022-12-24        Correction OpenJDK version
  2022-12-26        Add Opera Browser Version / Correction Microsoft Teams User Based Install version / Correction PuTTY version / Correction Screenpresso version / Correction VMware Tools version / Correction XCA download / Correction Zoom download / Create Citrix Optimizer function
  2022-12-27        Create SDelete function
  2022-12-28        Correction KeePass Version
  2023-01-02        Create DelProf2 function
  2023-01-03        Create download section for BIS-F Additional Tools
  2023-01-04        Correction ControlUp Agent Auth Key
  2023-01-06        Correction BIS-F Current Version install / Implement copy of BIS-F Additional Tools
  2023-01-16        Correction VMware Name / Correction download function for Citrix Optimizer and DelProf2 for PS5
  2023-01-19        Correction ControlUp Agent download
  2023-02-27        Correction ControlUp Agent download
  2023-03-02        Add loop to recognize the ps version and use different subobjects in MS Visual C++ Download / Correction of the save methode of ControlUp Auth Key and ControlUp Edge DX Keys
  2023-03-07        Correction Microsoft Teams Installer version / Correction Zoom VDI download
  2023-03-27        Correction ImageGlass Download
  2023-04-14        Correction Microsoft Teams Pre Preview Deyploment Download
  2023-04-17        Correction Microsoft PowerToys Download / Correction version comparison for PDF24 Creator / Kill the Update Message from Microsoft PowerToys / Correction version comparison for Microsoft PowerShell / Correction Microsoft Teams UserBased Download / Correction version comparison for Microsoft Teams UserBased / Correction Filezilla Download
  2023-05-19        Correction Microsoft Power BI Desktop version comparison
  2023-05-23        Correction Filezilla download / Add Adopt Open JDK download and install / Add Adopt Open JDK Iced Tea Web download and install / Add Bloomberg Terminal download and install / Add Google Drive download and install / Add MS Teams AVD regsitry key option
  2023-05-24        Add Jabra Direct download function / Add Jabra Direct download and install
  2023-05-26        Add OpenWebStart download and install
  2023-06-20        Correct Microsoft Teams Download options
  2023-07-13        Correct Citrix Optimizer Download / Add cleanup for Foxit Reader / Add Windows Update PS Module
  2023-09-21        Correct Google Chrome Download
  2023-10-05        Correct MS FSLogix Download
  2023-10-22        Correct MS Teams User Based Download
  2023-11-12        Correct ControlUp Agent Version
  2023-11-24        Correct ImageGlass Version / Correct Citrix Workspace App Version
  2024-01-04        Add new Teams Version
  2024-01-21        Add download function for Microsoft Teams 2
  2024-01-22        Add install function Microsoft Teams 2
  2024-02-05        Add new Microsoft Power BI Desktop download function
  2024-02-08        Correct Citrix Optimizer Tool Version
  2024-03-04        Correction FSLogix Installation path / Correction install.xml file for M365 Apps
  2024-03-05        Correction Microsoft Teams Version 2
  2024-03-06        Correction on Scheduled Task for Microsodft Teams 2
  2024-03-14        Correction typo (thx Ray Davis)
  2024-04-10        Correction Microsoft Teams Install
  2024-04-23        Correction Microsoft Teams Install / Correction DLLs for Microsoft Teams 2
  2024-04-28        Correction of the Micrsooft Teams 2 install flow
  2024-05-03        Correction of Powershell Module Update
  2024-05-11        Correction first run Teams 2 download (Thx to chezzer64) / Corretion Workspace App typo / Correction Workspace App Version and download url
  2024-05-13        Correction MS OneDrive download
  2024-05-23        Correction GoogleChrome Variables / Correction Citrix Workspace App download and install
  2024-06-05        Correction Firefox Channel download / Correction Gimp download
  2024-06-17        Correction download .Net Framework current / Correction Mozilla Firefox download and add Developer Channel / Correction Firefox Disable Auto Update / Correction Chrome Disable Auto Update
  2024-07-08        Correction Teams 2 Installation / Customize initials output
  2024-07-19        Correction Citrix Workspace App
  2024-08-01        Correction Adobe Reader DC
  2024-08-07        Extend Output for the PS Modules / Correction XCA Download / Correction Wireshark Download / Correction VMware Tools / Correction Adobe Reader DC

.PARAMETER ESfile

Path to file (LastSetting.txt) for software selection in unattended mode.

.PARAMETER GUIfile

Path to GUI file (LastSetting.txt) for software selection in GUI mode.

.EXAMPLE

.\NeverRed.ps1 -ESfile LastSetting.txt

Download and / or Install the selected Software out of the file.

.EXAMPLE

.\NeverRed.ps1 -GUIfile LastSetting.txt

Start the GUI with the options out of the file.

.EXAMPLE

.\NeverRed.ps1

Start the GUI to select the mode (Install and/or Download) and the Software.
#>

[CmdletBinding()]

Param (

        [Parameter(
            HelpMessage='File with Software Selection for Unattended Mode',
            ValuefromPipelineByPropertyName = $true
        )]
        [string]$ESfile,
    
        [Parameter(
            HelpMessage='File with Software Selection for GUI Mode',
            ValuefromPipelineByPropertyName = $true
        )]
        [string]$GUIfile,

        [Parameter(
            HelpMessage='Do not check the PowerShell Modules',
            ValuefromPipelineByPropertyName = $true
        )]
        [switch]$NoPSModuleCheck,

        [Parameter(
            HelpMessage='Do not check the PowerShell Modules',
            ValuefromPipelineByPropertyName = $true
        )]
        [switch]$NoUpdate
    
)

# Add Functions here

# Function OpenFile Dialog
#========================================================================================================================================
function Show-OpenFileDialog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false, Position=0)]
        [System.String]
        $Title = 'Browse',
         
        [Parameter(Mandatory=$false, Position=1)]
        [Object]
        $InitialDirectory = "$PSScriptRoot",
         
        [Parameter(Mandatory=$false, Position=2)]
        [System.String]
        $Filter = 'Extensible Markup Language | *.xml'
    )
     
    Add-Type -AssemblyName PresentationFramework
     
    $dialog = New-Object -TypeName Microsoft.Win32.OpenFileDialog
    $dialog.Title = $Title
    $dialog.InitialDirectory = $InitialDirectory
    $dialog.Filter = $Filter
    if ($dialog.ShowDialog())
    {
        $dialog.FileName
        $WPFTextBox_Filename.Text = $dialog.FileName
    }
    else
    {
        Write-Host -ForegroundColor Red  'Nothing selected.'   
    }
}

# Function MSI Installation
#========================================================================================================================================
Function Install-MSI {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true)]
        $msiFile, 
        $Arguments
    )
    If (!(Test-Path $msiFile)) {
        Write-Host -ForegroundColor Red "Path to MSI file ($msiFile) is invalid. Please check name and path"
    }
    $inst = $process = Start-Process -FilePath msiexec.exe -ArgumentList $Arguments -NoNewWindow -PassThru
    If ($inst) {
            Wait-Process -InputObject $inst
    }
    If ($process.ExitCode -eq 0) {
        Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
        DS_WriteLog "I" "Installation $Product finished!" $LogFile
    }
    Else {
        Write-Host -ForegroundColor Red "Error installing $Product (Exit Code $($process.ExitCode) for file $($msifile))"
    }
}

# Function File Download with Progress Bar
#========================================================================================================================================
Function Get-Download {
    Param (
        [Parameter(Mandatory=$true)]
        $url, 
        $destinationFolder="$PSScriptRoot\$Product\",
        $fileD="$Source",
        [switch]$includeStats
    )
    $wc = New-Object Net.WebClient
    $wc.UseDefaultCredentials = $true
    $destination = Join-Path $destinationFolder $fileD
    $start = Get-Date
    $wc.DownloadFile($url, $destination)
    $elapsed = ((Get-Date) - $start).ToString('hh\:mm\:ss')
    $totalSize = (Get-Item $destination).Length | Get-FileSize
    If ($includeStats.IsPresent){
        $DownloadStat = [PSCustomObject]@{TotalSize=$totalSize;Time=$elapsed}
        Write-Information $DownloadStat
    }
    Get-Item $destination | Unblock-File
}
Filter Get-FileSize {
	"{0:N2} {1}" -f $(
	If ($_ -lt 1kb) { $_, 'Bytes' }
	ElseIf ($_ -lt 1mb) { ($_/1kb), 'KB' }
	ElseIf ($_ -lt 1gb) { ($_/1mb), 'MB' }
	ElseIf ($_ -lt 1tb) { ($_/1gb), 'GB' }
	ElseIf ($_ -lt 1pb) { ($_/1tb), 'TB' }
	Else { ($_/1pb), 'PB' }
	)
}

# Function 7-Zip Download
#========================================================================================================================================
Function Get-7-Zip {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://www.7-zip.org/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'Download 7-Zip .* for Windows'
        $webVersion7Z = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersion7Z.Split(" ")
        $Version = $webSplit[2]
        $VersionSplit = $webSplit[2]
        $appVersion = $VersionSplit.Replace('.','')
        $x64 = "https://www.7-zip.org/a/7z" + "$appVersion" + "-x64.exe"
        $x32 = "https://www.7-zip.org/a/7z" + "$appVersion" + ".exe"


        $PSObjectx32 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x86"
        URI          = $x32
        }

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x64"
        URI          = $x64
        }
        Write-Output -InputObject $PSObjectx32
        Write-Output -InputObject $PSObjectx64
    }
}

# Function Screenpresso Download
#========================================================================================================================================
Function Get-Screenpresso {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://www.screenpresso.com/download/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Enterprise deployment \(.*\)<"
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersion.Split("(")[1].Split(")")[0]
        $x64 = "https://www.screenpresso.com/binaries/releases/stable/dotnet47/ScreenpressoSetup.msi"

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $appVersion
        URI          = $x64
        }
        Write-Output -InputObject $PSObjectx64
    }
}

# Function IISCrypto Download
#========================================================================================================================================
Function Get-IISCrypto {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://www.nartac.com/Products/IISCrypto/Download"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'line-header">Version .* '
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersion.Split(" ")[1]
        $x64 = "https://www.nartac.com/Downloads/IISCrypto/IISCrypto.exe"

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $appVersion
        URI          = $x64
        }
        Write-Output -InputObject $PSObjectx64
    }
}

# Function VMware Tools Download
#========================================================================================================================================
Function Get-VMwareTools {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $urlx64 = "https://packages.VMware.com/tools/releases/latest/windows/x64/"
        $urlx86 = "https://packages.VMware.com/tools/releases/latest/windows/x86/"
    Try {
        $webx64 = Invoke-WebRequest -UseBasicParsing -Uri $urlx64 -ErrorAction SilentlyContinue
        $webx86 = Invoke-WebRequest -UseBasicParsing -Uri $urlx86 -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $urlx64 with error $_."
        Break
    }
    Finally {
        $regexAppVersion = '-[0-9][0-9].[0-9].[0-9]-'
        $regexAppURL = 'VMware-tools-.*exe'
        $webVersionx64 = $webx64.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webURLx64 = $webx64.RawContent | Select-String -Pattern $regexAppURL -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webURLx64Split = $webURLx64.Split(">")
        $webURLx64Split2 = $webURLx64Split[0].Replace('"','')
        $webVersionx64 = $webVersionx64.Replace('-','')
        $webVersionx86 = $webx86.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webURLx86 = $webx86.RawContent | Select-String -Pattern $regexAppURL -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webURLx86Split = $webURLx86.Split(">")
        $webURLx86Split2 = $webURLx86Split[0].Replace('"','')
        $webVersionx86 = $webVersionx86.Replace('-','')
        $x32 = "https://packages.VMware.com/tools/releases/latest/windows/x86/$webURLx86Split2"
        $x64 = "https://packages.VMware.com/tools/releases/latest/windows/x64/$webURLx64Split2"


        $PSObjectx32 = [PSCustomObject] @{
        Version      = $webVersionx86
        Architecture = "x86"
        URI          = $x32
        }

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $webVersionx64
        Architecture = "x64"
        URI          = $x64
        }
        Write-Output -InputObject $PSObjectx32
        Write-Output -InputObject $PSObjectx64
    }
}

# Function IrfanView Download
#========================================================================================================================================
Function Get-IrfanView {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://www.irfanview.com/"
    Try {
        $web = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $m = $web.ToString() -split "[`r`n]" | Select-String "Version" | Select-Object -First 1
        $m = $m -replace "<((?!@).)*?>"
        $m = $m.Replace(' ','')
        $Version = $m -replace "Version"
        #$FileI = $Version -replace "\.",""
        $x32 = "https://www.techspot.com/downloads/downloadnow/299/?evp=893edf43f99033113608d9a805221b92&file=372"
        $x64 = "https://www.techspot.com/downloads/downloadnow/299/?evp=2bc137b9206e4001fbe10993002f0fb0&file=371"


        $PSObjectx32 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x86"
        Language     = "english"
        URI          = $x32
        }

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x64"
        Language     = "english"
        URI          = $x64
        }
        Write-Output -InputObject $PSObjectx32
        Write-Output -InputObject $PSObjectx64
    }
}

# Function Microsoft Teams Download Developer & Beta Version
#========================================================================================================================================
Function Get-MicrosoftTeamsDevBeta() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://github.com/ItzLevvie/MicrosoftTeams-msinternal/blob/master/defconfig"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersionx64dev = '\<td id="LC2".+<\/td\>'
        $webVersionx64dev = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx64dev -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx64dev = $webVersionx64dev.Split("/")
        $appVersionx64dev = $webSplitx64dev[4]
        $regexAppVersionx86dev = '\<td id="LC5".+<\/td\>'
        $webVersionx86dev = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx86dev -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx86dev = $webVersionx86dev.Split("/")
        $appVersionx86dev = $webSplitx86dev[4]
        $regexAppVersionx64beta = '\<td id="LC12".+<\/td\>'
        $webVersionx64beta = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx64beta -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx64beta = $webVersionx64beta.Split("/")
        $appVersionx64beta = $webSplitx64beta[4]
        $regexAppVersionx86beta = '\<td id="LC14".+<\/td\>'
        $webVersionx86beta = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx86beta -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx86beta = $webVersionx86beta.Split("/")
        $appVersionx86beta = $webSplitx86beta[4]
        $appx64URLdev = "https://statics.teams.cdn.office.net/production-windows-x64/$appVersionx64dev/Teams_windows_x64.msi"
        $appx86URLdev = "https://statics.teams.cdn.office.net/production-windows/$appVersionx86dev/Teams_windows.msi"
        $appx64URLbeta = "https://statics.teams.cdn.office.net/production-windows-x64/$appVersionx64beta/Teams_windows_x64.msi"
        $appx86URLbeta = "https://statics.teams.cdn.office.net/production-windows/$appVersionx86beta/Teams_windows.msi"

        $PSObjectx86dev = [PSCustomObject] @{
            Version      = $appVersionx86dev
            Ring         = "Developer"
            Architecture = "x86"
            URI          = $appx86URLdev
        }

        $PSObjectx64dev = [PSCustomObject] @{
            Version      = $appVersionx64dev
            Ring         = "Developer"
            Architecture = "x64"
            URI          = $appx64URLdev
        }

        $PSObjectx86beta = [PSCustomObject] @{
            Version      = $appVersionx86beta
            Ring         = "Exploration"
            Architecture = "x86"
            URI          = $appx86URLbeta
        }

        $PSObjectx64beta = [PSCustomObject] @{
            Version      = $appVersionx64beta
            Ring         = "Exploration"
            Architecture = "x64"
            URI          = $appx64URLbeta
        }
        Write-Output -InputObject $PSObjectx86dev
        Write-Output -InputObject $PSObjectx64dev
        Write-Output -InputObject $PSObjectx86beta
        Write-Output -InputObject $PSObjectx64beta
    }
}

# Function Microsoft Teams Download User Version
#========================================================================================================================================
Function Get-MicrosoftTeamsUser() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://github.com/ItzLevvie/MicrosoftTeams-msinternal/blob/master/defconfig"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
        $TeamsUserVersionGeneral = Get-EvergreenApp -Name MicrosoftTeams | Where-Object { $_.Architecture -eq "x64" -and $_.Ring -eq "General" -and $_.Type -eq "msi"}
        $VersionGeneral = $TeamsUserVersionGeneral.Version
        $TeamsUserVersionPreview = Get-EvergreenApp -Name MicrosoftTeams | Where-Object { $_.Architecture -eq "x64" -and $_.Ring -eq "Preview" -and $_.Type -eq "msi"}
        $VersionPreview = $TeamsUserVersionPreview.Version
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersionx64dev = 'daily build of Microsoft Teams.{16}'
        $webVersionx64dev = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx64dev -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx64dev = $webVersionx64dev.Split('\"')
        $webSplitx64dev = $webSplitx64dev[2].Split(' ')
        $appVersionx64dev = $webSplitx64dev[0]
        $appVersionx86dev = $appVersionx64dev
        $regexAppVersionx64beta = 'experimental build of Microsoft Teams.{16}'
        $webVersionx64beta = $webRequest.RawContent | Select-String -Pattern $regexAppVersionx64beta -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitx64beta = $webVersionx64beta.Split('\"')
        $appVersionx64beta = $webSplitx64beta[2]
        $appVersionx86beta = $appVersionx64beta
        $appx64URLdev = "https://staticsint.teams.cdn.office.net/production-windows-x64/$appVersionx64dev/Teams_windows_x64.exe"
        $appx86URLdev = "https://staticsint.teams.cdn.office.net/production-windows/$appVersionx86dev/Teams_windows.exe"
        $appx64URLbeta = "https://staticsint.teams.cdn.office.net/production-windows-x64/$appVersionx64beta/Teams_windows_x64.exe"
        $appx86URLbeta = "https://staticsint.teams.cdn.office.net/production-windows/$appVersionx86beta/Teams_windows.exe"
        $appx64URLG = "https://statics.teams.cdn.office.net/production-windows-x64/$VersionGeneral/Teams_windows_x64.exe"
        $appx86URLG = "https://statics.teams.cdn.office.net/production-windows/$VersionGeneral/Teams_windows.exe"
        $appx64URLP = "https://statics.teams.cdn.office.net/production-windows-x64/$VersionPreview/Teams_windows_x64.exe"
        $appx86URLP = "https://statics.teams.cdn.office.net/production-windows/$VersionPreview/Teams_windows.exe"

        $PSObjectx86G = [PSCustomObject] @{
            Version      = $VersionGeneral
            Ring         = "General"
            Architecture = "x86"
            URI          = $appx86URLG
        }

        $PSObjectx64G = [PSCustomObject] @{
            Version      = $VersionGeneral
            Ring         = "General"
            Architecture = "x64"
            URI          = $appx64URLG
        }

        $PSObjectx86P = [PSCustomObject] @{
            Version      = $VersionPreview
            Ring         = "Preview"
            Architecture = "x86"
            URI          = $appx86URLP
        }

        $PSObjectx64P = [PSCustomObject] @{
            Version      = $VersionPreview
            Ring         = "Preview"
            Architecture = "x64"
            URI          = $appx64URLP
        }

        $PSObjectx86dev = [PSCustomObject] @{
            Version      = $appVersionx86dev
            Ring         = "Continuous Deployment"
            Architecture = "x86"
            URI          = $appx86URLdev
        }

        $PSObjectx64dev = [PSCustomObject] @{
            Version      = $appVersionx64dev
            Ring         = "Continuous Deployment"
            Architecture = "x64"
            URI          = $appx64URLdev
        }

        $PSObjectx86beta = [PSCustomObject] @{
            Version      = $appVersionx86beta
            Ring         = "Exploration"
            Architecture = "x86"
            URI          = $appx86URLbeta
        }

        $PSObjectx64beta = [PSCustomObject] @{
            Version      = $appVersionx64beta
            Ring         = "Exploration"
            Architecture = "x64"
            URI          = $appx64URLbeta
        }

        Write-Output -InputObject $PSObjectx86G
        Write-Output -InputObject $PSObjectx64G
        Write-Output -InputObject $PSObjectx86P
        Write-Output -InputObject $PSObjectx64P
        Write-Output -InputObject $PSObjectx86beta
        Write-Output -InputObject $PSObjectx64beta
        Write-Output -InputObject $PSObjectx86dev
        Write-Output -InputObject $PSObjectx64dev
    }
}

# Function PDF Split & Merge Download
#========================================================================================================================================
Function Get-PDFsam() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://pdfsam.org/en/download-pdfsam-basic/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Download PDFsam Basic v.{5}"
        $webVersionPDFsam = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionPDFsam.Split()[3].Trim("v")
        $appx64URL = "https://github.com/torakiki/pdfsam/releases/download/v$appVersion/pdfsam-$appVersion.msi"

        $PSObjectx64 = [PSCustomObject] @{
            Version      = $appVersion
            Channel      = "Stable"
            Architecture = "x64"
            URI          = $appx64URL
        }

        Write-Output -InputObject $PSObjectx64
        
    }
}

# Function Citrix WorkspaceAppCurrent
#========================================================================================================================================
Function Get-WorkspaceAppCurrent() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.citrix.com/downloads/workspace-app/windows/workspace-app-for-windows-latest.html"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Version:.*\(.*\)"
        $webVersionCWA = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $appDLVersion = $webVersionCWA.Split()[1]
        $appDLVersion = $appDLVersion.Split("(")[0]
        #$appURL = "https://downloadplugins.citrix.com/ReceiverUpdates/Prod/Receiver/Win/CitrixWorkspaceApp$appDLVersion.exe"
        $appURL = "https://downloads.citrix.com/22681/CitrixWorkspaceApp.exe?__gda__=exp=1715472841~acl=/*~hmac=d66687ace98d8fef5c93aa5ee0e55340795cd1263bf4091372f24c0f27a0f807"

        $PSObject = [PSCustomObject] @{
            Version      = $appDLVersion
            Stream      = "Current"
            URI          = $appURL
        }

        Write-Output -InputObject $PSObject
        
    }
}

# Function Microsoft FSlogix Stable (Preferred by Deyda) Download
#========================================================================================================================================
Function Get-MSFSLogix() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://mw2301-my.sharepoint.com/:u:/g/personal/manuel_deyda_net/ESKhpNRTBsJKnBLOeoo9B-MBZ0PNfMXy342K4akivlUewQ?e=JmFn9d"
    Try {
        #$webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $appxURL = "https://www.deyda.net/wp-content/uploads/2021/12/fslogix_apps_29734930108.zip"

        $PSObjectx = [PSCustomObject] @{
            Version      = "2.9.7349.30108"
            URI          = $appxURL
        }

        Write-Output -InputObject $PSObjectx
        
    }
}

# Function ControlUp Remote DX Download
#========================================================================================================================================
Function Get-ControlUpRemoteDX() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.controlup.com/products/controlup/download-center/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Windows.*\(.*\)"
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webVersion = $webVersion.Split("(")[1].Trim(")")
        $appVersion = $webVersion.Split("version ")[1]

        $appxURLCitrix = "https://downloads.controlup.com/RemoteDX/citrix/windows/curdx_windows_citrix.exe"
        $appxURLVMware = "https://downloads.controlup.com/RemoteDX/VMware/windows/curdx_windows_VMware.exe"
        $appxURLMicrosoft = "https://downloads.controlup.com/RemoteDX/microsoft/windows/curdx_windows_microsoft.exe"

        $PSObjectctx = [PSCustomObject] @{
            Environment  = "Citrix CVAD"
            Version      = $appVersion
            URI          = $appxURLCitrix
        }

        $PSObjectVMware = [PSCustomObject] @{
            Environment  = "VMware Horizon"
            Version      = $appVersion
            URI          = $appxURLVMware
        }

        $PSObjectMicrosoft = [PSCustomObject] @{
            Environment  = "Microsoft AVD & RDP"
            Version      = $appVersion
            URI          = $appxURLMicrosoft
        }

        Write-Output -InputObject $PSObjectctx
        Write-Output -InputObject $PSObjectVMware
        Write-Output -InputObject $PSObjectMicrosoft
        
    }
}

# Function ControlUp Edge DX Download
#========================================================================================================================================
Function Get-ControlUpEdgeDX() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.controlup.com/controlup-release-notes"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Version.*Build.*\)"
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersion.Split(" ")[-1].Trim(")")

        $appxURL = "https://downloads.sip.controlup.com/agentmanagersetup.msi"

        $PSObject = [PSCustomObject] @{
            Version      = $appVersion
            URI          = $appxURL
        }

        Write-Output -InputObject $PSObject

    }
}

# Function Cisco Webex Teams Download
#========================================================================================================================================
Function Get-CiscoWebex() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.webex.com/downloads/teams-vdi.html"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Webex App.*\(.*\)"
        $regexAppURL64 = "vdi-hvd-aws-gold\/.*\/Webex\.msi"
        $regexAppURL32 = "vdi-hvd-aws-gold\/.*\/Webex_x86\.msi"
        $webVersionCW = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionCW.Split("(")[1].Trim(")")
        $webURL64 = $webRequest.RawContent | Select-String -Pattern $regexAppURL64 -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appxURL64 = "https://binaries.webex.com/" + $webURL64
        $webURL32 = $webRequest.RawContent | Select-String -Pattern $regexAppURL32 -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appxURL32 = "https://binaries.webex.com/" + $webURL32

        $PSObjectx64 = [PSCustomObject] @{
            Version      = "$appVersion"
            Architecture = "x64"
            URI          = $appxURL64
        }
        $PSObjectx86 = [PSCustomObject] @{
            Version      = "$appVersion"
            Architecture = "x86"
            URI          = $appxURL32
        }

        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx86
    }
}

# Function Cisco Webex VDI Plugin Download
#========================================================================================================================================
Function Get-CiscoWebexVDI() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.webex.com/downloads/teams-vdi.html"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Webex App VDI Plugin.*\(.*\)"
        $regexAppURL64 = "WebexTeamsDesktop-Windows-VDI-gold-Production\/.*\/WebexVDIPlugin\.msi"
        $regexAppURL32 = "WebexTeamsDesktop-Windows-VDI-gold-Production\/.*\/WebexVDIPlugin_x86\.msi"
        $webVersionCW = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionCW.Split("(")[1].Trim(")")
        $webURL64 = $webRequest.RawContent | Select-String -Pattern $regexAppURL64 -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appxURL64 = "https://binaries.webex.com/" + $webURL64
        $webURL32 = $webRequest.RawContent | Select-String -Pattern $regexAppURL32 -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appxURL32 = "https://binaries.webex.com/" + $webURL32

        $PSObjectx64 = [PSCustomObject] @{
            Version      = "$appVersion"
            Architecture = "x64"
            URI          = $appxURL64
        }
        $PSObjectx86 = [PSCustomObject] @{
            Version      = "$appVersion"
            Architecture = "x86"
            URI          = $appxURL32
        }

        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx86
    }
}

# Function Autodesk DWG TrueView Download
#========================================================================================================================================
Function Get-DWGTrueView() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.autodesk.com/products/dwg-trueview/overview"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "DWGTrueView_.{4}"
        $webVersionDWG = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionDWG.Split("_")[1]
        
        $regexAppURL = "https://efulfillment.*DWGTrueView_" + "$appVersion" + ".*_English_64bit_dlm.sfx.exe"
        $webURL = $webRequest.RawContent | Select-String -Pattern $regexAppURL -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appx64URL = $webURL.Split('"')[0]

        $PSObjectx64 = [PSCustomObject] @{
            Version      = $appVersion
            Language      = "English"
            Architecture = "x64"
            URI          = $appx64URL
        }

        Write-Output -InputObject $PSObjectx64
        
    }
}

# Function Total Commander Download
#========================================================================================================================================
Function Get-TotalCommander() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.ghisler.com/ddownload.htm"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Total Commander Version .{5}"
        $webVersionTC = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionTC.Split(" ")[3]
        $URLappVersionSplit = $appVersion.Split(".")
        $URLappVersion = $URLappVersionSplit[0] + $URLappVersionSplit[1]
        
        $appx64URL = "https://totalcommander.ch/win/tcmd" + "$URLappVersion" + "x64.exe"
        $appx32URL = "https://totalcommander.ch/win/tcmd" + "$URLappVersion" + "x32.exe"
        
        $PSObjectx64 = [PSCustomObject] @{
            Version      = $appVersion
            Architecture = "x64"
            URI          = $appx64URL
        }

        $PSObjectx32 = [PSCustomObject] @{
            Version      = $appVersion
            Architecture = "x86"
            URI          = $appx32URL
        }

        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx32
    }
}

# Function Bloomberg Terminal Download
#========================================================================================================================================
Function Get-Bloomberg() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.bloomberg.com/professional/support/software-updates/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "sotr.{12}"
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersion.Replace("_", ".").Trim("sotr").Trim(".exe")
        
        $appURL = "https://bdn-ak-ssl.bloomberg.com/software/trv/" + "$webVersion"
        
        $PSObject = [PSCustomObject] @{
            Version      = $appVersion
            URI          = $appURL
        }

        Write-Output -InputObject $PSObject
    }
}

# Function Jabra Direct Download
#========================================================================================================================================
Function Get-JabraDirect() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.jabra.com/Support/release-notes/release-note-jabra-direct"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "((?:\d+\.)+\d+)<br>"
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersion.Trim("<br>")
        
        $appURL = "https://jabraxpressonlineprdstor.blob.core.windows.net/jdo/JabraDirectSetup.exe"
        
        $PSObject = [PSCustomObject] @{
            Version      = $appVersion
            URI          = $appURL
        }

        Write-Output -InputObject $PSObject
    }
}

# Function pdfforge PDFCreator
#========================================================================================================================================
Function Get-pdfforgePDFCreator() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersionFree = "https://download.pdfforge.org/download/pdfcreator"
    $appURLVersionProfessional = "https://download.pdfforge.org/download/pdfcreator-professional"
    $appURLVersionTerminal = "https://download.pdfforge.org/download/pdfcreator-terminal-server"
    Try {
        $webRequestFree = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersionFree) -SessionVariable websession
        $webRequestProfessional = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersionProfessional) -SessionVariable websession
        $webRequestTerminal = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersionTerminal) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Stable Release.{6}"

        $webVersionFree = $webRequestFree.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersionFree = $webVersionFree.Split(" ")[2]
        $webURLFree = "https://download.pdfforge.org/download/pdfcreator/PDFCreator-stable?download"

        $webVersionProfessional = $webRequestProfessional.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersionProfessional = $webVersionProfessional.Split(" ")[2]
        $webURLProfessional = "https://download.pdfforge.org/download/pdfcreator-professional/PDFCreatorProfessional-stable?download"

        $webVersionTerminal = $webRequestTerminal.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersionTerminal = $webVersionTerminal.Split(" ")[2]
        $webURLTerminal = "https://download.pdfforge.org/download/pdfcreator-terminal-server/PDFCreatorTerminalServer-stable?download"

        $PSObjectFree = [PSCustomObject] @{
            Version      = $appVersionFree
            Channel      = "Free"
            URI          = $webURLFree
        }

        $PSObjectProfessional = [PSCustomObject] @{
            Version      = $appVersionProfessional
            Channel      = "Professional"
            URI          = $webURLProfessional
        }

        $PSObjectTerminal = [PSCustomObject] @{
            Version      = $appVersionTerminal
            Channel      = "Terminal Server"
            URI          = $webURLTerminal
        }

        Write-Output -InputObject $PSObjectFree
        Write-Output -InputObject $PSObjectProfessional
        Write-Output -InputObject $PSObjectTerminal
    }
}

# Function PDF24 Creator Download
#========================================================================================================================================
Function Get-PDF24Creator() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://creator.pdf24.org/listVersions.php"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "pdf24-creator-.*"
        $webVersionPDF24 = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersionPDF24 = $webVersionPDF24.Split("-")[2]
        $appVersionPDF24 = $appVersionPDF24.Split("exe")[0]
        $appVersion = $appVersionPDF24.Split("\.")
        $appVersion = $appVersion[0] + "." + $appVersion[1] + "." + $appVersion[2]
        $appx64URL = "https://creator.pdf24.org/download/pdf24-creator-" + "$appVersion" + ".msi"

        $PSObjectx64 = [PSCustomObject] @{
            Version      = $appVersion
            URI          = $appx64URL
        }

        Write-Output -InputObject $PSObjectx64
    }
}

# Function Microsoft Power BI Desktop Download
#========================================================================================================================================
Function Get-MicrosoftPowerBIDesktop() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.microsoft.com/en-us/download/details.aspx?id=58494"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "Version:<.+?>((?:\d+\.)+\d+)"
        $webVersionMicrosoftPowerBIDesktop = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $appVersion = $webVersionMicrosoftPowerBIDesktop.Split(">")[2]
        $appx64URL = "https://download.microsoft.com/download/8/8/0/880BCA75-79DD-466A-927D-1ABF1F5454B0/PBIDesktopSetup_x64.exe"
        $appx32URL = "https://download.microsoft.com/download/8/8/0/880BCA75-79DD-466A-927D-1ABF1F5454B0/PBIDesktopSetup.exe"


        $PSObjectx64 = [PSCustomObject] @{
            Architecture = "x64"
            Version      = $appVersion
            URI          = $appx64URL
        }
        $PSObjectx32 = [PSCustomObject] @{
            Architecture = "x32"
            Version      = $appVersion
            URI          = $appx32URL
        }

        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx32
    }
}

# Function WinRAR Download
#========================================================================================================================================
Function Get-WinRAR() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.rarlab.com/download.htm"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersionbeta = 'center\">.*beta.{2}'
        
        $regexAppVersionen = "<tr>\n.*\n.*English.*\n.*\n.*.*\n<\/tr>"
        $webVersionproden = $webRequest.RawContent | Select-String -Pattern $regexAppVersionen -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerproden = $webVersionproden.Line.Split(">")[2]
        $installerproden = $installerproden.Split('"')[1]
        $appversionproden = $webVersionproden.Line.Split(">")[8]
        $appversionproden = $appversionproden.Split("<")[0]
        $webVersionbetaen = $webRequest.RawContent | Select-String -Pattern $regexAppVersionen -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaen) {
            $installerbetaen = $webVersionbetaen.Line.Split(">")[2]
            $installerbetaen = $installerbetaen.Split('"')[1]
            $appversionbetaen = $webVersionbetaen.Line.Split(">")[8]
            $appversionbetaen = $appversionbetaen.Split("<")[0]
        }
        $webVersionprod32en = $webRequest.RawContent | Select-String -Pattern $regexAppVersionen -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32en = $webVersionprod32en.Line.Split(">")[2]
        $installerprod32en = $installerprod32en.Split('"')[1]
        $appversionprod32en = $webVersionprod32en.Line.Split(">")[8]
        $appversionprod32en = $appversionprod32en.Split("<")[0]
        $webVersionbeta32en = $webRequest.RawContent | Select-String -Pattern $regexAppVersionen -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32en) {
            $installerbeta32en = $webVersionbeta32en.Line.Split(">")[2]
            $installerbeta32en = $installerbeta32en.Split('"')[1]
            $appversionbeta32en = $webVersionbeta32en.Line.Split(">")[8]
            $appversionbeta32en = $appversionbeta32en.Split("<")[0]
        }

        $regexAppVersiondk = "<tr>\n.*\n.*Danish.*\n.*\n.*.*\n<\/tr>"
        $webVersionproddk = $webRequest.RawContent | Select-String -Pattern $regexAppVersiondk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerproddk = $webVersionproddk.Line.Split(">")[2]
        $installerproddk = $installerproddk.Split('"')[1]
        $appversionproddk = $webVersionproddk.Line.Split(">")[8]
        $appversionproddk = $appversionproddk.Split("<")[0]
        $webVersionbetadk = $webRequest.RawContent | Select-String -Pattern $regexAppVersiondk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetadk) {
            $installerbetadk = $webVersionbetadk.Line.Split(">")[2]
            $installerbetadk = $installerbetadk.Split('"')[1]
            $appversionbetadk = $webVersionbetadk.Line.Split(">")[8]
            $appversionbetadk = $appversionbetadk.Split("<")[0]
        }
        $webVersionprod32dk = $webRequest.RawContent | Select-String -Pattern $regexAppVersiondk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32dk = $webVersionprod32dk.Line.Split(">")[2]
        $installerprod32dk = $installerprod32dk.Split('"')[1]
        $appversionprod32dk = $webVersionprod32dk.Line.Split(">")[8]
        $appversionprod32dk = $appversionprod32dk.Split("<")[0]
        $webVersionbeta32dk = $webRequest.RawContent | Select-String -Pattern $regexAppVersiondk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32dk) {
            $installerbeta32dk = $webVersionbeta32dk.Line.Split(">")[2]
            $installerbeta32dk = $installerbeta32dk.Split('"')[1]
            $appversionbeta32dk = $webVersionbeta32dk.Line.Split(">")[8]
            $appversionbeta32dk = $appversionbeta32dk.Split("<")[0]
        }

        $regexAppVersionnl = "<tr>\n.*\n.*Dutch.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodnl = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnl -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodnl = $webVersionprodnl.Line.Split(">")[2]
        $installerprodnl = $installerprodnl.Split('"')[1]
        $appversionprodnl = $webVersionprodnl.Line.Split(">")[8]
        $appversionprodnl = $appversionprodnl.Split("<")[0]
        $webVersionbetanl = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnl -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetanl) {
            $installerbetanl = $webVersionbetanl.Line.Split(">")[2]
            $installerbetanl = $installerbetanl.Split('"')[1]
            $appversionbetanl = $webVersionbetanl.Line.Split(">")[8]
            $appversionbetanl = $appversionbetanl.Split("<")[0]
        }
        $webVersionprod32nl = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnl -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32nl = $webVersionprod32nl.Line.Split(">")[2]
        $installerprod32nl = $installerprod32nl.Split('"')[1]
        $appversionprod32nl = $webVersionprod32nl.Line.Split(">")[8]
        $appversionprod32nl = $appversionprod32nl.Split("<")[0]
        $webVersionbeta32nl = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnl -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32nl) {
            $installerbeta32nl = $webVersionbeta32nl.Line.Split(">")[2]
            $installerbeta32nl = $installerbeta32nl.Split('"')[1]
            $appversionbeta32nl = $webVersionbeta32nl.Line.Split(">")[8]
            $appversionbeta32nl = $appversionbeta32nl.Split("<")[0]
        }
        
        $regexAppVersionfn = "<tr>\n.*\n.*Finnish.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodfn = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfn -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodfn = $webVersionprodfn.Line.Split(">")[2]
        $installerprodfn = $installerprodfn.Split('"')[1]
        $appversionprodfn = $webVersionprodfn.Line.Split(">")[8]
        $appversionprodfn = $appversionprodfn.Split("<")[0]
        $webVersionbetafn = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfn -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetafn) {
            $installerbetafn = $webVersionbetafn.Line.Split(">")[2]
            $installerbetafn = $installerbetafn.Split('"')[1]
            $appversionbetafn = $webVersionbetafn.Line.Split(">")[8]
            $appversionbetafn = $appversionbetafn.Split("<")[0]
        }
        $webVersionprod32fn = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfn -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32fn = $webVersionprod32fn.Line.Split(">")[2]
        $installerprod32fn = $installerprod32fn.Split('"')[1]
        $appversionprod32fn = $webVersionprod32fn.Line.Split(">")[8]
        $appversionprod32fn = $appversionprod32fn.Split("<")[0]
        $webVersionbeta32fn = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfn -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32fn) {
            $installerbeta32fn = $webVersionbeta32fn.Line.Split(">")[2]
            $installerbeta32fn = $installerbeta32fn.Split('"')[1]
            $appversionbeta32fn = $webVersionbeta32fn.Line.Split(">")[8]
            $appversionbeta32fn = $appversionbeta32fn.Split("<")[0]
        }

        $regexAppVersionfr = "<tr>\n.*\n.*French.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodfr = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodfr = $webVersionprodfr.Line.Split(">")[2]
        $installerprodfr = $installerprodfr.Split('"')[1]
        $appversionprodfr = $webVersionprodfr.Line.Split(">")[8]
        $appversionprodfr = $appversionprodfr.Split("<")[0]
        $webVersionbetafr = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetafr) {
            $installerbetafr = $webVersionbetafr.Line.Split(">")[2]
            $installerbetafr = $installerbetafr.Split('"')[1]
            $appversionbetafr = $webVersionbetafr.Line.Split(">")[8]
            $appversionbetafr = $appversionbetafr.Split("<")[0]
        }
        $webVersionprod32fr = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32fr = $webVersionprod32fr.Line.Split(">")[2]
        $installerprod32fr = $installerprod32fr.Split('"')[1]
        $appversionprod32fr = $webVersionprod32fr.Line.Split(">")[8]
        $appversionprod32fr = $appversionprod32fr.Split("<")[0]
        $webVersionbeta32fr = $webRequest.RawContent | Select-String -Pattern $regexAppVersionfr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32fr) {
            $installerbeta32fr = $webVersionbeta32fr.Line.Split(">")[2]
            $installerbeta32fr = $installerbeta32fr.Split('"')[1]
            $appversionbeta32fr = $webVersionbeta32fr.Line.Split(">")[8]
            $appversionbeta32fr = $appversionbeta32fr.Split("<")[0]
        }

        $regexAppVersionde = "<tr>\n.*\n.*German.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodde = $webRequest.RawContent | Select-String -Pattern $regexAppVersionde -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodde = $webVersionprodde.Line.Split(">")[2]
        $installerprodde = $installerprodde.Split('"')[1]
        $appversionprodde = $webVersionprodde.Line.Split(">")[8]
        $appversionprodde = $appversionprodde.Split("<")[0]
        $webVersionbetade = $webRequest.RawContent | Select-String -Pattern $regexAppVersionde -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetade) {
            $installerbetade = $webVersionbetade.Line.Split(">")[2]
            $installerbetade = $installerbetade.Split('"')[1]
            $appversionbetade = $webVersionbetade.Line.Split(">")[8]
            $appversionbetade = $appversionbetade.Split("<")[0]
        }
        $webVersionprod32de = $webRequest.RawContent | Select-String -Pattern $regexAppVersionde -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32de = $webVersionprod32de.Line.Split(">")[2]
        $installerprod32de = $installerprod32de.Split('"')[1]
        $appversionprod32de = $webVersionprod32de.Line.Split(">")[8]
        $appversionprod32de = $appversionprod32de.Split("<")[0]
        $webVersionbeta32de = $webRequest.RawContent | Select-String -Pattern $regexAppVersionde -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32de) {
            $installerbeta32de = $webVersionbeta32de.Line.Split(">")[2]
            $installerbeta32de = $installerbeta32de.Split('"')[1]
            $appversionbeta32de = $webVersionbeta32de.Line.Split(">")[8]
            $appversionbeta32de = $appversionbeta32de.Split("<")[0]
        }

        $regexAppVersionit = "<tr>\n.*\n.*Italian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodit = $webRequest.RawContent | Select-String -Pattern $regexAppVersionit -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodit = $webVersionprodit.Line.Split(">")[2]
        $installerprodit = $installerprodit.Split('"')[1]
        $appversionprodit = $webVersionprodit.Line.Split(">")[8]
        $appversionprodit = $appversionprodit.Split("<")[0]
        $webVersionbetait = $webRequest.RawContent | Select-String -Pattern $regexAppVersionit -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetait) {
            $installerbetait = $webVersionbetait.Line.Split(">")[2]
            $installerbetait = $installerbetait.Split('"')[1]
            $appversionbetait = $webVersionbetait.Line.Split(">")[8]
            $appversionbetait = $appversionbetait.Split("<")[0]
        }
        $webVersionprod32it = $webRequest.RawContent | Select-String -Pattern $regexAppVersionit -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32it = $webVersionprod32it.Line.Split(">")[2]
        $installerprod32it = $installerprod32it.Split('"')[1]
        $appversionprod32it = $webVersionprod32it.Line.Split(">")[8]
        $appversionprod32it = $appversionprod32it.Split("<")[0]
        $webVersionbeta32it = $webRequest.RawContent | Select-String -Pattern $regexAppVersionit -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32it) {
            $installerbeta32it = $webVersionbeta32it.Line.Split(">")[2]
            $installerbeta32it = $installerbeta32it.Split('"')[1]
            $appversionbeta32it = $webVersionbeta32it.Line.Split(">")[8]
            $appversionbeta32it = $appversionbeta32it.Split("<")[0]
        }

        $regexAppVersionjp = "<tr>\n.*\n.*Japanese.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodjp = $webRequest.RawContent | Select-String -Pattern $regexAppVersionjp -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodjp = $webVersionprodjp.Line.Split(">")[2]
        $installerprodjp = $installerprodjp.Split('"')[1]
        $appversionprodjp = $webVersionprodjp.Line.Split(">")[8]
        $appversionprodjp = $appversionprodjp.Split("<")[0]
        $webVersionbetajp = $webRequest.RawContent | Select-String -Pattern $regexAppVersionjp -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetajp) {
            $installerbetajp = $webVersionbetajp.Line.Split(">")[2]
            $installerbetajp = $installerbetajp.Split('"')[1]
            $appversionbetajp = $webVersionbetajp.Line.Split(">")[8]
            $appversionbetajp = $appversionbetajp.Split("<")[0]
        }
        $webVersionprod32jp = $webRequest.RawContent | Select-String -Pattern $regexAppVersionjp -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32jp = $webVersionprod32jp.Line.Split(">")[2]
        $installerprod32jp = $installerprod32jp.Split('"')[1]
        $appversionprod32jp = $webVersionprod32jp.Line.Split(">")[8]
        $appversionprod32jp = $appversionprod32jp.Split("<")[0]
        $webVersionbeta32jp = $webRequest.RawContent | Select-String -Pattern $regexAppVersionjp -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32jp) {
            $installerbeta32jp = $webVersionbeta32jp.Line.Split(">")[2]
            $installerbeta32jp = $installerbeta32jp.Split('"')[1]
            $appversionbeta32jp = $webVersionbeta32jp.Line.Split(">")[8]
            $appversionbeta32jp = $appversionbeta32jp.Split("<")[0]
        }

        $regexAppVersionko = "<tr>\n.*\n.*Korean.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodko = $webRequest.RawContent | Select-String -Pattern $regexAppVersionko -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodko = $webVersionprodko.Line.Split(">")[2]
        $installerprodko = $installerprodko.Split('"')[1]
        $appversionprodko = $webVersionprodko.Line.Split(">")[8]
        $appversionprodko = $appversionprodko.Split("<")[0]
        $webVersionbetako = $webRequest.RawContent | Select-String -Pattern $regexAppVersionko -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetako) {
            $installerbetako = $webVersionbetako.Line.Split(">")[2]
            $installerbetako = $installerbetako.Split('"')[1]
            $appversionbetako = $webVersionbetako.Line.Split(">")[8]
            $appversionbetako = $appversionbetako.Split("<")[0]
        }
        $webVersionprod32ko = $webRequest.RawContent | Select-String -Pattern $regexAppVersionko -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32ko = $webVersionprod32ko.Line.Split(">")[2]
        $installerprod32ko = $installerprod32ko.Split('"')[1]
        $appversionprod32ko = $webVersionprod32ko.Line.Split(">")[8]
        $appversionprod32ko = $appversionprod32ko.Split("<")[0]
        $webVersionbeta32ko = $webRequest.RawContent | Select-String -Pattern $regexAppVersionko -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32ko) {
            $installerbeta32ko = $webVersionbeta32ko.Line.Split(">")[2]
            $installerbeta32ko = $installerbeta32ko.Split('"')[1]
            $appversionbeta32ko = $webVersionbeta32ko.Line.Split(">")[8]
            $appversionbeta32ko = $appversionbeta32ko.Split("<")[0]
        }

        $regexAppVersionnb = "<tr>\n.*\n.*Norwegian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodnb = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnb -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodnb = $webVersionprodnb.Line.Split(">")[2]
        $installerprodnb = $installerprodnb.Split('"')[1]
        $appversionprodnb = $webVersionprodnb.Line.Split(">")[8]
        $appversionprodnb = $appversionprodnb.Split("<")[0]
        $webVersionbetanb = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnb -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetanb) {
            $installerbetanb = $webVersionbetanb.Line.Split(">")[2]
            $installerbetanb = $installerbetanb.Split('"')[1]
            $appversionbetanb = $webVersionbetanb.Line.Split(">")[8]
            $appversionbetanb = $appversionbetanb.Split("<")[0]
        }
        $webVersionprod32nb = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnb -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32nb = $webVersionprod32nb.Line.Split(">")[2]
        $installerprod32nb = $installerprod32nb.Split('"')[1]
        $appversionprod32nb = $webVersionprod32nb.Line.Split(">")[8]
        $appversionprod32nb = $appversionprod32nb.Split("<")[0]
        $webVersionbeta32nb = $webRequest.RawContent | Select-String -Pattern $regexAppVersionnb -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32nb) {
            $installerbeta32nb = $webVersionbeta32nb.Line.Split(">")[2]
            $installerbeta32nb = $installerbeta32nb.Split('"')[1]
            $appversionbeta32nb = $webVersionbeta32nb.Line.Split(">")[8]
            $appversionbeta32nb = $appversionbeta32nb.Split("<")[0]
        }

        $regexAppVersionpo = "<tr>\n.*\n.*Polish.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodpo = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpo -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodpo = $webVersionprodpo.Line.Split(">")[2]
        $installerprodpo = $installerprodpo.Split('"')[1]
        $appversionprodpo = $webVersionprodpo.Line.Split(">")[8]
        $appversionprodpo = $appversionprodpo.Split("<")[0]
        $webVersionbetapo = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpo -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetapo) {
            $installerbetapo = $webVersionbetapo.Line.Split(">")[2]
            $installerbetapo = $installerbetapo.Split('"')[1]
            $appversionbetapo = $webVersionbetapo.Line.Split(">")[8]
            $appversionbetapo = $appversionbetapo.Split("<")[0]
        }
        $webVersionprod32po = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpo -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32po = $webVersionprod32po.Line.Split(">")[2]
        $installerprod32po = $installerprod32po.Split('"')[1]
        $appversionprod32po = $webVersionprod32po.Line.Split(">")[8]
        $appversionprod32po = $appversionprod32po.Split("<")[0]
        $webVersionbeta32po = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpo -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32po) {
            $installerbeta32po = $webVersionbeta32po.Line.Split(">")[2]
            $installerbeta32po = $installerbeta32po.Split('"')[1]
            $appversionbeta32po = $webVersionbeta32po.Line.Split(">")[8]
            $appversionbeta32po = $appversionbeta32po.Split("<")[0]
        }

        $regexAppVersionpg = "<tr>\n.*\n.*Portuguese.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodpg = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpg -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodpg = $webVersionprodpg.Line.Split(">")[2]
        $installerprodpg = $installerprodpg.Split('"')[1]
        $appversionprodpg = $webVersionprodpg.Line.Split(">")[8]
        $appversionprodpg = $appversionprodpg.Split("<")[0]
        $webVersionbetapg = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpg -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetapg) {
            $installerbetapg = $webVersionbetapg.Line.Split(">")[2]
            $installerbetapg = $installerbetapg.Split('"')[1]
            $appversionbetapg = $webVersionbetapg.Line.Split(">")[8]
            $appversionbetapg = $appversionbetapg.Split("<")[0]
        }
        $webVersionprod32pg = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpg -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32pg = $webVersionprod32pg.Line.Split(">")[2]
        $installerprod32pg = $installerprod32pg.Split('"')[1]
        $appversionprod32pg = $webVersionprod32pg.Line.Split(">")[8]
        $appversionprod32pg = $appversionprod32pg.Split("<")[0]
        $webVersionbeta32pg = $webRequest.RawContent | Select-String -Pattern $regexAppVersionpg -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32pg) {
            $installerbeta32pg = $webVersionbeta32pg.Line.Split(">")[2]
            $installerbeta32pg = $installerbeta32pg.Split('"')[1]
            $appversionbeta32pg = $webVersionbeta32pg.Line.Split(">")[8]
            $appversionbeta32pg = $appversionbeta32pg.Split("<")[0]
        }

        $regexAppVersionru = "<tr>\n.*\n.*Russian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodru = $webRequest.RawContent | Select-String -Pattern $regexAppVersionru -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodru = $webVersionprodru.Line.Split(">")[2]
        $installerprodru = $installerprodru.Split('"')[1]
        $appversionprodru = $webVersionprodru.Line.Split(">")[8]
        $appversionprodru = $appversionprodru.Split("<")[0]
        $webVersionbetaru = $webRequest.RawContent | Select-String -Pattern $regexAppVersionru -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaru) {
            $installerbetaru = $webVersionbetaru.Line.Split(">")[2]
            $installerbetaru = $installerbetaru.Split('"')[1]
            $appversionbetaru = $webVersionbetaru.Line.Split(">")[8]
            $appversionbetaru = $appversionbetaru.Split("<")[0]
        }
        $webVersionprod32ru = $webRequest.RawContent | Select-String -Pattern $regexAppVersionru -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32ru = $webVersionprod32ru.Line.Split(">")[2]
        $installerprod32ru = $installerprod32ru.Split('"')[1]
        $appversionprod32ru = $webVersionprod32ru.Line.Split(">")[8]
        $appversionprod32ru = $appversionprod32ru.Split("<")[0]
        $webVersionbeta32ru = $webRequest.RawContent | Select-String -Pattern $regexAppVersionru -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32ru) {
            $installerbeta32ru = $webVersionbeta32ru.Line.Split(">")[2]
            $installerbeta32ru = $installerbeta32ru.Split('"')[1]
            $appversionbeta32ru = $webVersionbeta32ru.Line.Split(">")[8]
            $appversionbeta32ru = $appversionbeta32ru.Split("<")[0]
        }

        $regexAppVersiones = "<tr>\n.*\n.*Spanish.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodes = $webRequest.RawContent | Select-String -Pattern $regexAppVersiones -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodes = $webVersionprodes.Line.Split(">")[2]
        $installerprodes = $installerprodes.Split('"')[1]
        $appversionprodes = $webVersionprodes.Line.Split(">")[8]
        $appversionprodes = $appversionprodes.Split("<")[0]
        $webVersionbetaes = $webRequest.RawContent | Select-String -Pattern $regexAppVersiones -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaes) {
            $installerbetaes = $webVersionbetaes.Line.Split(">")[2]
            $installerbetaes = $installerbetaes.Split('"')[1]
            $appversionbetaes = $webVersionbetaes.Line.Split(">")[8]
            $appversionbetaes = $appversionbetaes.Split("<")[0]
        }
        $webVersionprod32es = $webRequest.RawContent | Select-String -Pattern $regexAppVersiones -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32es = $webVersionprod32es.Line.Split(">")[2]
        $installerprod32es = $installerprod32es.Split('"')[1]
        $appversionprod32es = $webVersionprod32es.Line.Split(">")[8]
        $appversionprod32es = $appversionprod32es.Split("<")[0]
        $webVersionbeta32es = $webRequest.RawContent | Select-String -Pattern $regexAppVersiones -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32es) {
            $installerbeta32es = $webVersionbeta32es.Line.Split(">")[2]
            $installerbeta32es = $installerbeta32es.Split('"')[1]
            $appversionbeta32es = $webVersionbeta32es.Line.Split(">")[8]
            $appversionbeta32es = $appversionbeta32es.Split("<")[0]
        }

        $regexAppVersionsv = "<tr>\n.*\n.*Swedish.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodsv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodsv = $webVersionprodsv.Line.Split(">")[2]
        $installerprodsv = $installerprodsv.Split('"')[1]
        $appversionprodsv = $webVersionprodsv.Line.Split(">")[8]
        $appversionprodsv = $appversionprodsv.Split("<")[0]
        $webVersionbetasv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetasv) {
            $installerbetasv = $webVersionbetasv.Line.Split(">")[2]
            $installerbetasv = $installerbetasv.Split('"')[1]
            $appversionbetasv = $webVersionbetasv.Line.Split(">")[8]
            $appversionbetasv = $appversionbetasv.Split("<")[0]
        }
        $webVersionprod32sv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32sv = $webVersionprod32sv.Line.Split(">")[2]
        $installerprod32sv = $installerprod32sv.Split('"')[1]
        $appversionprod32sv = $webVersionprod32sv.Line.Split(">")[8]
        $appversionprod32sv = $appversionprod32sv.Split("<")[0]
        $webVersionbeta32sv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32sv) {
            $installerbeta32sv = $webVersionbeta32sv.Line.Split(">")[2]
            $installerbeta32sv = $installerbeta32sv.Split('"')[1]
            $appversionbeta32sv = $webVersionbeta32sv.Line.Split(">")[8]
            $appversionbeta32sv = $appversionbeta32sv.Split("<")[0]
        }

        $regexAppVersionuk = "<tr>\n.*\n.*Ukrainian.*\n.*\n.*.*\n<\/tr>"
        $webVersionproduk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionuk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerproduk = $webVersionproduk.Line.Split(">")[2]
        $installerproduk = $installerproduk.Split('"')[1]
        $appversionproduk = $webVersionproduk.Line.Split(">")[8]
        $appversionproduk = $appversionproduk.Split("<")[0]
        $webVersionbetauk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionuk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetauk) {
            $installerbetauk = $webVersionbetauk.Line.Split(">")[2]
            $installerbetauk = $installerbetauk.Split('"')[1]
            $appversionbetauk = $webVersionbetauk.Line.Split(">")[8]
            $appversionbetauk = $appversionbetauk.Split("<")[0]
        }
        $webVersionprod32uk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionuk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32uk = $webVersionprod32uk.Line.Split(">")[2]
        $installerprod32uk = $installerprod32uk.Split('"')[1]
        $appversionprod32uk = $webVersionprod32uk.Line.Split(">")[8]
        $appversionprod32uk = $appversionprod32uk.Split("<")[0]
        $webVersionbeta32uk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionuk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32uk) {
            $installerbeta32uk = $webVersionbeta32uk.Line.Split(">")[2]
            $installerbeta32uk = $installerbeta32uk.Split('"')[1]
            $appversionbeta32uk = $webVersionbeta32uk.Line.Split(">")[8]
            $appversionbeta32uk = $appversionbeta32uk.Split("<")[0]
        }

        $regexAppVersiontr = "<tr>\n.*\n.*Turkish.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodtr = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodtr = $webVersionprodtr.Line.Split(">")[2]
        $installerprodtr = $installerprodtr.Split('"')[1]
        $appversionprodtr = $webVersionprodtr.Line.Split(">")[8]
        $appversionprodtr = $appversionprodtr.Split("<")[0]
        $webVersionbetatr = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetatr) {
            $installerbetatr = $webVersionbetatr.Line.Split(">")[2]
            $installerbetatr = $installerbetatr.Split('"')[1]
            $appversionbetatr = $webVersionbetatr.Line.Split(">")[8]
            $appversionbetatr = $appversionbetatr.Split("<")[0]
        }
        $webVersionprod32tr = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32tr = $webVersionprod32tr.Line.Split(">")[2]
        $installerprod32tr = $installerprod32tr.Split('"')[1]
        $appversionprod32tr = $webVersionprod32tr.Line.Split(">")[8]
        $appversionprod32tr = $appversionprod32tr.Split("<")[0]
        $webVersionbeta32tr = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontr -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32tr) {
            $installerbeta32tr = $webVersionbeta32tr.Line.Split(">")[2]
            $installerbeta32tr = $installerbeta32tr.Split('"')[1]
            $appversionbeta32tr = $webVersionbeta32tr.Line.Split(">")[8]
            $appversionbeta32tr = $appversionbeta32tr.Split("<")[0]
        }

        $regexAppVersionhe = "<tr>\n.*\n.*Hebrew.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodhe = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhe -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodhe = $webVersionprodhe.Line.Split(">")[2]
        $installerprodhe = $installerprodhe.Split('"')[1]
        $appversionprodhe = $webVersionprodhe.Line.Split(">")[8]
        $appversionprodhe = $appversionprodhe.Split("<")[0]
        $webVersionbetahe = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhe -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetahe) {
            $installerbetahe = $webVersionbetahe.Line.Split(">")[2]
            $installerbetahe = $installerbetahe.Split('"')[1]
            $appversionbetahe = $webVersionbetahe.Line.Split(">")[8]
            $appversionbetahe = $appversionbetahe.Split("<")[0]
        }
        $webVersionprod32he = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhe -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32he = $webVersionprod32he.Line.Split(">")[2]
        $installerprod32he = $installerprod32he.Split('"')[1]
        $appversionprod32he = $webVersionprod32he.Line.Split(">")[8]
        $appversionprod32he = $appversionprod32he.Split("<")[0]
        $webVersionbeta32he = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhe -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32he) {
            $installerbeta32he = $webVersionbeta32he.Line.Split(">")[2]
            $installerbeta32he = $installerbeta32he.Split('"')[1]
            $appversionbeta32he = $webVersionbeta32he.Line.Split(">")[8]
            $appversionbeta32he = $appversionbeta32he.Split("<")[0]
        }

        $regexAppVersionar = "<tr>\n.*\n.*Arabic.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodar = $webRequest.RawContent | Select-String -Pattern $regexAppVersionar -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodar = $webVersionprodar.Line.Split(">")[2]
        $installerprodar = $installerprodar.Split('"')[1]
        $appversionprodar = $webVersionprodar.Line.Split(">")[8]
        $appversionprodar = $appversionprodar.Split("<")[0]
        $webVersionbetaar = $webRequest.RawContent | Select-String -Pattern $regexAppVersionar -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaar) {
            $installerbetaar = $webVersionbetaar.Line.Split(">")[2]
            $installerbetaar = $installerbetaar.Split('"')[1]
            $appversionbetaar = $webVersionbetaar.Line.Split(">")[8]
            $appversionbetaar = $appversionbetaar.Split("<")[0]
        }
        $webVersionprod32ar = $webRequest.RawContent | Select-String -Pattern $regexAppVersionar -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32ar = $webVersionprod32ar.Line.Split(">")[2]
        $installerprod32ar = $installerprod32ar.Split('"')[1]
        $appversionprod32ar = $webVersionprod32ar.Line.Split(">")[8]
        $appversionprod32ar = $appversionprod32ar.Split("<")[0]
        $webVersionbeta32ar = $webRequest.RawContent | Select-String -Pattern $regexAppVersionar -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32ar) {
            $installerbeta32ar = $webVersionbeta32ar.Line.Split(">")[2]
            $installerbeta32ar = $installerbeta32ar.Split('"')[1]
            $appversionbeta32ar = $webVersionbeta32ar.Line.Split(">")[8]
            $appversionbeta32ar = $appversionbeta32ar.Split("<")[0]
        }

        $regexAppVersiontc = "<tr>\n.*\n.*Chinese.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodtc = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontc -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodtc = $webVersionprodtc.Line.Split(">")[2]
        $installerprodtc = $installerprodtc.Split('"')[1]
        $appversionprodtc = $webVersionprodtc.Line.Split(">")[8]
        $appversionprodtc = $appversionprodtc.Split("<")[0]
        $webVersionbetatc = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontc -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetatc) {
            $installerbetatc = $webVersionbetatc.Line.Split(">")[2]
            $installerbetatc = $installerbetatc.Split('"')[1]
            $appversionbetatc = $webVersionbetatc.Line.Split(">")[8]
            $appversionbetatc = $appversionbetatc.Split("<")[0]
        }
        $webVersionprod32tc = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontc -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32tc = $webVersionprod32tc.Line.Split(">")[2]
        $installerprod32tc = $installerprod32tc.Split('"')[1]
        $appversionprod32tc = $webVersionprod32tc.Line.Split(">")[8]
        $appversionprod32tc = $appversionprod32tc.Split("<")[0]
        $webVersionbeta32tc = $webRequest.RawContent | Select-String -Pattern $regexAppVersiontc -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32tc) {
            $installerbeta32tc = $webVersionbeta32tc.Line.Split(">")[2]
            $installerbeta32tc = $installerbeta32tc.Split('"')[1]
            $appversionbeta32tc = $webVersionbeta32tc.Line.Split(">")[8]
            $appversionbeta32tc = $appversionbeta32tc.Split("<")[0]
        }

        $regexAppVersioncz = "<tr>\n.*\n.*Czech.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodcz = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncz -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodcz = $webVersionprodcz.Line.Split(">")[2]
        $installerprodcz = $installerprodcz.Split('"')[1]
        $appversionprodcz = $webVersionprodcz.Line.Split(">")[8]
        $appversionprodcz = $appversionprodcz.Split("<")[0]
        $webVersionbetacz = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncz -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetacz) {
            $installerbetacz = $webVersionbetacz.Line.Split(">")[2]
            $installerbetacz = $installerbetacz.Split('"')[1]
            $appversionbetacz = $webVersionbetacz.Line.Split(">")[8]
            $appversionbetacz = $appversionbetacz.Split("<")[0]
        }
        $webVersionprod32cz = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncz -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32cz = $webVersionprod32cz.Line.Split(">")[2]
        $installerprod32cz = $installerprod32cz.Split('"')[1]
        $appversionprod32cz = $webVersionprod32cz.Line.Split(">")[8]
        $appversionprod32cz = $appversionprod32cz.Split("<")[0]
        $webVersionbeta32cz = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncz -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32cz) {
            $installerbeta32cz = $webVersionbeta32cz.Line.Split(">")[2]
            $installerbeta32cz = $installerbeta32cz.Split('"')[1]
            $appversionbeta32cz = $webVersionbeta32cz.Line.Split(">")[8]
            $appversionbeta32cz = $appversionbeta32cz.Split("<")[0]
        }

        $regexAppVersionsk = "<tr>\n.*\n.*Slovak.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodsk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodsk = $webVersionprodsk.Line.Split(">")[2]
        $installerprodsk = $installerprodsk.Split('"')[1]
        $appversionprodsk = $webVersionprodsk.Line.Split(">")[8]
        $appversionprodsk = $appversionprodsk.Split("<")[0]
        $webVersionbetask = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetask) {
            $installerbetask = $webVersionbetask.Line.Split(">")[2]
            $installerbetask = $installerbetask.Split('"')[1]
            $appversionbetask = $webVersionbetask.Line.Split(">")[8]
            $appversionbetask = $appversionbetask.Split("<")[0]
        }
        $webVersionprod32sk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32sk = $webVersionprod32sk.Line.Split(">")[2]
        $installerprod32sk = $installerprod32sk.Split('"')[1]
        $appversionprod32sk = $webVersionprod32sk.Line.Split(">")[8]
        $appversionprod32sk = $appversionprod32sk.Split("<")[0]
        $webVersionbeta32sk = $webRequest.RawContent | Select-String -Pattern $regexAppVersionsk -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32sk) {
            $installerbeta32sk = $webVersionbeta32sk.Line.Split(">")[2]
            $installerbeta32sk = $installerbeta32sk.Split('"')[1]
            $appversionbeta32sk = $webVersionbeta32sk.Line.Split(">")[8]
            $appversionbeta32sk = $appversionbeta32sk.Split("<")[0]
        }

        $regexAppVersionhu = "<tr>\n.*\n.*Hungarian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodhu = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhu -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodhu = $webVersionprodhu.Line.Split(">")[2]
        $installerprodhu = $installerprodhu.Split('"')[1]
        $appversionprodhu = $webVersionprodhu.Line.Split(">")[8]
        $appversionprodhu = $appversionprodhu.Split("<")[0]
        $webVersionbetahu = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhu -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetahu) {
            $installerbetahu = $webVersionbetahu.Line.Split(">")[2]
            $installerbetahu = $installerbetahu.Split('"')[1]
            $appversionbetahu = $webVersionbetahu.Line.Split(">")[8]
            $appversionbetahu = $appversionbetahu.Split("<")[0]
        }
        $webVersionprod32hu = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhu -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32hu = $webVersionprod32hu.Line.Split(">")[2]
        $installerprod32hu = $installerprod32hu.Split('"')[1]
        $appversionprod32hu = $webVersionprod32hu.Line.Split(">")[8]
        $appversionprod32hu = $appversionprod32hu.Split("<")[0]
        $webVersionbeta32hu = $webRequest.RawContent | Select-String -Pattern $regexAppVersionhu -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32hu) {
            $installerbeta32hu = $webVersionbeta32hu.Line.Split(">")[2]
            $installerbeta32hu = $installerbeta32hu.Split('"')[1]
            $appversionbeta32hu = $webVersionbeta32hu.Line.Split(">")[8]
            $appversionbeta32hu = $appversionbeta32hu.Split("<")[0]
        }

        $regexAppVersionslv = "<tr>\n.*\n.*Slovenian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodslv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionslv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodslv = $webVersionprodslv.Line.Split(">")[2]
        $installerprodslv = $installerprodslv.Split('"')[1]
        $appversionprodslv = $webVersionprodslv.Line.Split(">")[8]
        $appversionprodslv = $appversionprodslv.Split("<")[0]
        $webVersionbetaslv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionslv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaslv) {
            $installerbetaslv = $webVersionbetaslv.Line.Split(">")[2]
            $installerbetaslv = $installerbetaslv.Split('"')[1]
            $appversionbetaslv = $webVersionbetaslv.Line.Split(">")[8]
            $appversionbetaslv = $appversionbetaslv.Split("<")[0]
        }
        $webVersionprod32slv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionslv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32slv = $webVersionprod32slv.Line.Split(">")[2]
        $installerprod32slv = $installerprod32slv.Split('"')[1]
        $appversionprod32slv = $webVersionprod32slv.Line.Split(">")[8]
        $appversionprod32slv = $appversionprod32slv.Split("<")[0]
        $webVersionbeta32slv = $webRequest.RawContent | Select-String -Pattern $regexAppVersionslv -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32slv) {
            $installerbeta32slv = $webVersionbeta32slv.Line.Split(">")[2]
            $installerbeta32slv = $installerbeta32slv.Split('"')[1]
            $appversionbeta32slv = $webVersionbeta32slv.Line.Split(">")[8]
            $appversionbeta32slv = $appversionbeta32slv.Split("<")[0]
        }

        $regexAppVersionro = "<tr>\n.*\n.*Romanian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodro = $webRequest.RawContent | Select-String -Pattern $regexAppVersionro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodro = $webVersionprodro.Line.Split(">")[2]
        $installerprodro = $installerprodro.Split('"')[1]
        $appversionprodro = $webVersionprodro.Line.Split(">")[8]
        $appversionprodro = $appversionprodro.Split("<")[0]
        $webVersionbetaro = $webRequest.RawContent | Select-String -Pattern $regexAppVersionro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetaro) {
            $installerbetaro = $webVersionbetaro.Line.Split(">")[2]
            $installerbetaro = $installerbetaro.Split('"')[1]
            $appversionbetaro = $webVersionbetaro.Line.Split(">")[8]
            $appversionbetaro = $appversionbetaro.Split("<")[0]
        }
        $webVersionprod32ro = $webRequest.RawContent | Select-String -Pattern $regexAppVersionro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32ro = $webVersionprod32ro.Line.Split(">")[2]
        $installerprod32ro = $installerprod32ro.Split('"')[1]
        $appversionprod32ro = $webVersionprod32ro.Line.Split(">")[8]
        $appversionprod32ro = $appversionprod32ro.Split("<")[0]
        $webVersionbeta32ro = $webRequest.RawContent | Select-String -Pattern $regexAppVersionro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32ro) {
            $installerbeta32ro = $webVersionbeta32ro.Line.Split(">")[2]
            $installerbeta32ro = $installerbeta32ro.Split('"')[1]
            $appversionbeta32ro = $webVersionbeta32ro.Line.Split(">")[8]
            $appversionbeta32ro = $appversionbeta32ro.Split("<")[0]
        }

        $regexAppVersioncro = "<tr>\n.*\n.*Croatian.*\n.*\n.*.*\n<\/tr>"
        $webVersionprodcro = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -First 1
        $installerprodcro = $webVersionprodcro.Line.Split(">")[2]
        $installerprodcro = $installerprodcro.Split('"')[1]
        $appversionprodcro = $webVersionprodcro.Line.Split(">")[8]
        $appversionprodcro = $appversionprodcro.Split("<")[0]
        $webVersionbetacro = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -First 1
        If ($webVersionbetacro) {
            $installerbetacro = $webVersionbetacro.Line.Split(">")[2]
            $installerbetacro = $installerbetacro.Split('"')[1]
            $appversionbetacro = $webVersionbetacro.Line.Split(">")[8]
            $appversionbetacro = $appversionbetacro.Split("<")[0]
        }
        $webVersionprod32cro = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -NotMatch $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        $installerprod32cro = $webVersionprod32cro.Line.Split(">")[2]
        $installerprod32cro = $installerprod32cro.Split('"')[1]
        $appversionprod32cro = $webVersionprod32cro.Line.Split(">")[8]
        $appversionprod32cro = $appversionprod32cro.Split("<")[0]
        $webVersionbeta32cro = $webRequest.RawContent | Select-String -Pattern $regexAppVersioncro -AllMatches | ForEach-Object { $_.Matches.Value } | Select-String -Pattern $regexAppVersionbeta -AllMatches | Select-Object -Last 1
        If ($webVersionbeta32cro) {
            $installerbeta32cro = $webVersionbeta32cro.Line.Split(">")[2]
            $installerbeta32cro = $installerbeta32cro.Split('"')[1]
            $appversionbeta32cro = $webVersionbeta32cro.Line.Split(">")[8]
            $appversionbeta32cro = $appversionbeta32cro.Split("<")[0]
        }

        $appx64URLPRODEN = "https://www.rarlab.com" + "$installerproden"
        If ($installerbetaen) {
            $appx64URLBETAEN = "https://www.rarlab.com" + "$installerbetaen"
        } Else {
            $appx64URLBETAEN = "https://www.rarlab.com" + "$installerproden"
            $appversionbetaen = $appversionproden
        }
        $appx32URLPRODEN = "https://www.rarlab.com" + "$installerprod32en"
        If ($installerbeta32en) {
            $appx32URLBETAEN = "https://www.rarlab.com" + "$installerbeta32en"
        } Else {
            $appx32URLBETAEN = "https://www.rarlab.com" + "$installerprod32en"
            $appversionbeta32en = $appversionprod32en
        }

        $appx64URLPRODDK = "https://www.rarlab.com" + "$installerproddk"
        If ($installerbetadk) {
            $appx64URLBETADK = "https://www.rarlab.com" + "$installerbetadk"
        } Else {
            $appx64URLBETADK = "https://www.rarlab.com" + "$installerproddk"
            $appversionbetadk = $appversionproddk
        }
        $appx32URLPRODDK = "https://www.rarlab.com" + "$installerprod32dk"
        If ($installerbeta32dk) {
            $appx32URLBETADK = "https://www.rarlab.com" + "$installerbeta32dk"
        } Else {
            $appx32URLBETADK = "https://www.rarlab.com" + "$installerprod32dk"
            $appversionbeta32dk = $appversionprod32dk
        }

        $appx64URLPRODNL = "https://www.rarlab.com" + "$installerprodnl"
        If ($installerbetanl) {
            $appx64URLBETANL = "https://www.rarlab.com" + "$installerbetanl"
        } Else {
            $appx64URLBETANL = "https://www.rarlab.com" + "$installerprodnl"
            $appversionbetanl = $appversionprodnl
        }
        $appx32URLPRODNL = "https://www.rarlab.com" + "$installerprod32nl"
        If ($installerbeta32nl) {
            $appx32URLBETANL = "https://www.rarlab.com" + "$installerbeta32nl"
        } Else {
            $appx32URLBETANL = "https://www.rarlab.com" + "$installerprod32nl"
            $appversionbeta32nl = $appversionprod32nl
        }

        $appx64URLPRODFN = "https://www.rarlab.com" + "$installerprodfn"
        If ($installerbetafn) {
            $appx64URLBETAFN = "https://www.rarlab.com" + "$installerbetafn"
        } Else {
            $appx64URLBETAFN = "https://www.rarlab.com" + "$installerprodfn"
            $appversionbetafn = $appversionprodfn
        }
        $appx32URLPRODFN = "https://www.rarlab.com" + "$installerprod32fn"
        If ($installerbeta32fn) {
            $appx32URLBETAFN = "https://www.rarlab.com" + "$installerbeta32fn"
        } Else {
            $appx32URLBETAFN = "https://www.rarlab.com" + "$installerprod32fn"
            $appversionbeta32fn = $appversionprod32fn
        }

        $appx64URLPRODFR = "https://www.rarlab.com" + "$installerprodfr"
        If ($installerbetafr) {
            $appx64URLBETAFR = "https://www.rarlab.com" + "$installerbetafr"
        } Else {
            $appx64URLBETAFR = "https://www.rarlab.com" + "$installerprodfr"
            $appversionbetafr = $appversionprodfr
        }
        $appx32URLPRODFR = "https://www.rarlab.com" + "$installerprod32fr"
        If ($installerbeta32fr) {
            $appx32URLBETAFR = "https://www.rarlab.com" + "$installerbeta32fr"
        } Else {
            $appx32URLBETAFR = "https://www.rarlab.com" + "$installerprod32fr"
            $appversionbeta32fr = $appversionprod32fr
        }

        $appx64URLPRODDE = "https://www.rarlab.com" + "$installerprodde"
        If ($installerbetade) {
            $appx64URLBETADE = "https://www.rarlab.com" + "$installerbetade"
        } Else {
            $appx64URLBETADE = "https://www.rarlab.com" + "$installerprodde"
            $appversionbetade = $appversionprodde
        }
        $appx32URLPRODDE = "https://www.rarlab.com" + "$installerprod32de"
        If ($installerbeta32de) {
            $appx32URLBETADE = "https://www.rarlab.com" + "$installerbeta32de"
        } Else {
            $appx32URLBETADE = "https://www.rarlab.com" + "$installerprod32de"
            $appversionbeta32de = $appversionprod32de
        }

        $appx64URLPRODIT = "https://www.rarlab.com" + "$installerprodit"
        If ($installerbetait) {
            $appx64URLBETAIT = "https://www.rarlab.com" + "$installerbetait"
        } Else {
            $appx64URLBETAIT = "https://www.rarlab.com" + "$installerprodit"
            $appversionbetait = $appversionprodit
        }
        $appx32URLPRODIT = "https://www.rarlab.com" + "$installerprod32it"
        If ($installerbeta32it) {
            $appx32URLBETAIT = "https://www.rarlab.com" + "$installerbeta32it"
        } Else {
            $appx32URLBETAIT = "https://www.rarlab.com" + "$installerprod32it"
            $appversionbeta32it = $appversionprod32it
        }

        $appx64URLPRODJP = "https://www.rarlab.com" + "$installerprodjp"
        If ($installerbetajp) {
            $appx64URLBETAJP = "https://www.rarlab.com" + "$installerbetajp"
        } Else {
            $appx64URLBETAJP = "https://www.rarlab.com" + "$installerprodjp"
            $appversionbetajp = $appversionprodjp
        }
        $appx32URLPRODJP = "https://www.rarlab.com" + "$installerprod32jp"
        If ($installerbeta32jp) {
            $appx32URLBETAJP = "https://www.rarlab.com" + "$installerbeta32jp"
        } Else {
            $appx32URLBETAJP = "https://www.rarlab.com" + "$installerprod32jp"
            $appversionbeta32jp = $appversionprod32jp
        }

        $appx64URLPRODKO = "https://www.rarlab.com" + "$installerprodko"
        If ($installerbetako) {
            $appx64URLBETAKO = "https://www.rarlab.com" + "$installerbetako"
        } Else {
            $appx64URLBETAKO = "https://www.rarlab.com" + "$installerprodko"
            $appversionbetako = $appversionprodko
        }
        $appx32URLPRODKO = "https://www.rarlab.com" + "$installerprod32ko"
        If ($installerbeta32ko) {
            $appx32URLBETAKO = "https://www.rarlab.com" + "$installerbeta32ko"
        } Else {
            $appx32URLBETAKO = "https://www.rarlab.com" + "$installerprod32ko"
            $appversionbeta32ko = $appversionprod32ko
        }

        $appx64URLPRODNB = "https://www.rarlab.com" + "$installerprodnb"
        If ($installerbetanb) {
            $appx64URLBETANB = "https://www.rarlab.com" + "$installerbetanb"
        } Else {
            $appx64URLBETANB = "https://www.rarlab.com" + "$installerprodnb"
            $appversionbetanb = $appversionprodnb
        }
        $appx32URLPRODNB = "https://www.rarlab.com" + "$installerprod32nb"
        If ($installerbeta32nb) {
            $appx32URLBETANB = "https://www.rarlab.com" + "$installerbeta32nb"
        } Else {
            $appx32URLBETANB = "https://www.rarlab.com" + "$installerprod32nb"
            $appversionbeta32nb = $appversionprod32nb
        }

        $appx64URLPRODPO = "https://www.rarlab.com" + "$installerprodpo"
        If ($installerbetapo) {
            $appx64URLBETAPO = "https://www.rarlab.com" + "$installerbetapo"
        } Else {
            $appx64URLBETAPO = "https://www.rarlab.com" + "$installerprodpo"
            $appversionbetapo = $appversionprodpo
        }
        $appx32URLPRODPO = "https://www.rarlab.com" + "$installerprod32po"
        If ($installerbeta32po) {
            $appx32URLBETAPO = "https://www.rarlab.com" + "$installerbeta32po"
        } Else {
            $appx32URLBETAPO = "https://www.rarlab.com" + "$installerprod32po"
            $appversionbeta32po = $appversionprod32po
        }

        $appx64URLPRODPG = "https://www.rarlab.com" + "$installerprodpg"
        If ($installerbetapg) {
            $appx64URLBETAPG = "https://www.rarlab.com" + "$installerbetapg"
        } Else {
            $appx64URLBETAPG = "https://www.rarlab.com" + "$installerprodpg"
            $appversionbetapg = $appversionprodpg
        }
        $appx32URLPRODPG = "https://www.rarlab.com" + "$installerprod32pg"
        If ($installerbeta32pg) {
            $appx32URLBETAPG = "https://www.rarlab.com" + "$installerbeta32pg"
        } Else {
            $appx32URLBETAPG = "https://www.rarlab.com" + "$installerprod32pg"
            $appversionbeta32pg = $appversionprod32pg
        }

        $appx64URLPRODRU = "https://www.rarlab.com" + "$installerprodru"
        If ($installerbetaru) {
            $appx64URLBETARU = "https://www.rarlab.com" + "$installerbetaru"
        } Else {
            $appx64URLBETARU = "https://www.rarlab.com" + "$installerprodru"
            $appversionbetaru = $appversionprodru
        }
        $appx32URLPRODRU = "https://www.rarlab.com" + "$installerprod32ru"
        If ($installerbeta32ru) {
            $appx32URLBETARU = "https://www.rarlab.com" + "$installerbeta32ru"
        } Else {
            $appx32URLBETARU = "https://www.rarlab.com" + "$installerprod32ru"
            $appversionbeta32ru = $appversionprod32ru
        }

        $appx64URLPRODES = "https://www.rarlab.com" + "$installerprodes"
        If ($installerbetaes) {
            $appx64URLBETAES = "https://www.rarlab.com" + "$installerbetaes"
        } Else {
            $appx64URLBETAES = "https://www.rarlab.com" + "$installerprodes"
            $appversionbetaes = $appversionprodes
        }
        $appx32URLPRODES = "https://www.rarlab.com" + "$installerprod32es"
        If ($installerbeta32es) {
            $appx32URLBETAES = "https://www.rarlab.com" + "$installerbeta32es"
        } Else {
            $appx32URLBETAES = "https://www.rarlab.com" + "$installerprod32es"
            $appversionbeta32es = $appversionprod32es
        }

        $appx64URLPRODSV = "https://www.rarlab.com" + "$installerprodsv"
        If ($installerbetasv) {
            $appx64URLBETASV = "https://www.rarlab.com" + "$installerbetasv"
        } Else {
            $appx64URLBETASV = "https://www.rarlab.com" + "$installerprodsv"
            $appversionbetasv = $appversionprodsv
        }
        $appx32URLPRODSV = "https://www.rarlab.com" + "$installerprod32sv"
        If ($installerbeta32sv) {
            $appx32URLBETASV = "https://www.rarlab.com" + "$installerbeta32sv"
        } Else {
            $appx32URLBETASV = "https://www.rarlab.com" + "$installerprod32sv"
            $appversionbeta32sv = $appversionprod32sv
        }

        $appx64URLPRODUK = "https://www.rarlab.com" + "$installerproduk"
        If ($installerbetauk) {
            $appx64URLBETAUK = "https://www.rarlab.com" + "$installerbetauk"
        } Else {
            $appx64URLBETAUK = "https://www.rarlab.com" + "$installerproduk"
            $appversionbetauk = $appversionproduk
        }
        $appx32URLPRODUK = "https://www.rarlab.com" + "$installerprod32uk"
        If ($installerbeta32uk) {
            $appx32URLBETAUK = "https://www.rarlab.com" + "$installerbeta32uk"
        } Else {
            $appx32URLBETAUK = "https://www.rarlab.com" + "$installerprod32uk"
            $appversionbeta32uk = $appversionprod32uk
        }

        $appx64URLPRODtr = "https://www.rarlab.com" + "$installerprodtr"
        If ($installerbetatr) {
            $appx64URLBETAtr = "https://www.rarlab.com" + "$installerbetatr"
        } Else {
            $appx64URLBETAtr = "https://www.rarlab.com" + "$installerprodtr"
            $appversionbetatr = $appversionprodtr
        }
        $appx32URLPRODtr = "https://www.rarlab.com" + "$installerprod32tr"
        If ($installerbeta32tr) {
            $appx32URLBETAtr = "https://www.rarlab.com" + "$installerbeta32tr"
        } Else {
            $appx32URLBETAtr = "https://www.rarlab.com" + "$installerprod32tr"
            $appversionbeta32tr = $appversionprod32tr
        }

        $appx64URLPRODhe = "https://www.rarlab.com" + "$installerprodhe"
        If ($installerbetahe) {
            $appx64URLBETAhe = "https://www.rarlab.com" + "$installerbetahe"
        } Else {
            $appx64URLBETAhe = "https://www.rarlab.com" + "$installerprodhe"
            $appversionbetahe = $appversionprodhe
        }
        $appx32URLPRODhe = "https://www.rarlab.com" + "$installerprod32he"
        If ($installerbeta32he) {
            $appx32URLBETAhe = "https://www.rarlab.com" + "$installerbeta32he"
        } Else {
            $appx32URLBETAhe = "https://www.rarlab.com" + "$installerprod32he"
            $appversionbeta32he = $appversionprod32he
        }

        $appx64URLPRODar = "https://www.rarlab.com" + "$installerprodar"
        If ($installerbetaar) {
            $appx64URLBETAar = "https://www.rarlab.com" + "$installerbetaar"
        } Else {
            $appx64URLBETAar = "https://www.rarlab.com" + "$installerprodar"
            $appversionbetaar = $appversionprodar
        }
        $appx32URLPRODar = "https://www.rarlab.com" + "$installerprod32ar"
        If ($installerbeta32ar) {
            $appx32URLBETAar = "https://www.rarlab.com" + "$installerbeta32ar"
        } Else {
            $appx32URLBETAar = "https://www.rarlab.com" + "$installerprod32ar"
            $appversionbeta32ar = $appversionprod32ar
        }

        $appx64URLPRODtc = "https://www.rarlab.com" + "$installerprodtc"
        If ($installerbetatc) {
            $appx64URLBETAtc = "https://www.rarlab.com" + "$installerbetatc"
        } Else {
            $appx64URLBETAtc = "https://www.rarlab.com" + "$installerprodtc"
            $appversionbetatc = $appversionprodtc
        }
        $appx32URLPRODtc = "https://www.rarlab.com" + "$installerprod32tc"
        If ($installerbeta32tc) {
            $appx32URLBETAtc = "https://www.rarlab.com" + "$installerbeta32tc"
        } Else {
            $appx32URLBETAtc = "https://www.rarlab.com" + "$installerprod32tc"
            $appversionbeta32tc = $appversionprod32tc
        }

        $appx64URLPRODcz = "https://www.rarlab.com" + "$installerprodcz"
        If ($installerbetacz) {
            $appx64URLBETAcz = "https://www.rarlab.com" + "$installerbetacz"
        } Else {
            $appx64URLBETAcz = "https://www.rarlab.com" + "$installerprodcz"
            $appversionbetacz = $appversionprodcz
        }
        $appx32URLPRODcz = "https://www.rarlab.com" + "$installerprod32cz"
        If ($installerbeta32cz) {
            $appx32URLBETAcz = "https://www.rarlab.com" + "$installerbeta32cz"
        } Else {
            $appx32URLBETAcz = "https://www.rarlab.com" + "$installerprod32cz"
            $appversionbeta32cz = $appversionprod32cz
        }

        $appx64URLPRODsk = "https://www.rarlab.com" + "$installerprodsk"
        If ($installerbetask) {
            $appx64URLBETAsk = "https://www.rarlab.com" + "$installerbetask"
        } Else {
            $appx64URLBETAsk = "https://www.rarlab.com" + "$installerprodsk"
            $appversionbetask = $appversionprodsk
        }
        $appx32URLPRODsk = "https://www.rarlab.com" + "$installerprod32sk"
        If ($installerbeta32sk) {
            $appx32URLBETAsk = "https://www.rarlab.com" + "$installerbeta32sk"
        } Else {
            $appx32URLBETAsk = "https://www.rarlab.com" + "$installerprod32sk"
            $appversionbeta32sk = $appversionprod32sk
        }

        $appx64URLPRODhu = "https://www.rarlab.com" + "$installerprodhu"
        If ($installerbetahu) {
            $appx64URLBETAhu = "https://www.rarlab.com" + "$installerbetahu"
        } Else {
            $appx64URLBETAhu = "https://www.rarlab.com" + "$installerprodhu"
            $appversionbetahu = $appversionprodhu
        }
        $appx32URLPRODhu = "https://www.rarlab.com" + "$installerprod32hu"
        If ($installerbeta32hu) {
            $appx32URLBETAhu = "https://www.rarlab.com" + "$installerbeta32hu"
        } Else {
            $appx32URLBETAhu = "https://www.rarlab.com" + "$installerprod32hu"
            $appversionbeta32hu = $appversionprod32hu
        }

        $appx64URLPRODslv = "https://www.rarlab.com" + "$installerprodslv"
        If ($installerbetaslv) {
            $appx64URLBETAslv = "https://www.rarlab.com" + "$installerbetaslv"
        } Else {
            $appx64URLBETAslv = "https://www.rarlab.com" + "$installerprodslv"
            $appversionbetaslv = $appversionprodslv
        }
        $appx32URLPRODslv = "https://www.rarlab.com" + "$installerprod32slv"
        If ($installerbeta32slv) {
            $appx32URLBETAslv = "https://www.rarlab.com" + "$installerbeta32slv"
        } Else {
            $appx32URLBETAslv = "https://www.rarlab.com" + "$installerprod32slv"
            $appversionbeta32slv = $appversionprod32slv
        }

        $appx64URLPRODro = "https://www.rarlab.com" + "$installerprodro"
        If ($installerbetaro) {
            $appx64URLBETAro = "https://www.rarlab.com" + "$installerbetaro"
        } Else {
            $appx64URLBETAro = "https://www.rarlab.com" + "$installerprodro"
            $appversionbetaro = $appversionprodro
        }
        $appx32URLPRODro = "https://www.rarlab.com" + "$installerprod32ro"
        If ($installerbeta32ro) {
            $appx32URLBETAro = "https://www.rarlab.com" + "$installerbeta32ro"
        } Else {
            $appx32URLBETAro = "https://www.rarlab.com" + "$installerprod32ro"
            $appversionbeta32ro = $appversionprod32ro
        }

        $appx64URLPRODcro = "https://www.rarlab.com" + "$installerprodcro"
        If ($installerbetacro) {
            $appx64URLBETAcro = "https://www.rarlab.com" + "$installerbetacro"
        } Else {
            $appx64URLBETAcro = "https://www.rarlab.com" + "$installerprodcro"
            $appversionbetacro = $appversionprodcro
        }
        $appx32URLPRODcro = "https://www.rarlab.com" + "$installerprod32cro"
        If ($installerbeta32cro) {
            $appx32URLBETAcro = "https://www.rarlab.com" + "$installerbeta32cro"
        } Else {
            $appx32URLBETAcro = "https://www.rarlab.com" + "$installerprod32cro"
            $appversionbeta32cro = $appversionprod32cro
        }

        $PSObjectx64PRODEN = [PSCustomObject] @{
            Version      = $appVersionproden
            Language     = "English"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODEN
        }

        $PSObjectx64BETAEN = [PSCustomObject] @{
            Version      = $appVersionbetaen
            Language     = "English"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAEN
        }

        $PSObjectx32PRODEN = [PSCustomObject] @{
            Version      = $appVersionprod32en
            Language     = "English"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODEN
        }

        $PSObjectx32BETAEN = [PSCustomObject] @{
            Version      = $appVersionbeta32en
            Language     = "English"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAEN
        }

        $PSObjectx64PRODDK = [PSCustomObject] @{
            Version      = $appVersionproddk
            Language     = "Danish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODDK
        }

        $PSObjectx64BETADK = [PSCustomObject] @{
            Version      = $appVersionbetadk
            Language     = "Danish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETADK
        }

        $PSObjectx32PRODDK = [PSCustomObject] @{
            Version      = $appVersionprod32dk
            Language     = "Danish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODDK
        }

        $PSObjectx32BETADK = [PSCustomObject] @{
            Version      = $appVersionbeta32dk
            Language     = "Danish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETADK
        }

        $PSObjectx64PRODNL = [PSCustomObject] @{
            Version      = $appVersionprodnl
            Language     = "Dutch"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODNL
        }

        $PSObjectx64BETANL = [PSCustomObject] @{
            Version      = $appVersionbetanl
            Language     = "Dutch"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETANL
        }

        $PSObjectx32PRODNL = [PSCustomObject] @{
            Version      = $appVersionprod32nl
            Language     = "Dutch"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODNL
        }

        $PSObjectx32BETANL = [PSCustomObject] @{
            Version      = $appVersionbeta32nl
            Language     = "Dutch"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETANL
        }

        $PSObjectx64PRODFN = [PSCustomObject] @{
            Version      = $appVersionprodfn
            Language     = "Finnish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODFN
        }

        $PSObjectx64BETAFN = [PSCustomObject] @{
            Version      = $appVersionbetafn
            Language     = "Finnish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAFN
        }

        $PSObjectx32PRODFN = [PSCustomObject] @{
            Version      = $appVersionprod32fn
            Language     = "Finnish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODFN
        }

        $PSObjectx32BETAFN = [PSCustomObject] @{
            Version      = $appVersionbeta32fn
            Language     = "Finnish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAFN
        }

        $PSObjectx64PRODFR = [PSCustomObject] @{
            Version      = $appVersionprodfr
            Language     = "French"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODFR
        }

        $PSObjectx64BETAFR = [PSCustomObject] @{
            Version      = $appVersionbetafr
            Language     = "French"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAFR
        }

        $PSObjectx32PRODFR = [PSCustomObject] @{
            Version      = $appVersionprod32fr
            Language     = "French"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODFR
        }

        $PSObjectx32BETAFR = [PSCustomObject] @{
            Version      = $appVersionbeta32fr
            Language     = "French"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAFR
        }

        $PSObjectx64PRODDE = [PSCustomObject] @{
            Version      = $appVersionprodde
            Language     = "German"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODDE
        }

        $PSObjectx64BETADE = [PSCustomObject] @{
            Version      = $appVersionbetade
            Language     = "German"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETADE
        }

        $PSObjectx32PRODDE = [PSCustomObject] @{
            Version      = $appVersionprod32de
            Language     = "German"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODDE
        }

        $PSObjectx32BETADE = [PSCustomObject] @{
            Version      = $appVersionbeta32de
            Language     = "German"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETADE
        }

        $PSObjectx64PRODIT = [PSCustomObject] @{
            Version      = $appVersionprodit
            Language     = "Italian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODIT
        }

        $PSObjectx64BETAIT = [PSCustomObject] @{
            Version      = $appVersionbetait
            Language     = "Italian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAIT
        }

        $PSObjectx32PRODIT = [PSCustomObject] @{
            Version      = $appVersionprod32it
            Language     = "Italian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODIT
        }

        $PSObjectx32BETAIT = [PSCustomObject] @{
            Version      = $appVersionbeta32it
            Language     = "Italian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAIT
        }

        $PSObjectx64PRODJP = [PSCustomObject] @{
            Version      = $appVersionprodjp
            Language     = "Japanese"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODJP
        }

        $PSObjectx64BETAJP = [PSCustomObject] @{
            Version      = $appVersionbetajp
            Language     = "Japanese"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAJP
        }

        $PSObjectx32PRODJP = [PSCustomObject] @{
            Version      = $appVersionprod32jp
            Language     = "Japanese"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODJP
        }

        $PSObjectx32BETAJP = [PSCustomObject] @{
            Version      = $appVersionbeta32jp
            Language     = "Japanese"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAJP
        }

        $PSObjectx64PRODKO = [PSCustomObject] @{
            Version      = $appVersionprodko
            Language     = "Korean"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODKO
        }

        $PSObjectx64BETAKO = [PSCustomObject] @{
            Version      = $appVersionbetako
            Language     = "Korean"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAKO
        }

        $PSObjectx32PRODKO = [PSCustomObject] @{
            Version      = $appVersionprod32ko
            Language     = "Korean"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODKO
        }

        $PSObjectx32BETAKO = [PSCustomObject] @{
            Version      = $appVersionbeta32ko
            Language     = "Korean"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAKO
        }

        $PSObjectx64PRODNB = [PSCustomObject] @{
            Version      = $appVersionprodnb
            Language     = "Norwegian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODNB
        }

        $PSObjectx64BETANB = [PSCustomObject] @{
            Version      = $appVersionbetanb
            Language     = "Norwegian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETANB
        }

        $PSObjectx32PRODNB = [PSCustomObject] @{
            Version      = $appVersionprod32nb
            Language     = "Norwegian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODNB
        }

        $PSObjectx32BETANB = [PSCustomObject] @{
            Version      = $appVersionbeta32nb
            Language     = "Norwegian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETANB
        }

        $PSObjectx64PRODPO = [PSCustomObject] @{
            Version      = $appVersionprodpo
            Language     = "Polish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODPO
        }

        $PSObjectx64BETAPO = [PSCustomObject] @{
            Version      = $appVersionbetapo
            Language     = "Polish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAPO
        }

        $PSObjectx32PRODPO = [PSCustomObject] @{
            Version      = $appVersionprod32po
            Language     = "Polish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODPO
        }

        $PSObjectx32BETAPO = [PSCustomObject] @{
            Version      = $appVersionbeta32po
            Language     = "Polish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAPO
        }

        $PSObjectx64PRODPG = [PSCustomObject] @{
            Version      = $appVersionprodpg
            Language     = "Portuguese"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODPG
        }

        $PSObjectx64BETAPG = [PSCustomObject] @{
            Version      = $appVersionbetapg
            Language     = "Portuguese"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAPG
        }

        $PSObjectx32PRODPG = [PSCustomObject] @{
            Version      = $appVersionprod32pg
            Language     = "Portuguese"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODPG
        }

        $PSObjectx32BETAPG = [PSCustomObject] @{
            Version      = $appVersionbeta32pg
            Language     = "Portuguese"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAPG
        }

        $PSObjectx64PRODRU = [PSCustomObject] @{
            Version      = $appVersionprodru
            Language     = "Russian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODRU
        }

        $PSObjectx64BETARU = [PSCustomObject] @{
            Version      = $appVersionbetaru
            Language     = "Russian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETARU
        }

        $PSObjectx32PRODRU = [PSCustomObject] @{
            Version      = $appVersionprod32ru
            Language     = "Russian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODRU
        }

        $PSObjectx32BETARU = [PSCustomObject] @{
            Version      = $appVersionbeta32ru
            Language     = "Russian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETARU
        }

        $PSObjectx64PRODES = [PSCustomObject] @{
            Version      = $appVersionprodes
            Language     = "Spanish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODES
        }

        $PSObjectx64BETAES = [PSCustomObject] @{
            Version      = $appVersionbetaes
            Language     = "Spanish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAES
        }

        $PSObjectx32PRODES = [PSCustomObject] @{
            Version      = $appVersionprod32es
            Language     = "Spanish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODES
        }

        $PSObjectx32BETAES = [PSCustomObject] @{
            Version      = $appVersionbeta32es
            Language     = "Spanish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAES
        }

        $PSObjectx64PRODSV = [PSCustomObject] @{
            Version      = $appVersionprodsv
            Language     = "Swedish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODSV
        }

        $PSObjectx64BETASV = [PSCustomObject] @{
            Version      = $appVersionbetasv
            Language     = "Swedish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETASV
        }

        $PSObjectx32PRODSV = [PSCustomObject] @{
            Version      = $appVersionprod32sv
            Language     = "Swedish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODSV
        }

        $PSObjectx32BETASV = [PSCustomObject] @{
            Version      = $appVersionbeta32sv
            Language     = "Swedish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETASV
        }

        $PSObjectx64PRODUK = [PSCustomObject] @{
            Version      = $appVersionproduk
            Language     = "Ukrainian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODUK
        }

        $PSObjectx64BETAUK = [PSCustomObject] @{
            Version      = $appVersionbetauk
            Language     = "Ukrainian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAUK
        }

        $PSObjectx32PRODUK = [PSCustomObject] @{
            Version      = $appVersionprod32uk
            Language     = "Ukrainian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODUK
        }

        $PSObjectx32BETAUK = [PSCustomObject] @{
            Version      = $appVersionbeta32uk
            Language     = "Ukrainian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAUK
        }

        $PSObjectx64PRODtr = [PSCustomObject] @{
            Version      = $appVersionprodtr
            Language     = "Turkish"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODtr
        }

        $PSObjectx64BETAtr = [PSCustomObject] @{
            Version      = $appVersionbetatr
            Language     = "Turkish"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAtr
        }

        $PSObjectx32PRODtr = [PSCustomObject] @{
            Version      = $appVersionprod32tr
            Language     = "Turkish"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODtr
        }

        $PSObjectx32BETAtr = [PSCustomObject] @{
            Version      = $appVersionbeta32tr
            Language     = "Turkish"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAtr
        }

        $PSObjectx64PRODhe = [PSCustomObject] @{
            Version      = $appVersionprodhe
            Language     = "Hebrew"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODhe
        }

        $PSObjectx64BETAhe = [PSCustomObject] @{
            Version      = $appVersionbetahe
            Language     = "Hebrew"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAhe
        }

        $PSObjectx32PRODhe = [PSCustomObject] @{
            Version      = $appVersionprod32he
            Language     = "Hebrew"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODhe
        }

        $PSObjectx32BETAhe = [PSCustomObject] @{
            Version      = $appVersionbeta32he
            Language     = "Hebrew"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAhe
        }

        $PSObjectx64PRODar = [PSCustomObject] @{
            Version      = $appVersionprodar
            Language     = "Arabic"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODar
        }

        $PSObjectx64BETAar = [PSCustomObject] @{
            Version      = $appVersionbetaar
            Language     = "Arabic"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAar
        }

        $PSObjectx32PRODar = [PSCustomObject] @{
            Version      = $appVersionprod32ar
            Language     = "Arabic"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODar
        }

        $PSObjectx32BETAar = [PSCustomObject] @{
            Version      = $appVersionbeta32ar
            Language     = "Arabic"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAar
        }

        $PSObjectx64PRODtc = [PSCustomObject] @{
            Version      = $appVersionprodtc
            Language     = "Chinese"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODtc
        }

        $PSObjectx64BETAtc = [PSCustomObject] @{
            Version      = $appVersionbetatc
            Language     = "Chinese"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAtc
        }

        $PSObjectx32PRODtc = [PSCustomObject] @{
            Version      = $appVersionprod32tc
            Language     = "Chinese"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODtc
        }

        $PSObjectx32BETAtc = [PSCustomObject] @{
            Version      = $appVersionbeta32tc
            Language     = "Chinese"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAtc
        }

        $PSObjectx64PRODcz = [PSCustomObject] @{
            Version      = $appVersionprodcz
            Language     = "Czech"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODcz
        }

        $PSObjectx64BETAcz = [PSCustomObject] @{
            Version      = $appVersionbetacz
            Language     = "Czech"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAcz
        }

        $PSObjectx32PRODcz = [PSCustomObject] @{
            Version      = $appVersionprod32cz
            Language     = "Czech"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODcz
        }

        $PSObjectx32BETAcz = [PSCustomObject] @{
            Version      = $appVersionbeta32cz
            Language     = "Czech"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAcz
        }

        $PSObjectx64PRODsk = [PSCustomObject] @{
            Version      = $appVersionprodsk
            Language     = "Slovak"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODsk
        }

        $PSObjectx64BETAsk = [PSCustomObject] @{
            Version      = $appVersionbetask
            Language     = "Slovak"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAsk
        }

        $PSObjectx32PRODsk = [PSCustomObject] @{
            Version      = $appVersionprod32sk
            Language     = "Slovak"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODsk
        }

        $PSObjectx32BETAsk = [PSCustomObject] @{
            Version      = $appVersionbeta32sk
            Language     = "Slovak"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAsk
        }

        $PSObjectx64PRODhu = [PSCustomObject] @{
            Version      = $appVersionprodhu
            Language     = "Hungarian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODhu
        }

        $PSObjectx64BETAhu = [PSCustomObject] @{
            Version      = $appVersionbetahu
            Language     = "Hungarian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAhu
        }

        $PSObjectx32PRODhu = [PSCustomObject] @{
            Version      = $appVersionprod32hu
            Language     = "Hungarian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODhu
        }

        $PSObjectx32BETAhu = [PSCustomObject] @{
            Version      = $appVersionbeta32hu
            Language     = "Hungarian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAhu
        }

        $PSObjectx64PRODslv = [PSCustomObject] @{
            Version      = $appVersionprodslv
            Language     = "Slovenian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODslv
        }

        $PSObjectx64BETAslv = [PSCustomObject] @{
            Version      = $appVersionbetaslv
            Language     = "Slovenian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAslv
        }

        $PSObjectx32PRODslv = [PSCustomObject] @{
            Version      = $appVersionprod32slv
            Language     = "Slovenian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODslv
        }

        $PSObjectx32BETAslv = [PSCustomObject] @{
            Version      = $appVersionbeta32slv
            Language     = "Slovenian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAslv
        }

        $PSObjectx64PRODro = [PSCustomObject] @{
            Version      = $appVersionprodro
            Language     = "Romanian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODro
        }

        $PSObjectx64BETAro = [PSCustomObject] @{
            Version      = $appVersionbetaro
            Language     = "Romanian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAro
        }

        $PSObjectx32PRODro = [PSCustomObject] @{
            Version      = $appVersionprod32ro
            Language     = "Romanian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODro
        }

        $PSObjectx32BETAro = [PSCustomObject] @{
            Version      = $appVersionbeta32ro
            Language     = "Romanian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAro
        }

        $PSObjectx64PRODcro = [PSCustomObject] @{
            Version      = $appVersionprodcro
            Language     = "Croatian"
            Architecture = "x64"
            Channel      = "Stable"
            URI          = $appx64URLPRODcro
        }

        $PSObjectx64BETAcro = [PSCustomObject] @{
            Version      = $appVersionbetacro
            Language     = "Croatian"
            Architecture = "x64"
            Channel      = "Beta"
            URI          = $appx64URLBETAcro
        }

        $PSObjectx32PRODcro = [PSCustomObject] @{
            Version      = $appVersionprod32cro
            Language     = "Croatian"
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $appx32URLPRODcro
        }

        $PSObjectx32BETAcro = [PSCustomObject] @{
            Version      = $appVersionbeta32cro
            Language     = "Croatian"
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $appx32URLBETAcro
        }

        Write-Output -InputObject $PSObjectx64BETAEN
        Write-Output -InputObject $PSObjectx64PRODEN
        Write-Output -InputObject $PSObjectx32BETAEN
        Write-Output -InputObject $PSObjectx32PRODEN
        Write-Output -InputObject $PSObjectx64BETADK
        Write-Output -InputObject $PSObjectx64PRODDK
        Write-Output -InputObject $PSObjectx32BETADK
        Write-Output -InputObject $PSObjectx32PRODDK
        Write-Output -InputObject $PSObjectx64BETANL
        Write-Output -InputObject $PSObjectx64PRODNL
        Write-Output -InputObject $PSObjectx32BETANL
        Write-Output -InputObject $PSObjectx32PRODNL
        Write-Output -InputObject $PSObjectx64BETAFN
        Write-Output -InputObject $PSObjectx64PRODFN
        Write-Output -InputObject $PSObjectx32BETAFN
        Write-Output -InputObject $PSObjectx32PRODFN
        Write-Output -InputObject $PSObjectx64BETAFR
        Write-Output -InputObject $PSObjectx64PRODFR
        Write-Output -InputObject $PSObjectx32BETAFR
        Write-Output -InputObject $PSObjectx32PRODFR
        Write-Output -InputObject $PSObjectx64BETADE
        Write-Output -InputObject $PSObjectx64PRODDE
        Write-Output -InputObject $PSObjectx32BETADE
        Write-Output -InputObject $PSObjectx32PRODDE
        Write-Output -InputObject $PSObjectx64BETAIT
        Write-Output -InputObject $PSObjectx64PRODIT
        Write-Output -InputObject $PSObjectx32BETAIT
        Write-Output -InputObject $PSObjectx32PRODIT
        Write-Output -InputObject $PSObjectx64BETAJP
        Write-Output -InputObject $PSObjectx64PRODJP
        Write-Output -InputObject $PSObjectx32BETAJP
        Write-Output -InputObject $PSObjectx32PRODJP
        Write-Output -InputObject $PSObjectx64BETAKO
        Write-Output -InputObject $PSObjectx64PRODKO
        Write-Output -InputObject $PSObjectx32BETAKO
        Write-Output -InputObject $PSObjectx32PRODKO
        Write-Output -InputObject $PSObjectx64BETANB
        Write-Output -InputObject $PSObjectx64PRODNB
        Write-Output -InputObject $PSObjectx32BETANB
        Write-Output -InputObject $PSObjectx32PRODNB
        Write-Output -InputObject $PSObjectx64BETAPO
        Write-Output -InputObject $PSObjectx64PRODPO
        Write-Output -InputObject $PSObjectx32BETAPO
        Write-Output -InputObject $PSObjectx32PRODPO
        Write-Output -InputObject $PSObjectx64BETAPG
        Write-Output -InputObject $PSObjectx64PRODPG
        Write-Output -InputObject $PSObjectx32BETAPG
        Write-Output -InputObject $PSObjectx32PRODPG
        Write-Output -InputObject $PSObjectx64BETARU
        Write-Output -InputObject $PSObjectx64PRODRU
        Write-Output -InputObject $PSObjectx32BETARU
        Write-Output -InputObject $PSObjectx32PRODRU
        Write-Output -InputObject $PSObjectx64BETAES
        Write-Output -InputObject $PSObjectx64PRODES
        Write-Output -InputObject $PSObjectx32BETAES
        Write-Output -InputObject $PSObjectx32PRODES
        Write-Output -InputObject $PSObjectx64BETASV
        Write-Output -InputObject $PSObjectx64PRODSV
        Write-Output -InputObject $PSObjectx32BETASV
        Write-Output -InputObject $PSObjectx32PRODSV
        Write-Output -InputObject $PSObjectx64BETAUK
        Write-Output -InputObject $PSObjectx64PRODUK
        Write-Output -InputObject $PSObjectx32BETAUK
        Write-Output -InputObject $PSObjectx32PRODUK
        Write-Output -InputObject $PSObjectx64BETAtr
        Write-Output -InputObject $PSObjectx64PRODtr
        Write-Output -InputObject $PSObjectx32BETAtr
        Write-Output -InputObject $PSObjectx32PRODtr
        Write-Output -InputObject $PSObjectx64BETAhe
        Write-Output -InputObject $PSObjectx64PRODhe
        Write-Output -InputObject $PSObjectx32BETAhe
        Write-Output -InputObject $PSObjectx32PRODhe
        Write-Output -InputObject $PSObjectx64BETAar
        Write-Output -InputObject $PSObjectx64PRODar
        Write-Output -InputObject $PSObjectx32BETAar
        Write-Output -InputObject $PSObjectx32PRODar
        Write-Output -InputObject $PSObjectx64BETAtc
        Write-Output -InputObject $PSObjectx64PRODtc
        Write-Output -InputObject $PSObjectx32BETAtc
        Write-Output -InputObject $PSObjectx32PRODtc
        Write-Output -InputObject $PSObjectx64BETAcz
        Write-Output -InputObject $PSObjectx64PRODcz
        Write-Output -InputObject $PSObjectx32BETAcz
        Write-Output -InputObject $PSObjectx32PRODcz
        Write-Output -InputObject $PSObjectx64BETAsk
        Write-Output -InputObject $PSObjectx64PRODsk
        Write-Output -InputObject $PSObjectx32BETAsk
        Write-Output -InputObject $PSObjectx32PRODsk
        Write-Output -InputObject $PSObjectx64BETAhu
        Write-Output -InputObject $PSObjectx64PRODhu
        Write-Output -InputObject $PSObjectx32BETAhu
        Write-Output -InputObject $PSObjectx32PRODhu
        Write-Output -InputObject $PSObjectx64BETAslv
        Write-Output -InputObject $PSObjectx64PRODslv
        Write-Output -InputObject $PSObjectx32BETAslv
        Write-Output -InputObject $PSObjectx32PRODslv
        Write-Output -InputObject $PSObjectx64BETAro
        Write-Output -InputObject $PSObjectx64PRODro
        Write-Output -InputObject $PSObjectx32BETAro
        Write-Output -InputObject $PSObjectx32PRODro
        Write-Output -InputObject $PSObjectx64BETAcro
        Write-Output -InputObject $PSObjectx64PRODcro
        Write-Output -InputObject $PSObjectx32BETAcro
        Write-Output -InputObject $PSObjectx32PRODcro
    }
}

# Function MindView Download
#========================================================================================================================================
Function Get-MindView() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.matchware.com/de/mindview-servicepacks"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "MindView 8.*8.*"
        $webVersionMV = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webVersionMV = $webVersionMV.Split("(")[1]
        $appVersion = $webVersionMV.Split(")")[0]
        
        $appx64URLDE = "https://link.matchware.com/mindview8"
        $appx64URLEN = "https://link.matchware.com/mindview8"
        $appx64URLFR = "https://link.matchware.com/mindview8"
        $appx64URLDK = "https://link.matchware.com/mindview8"

        $PSObjectx64de = [PSCustomObject] @{
            Version      = $appVersion
            Language      = "German"
            URI          = $appx64URLDE
        }

        $PSObjectx64en = [PSCustomObject] @{
            Version      = $appVersion
            Language      = "English"
            URI          = $appx64URLEN
        }

        $PSObjectx64fr = [PSCustomObject] @{
            Version      = $appVersion
            Language      = "French"
            URI          = $appx64URLFR
        }

        $PSObjectx64dk = [PSCustomObject] @{
            Version      = $appVersion
            Language      = "Danish"
            URI          = $appx64URLDK
        }

        Write-Output -InputObject $PSObjectx64de
        Write-Output -InputObject $PSObjectx64en
        Write-Output -InputObject $PSObjectx64fr
        Write-Output -InputObject $PSObjectx64dk
        
    }
}

# Function Zoom VDI Download
#========================================================================================================================================
Function Get-ZoomVDI {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://support.zoom.us/hc/en-us/articles/4415057249549"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersionD = 'class="panel-title"><a class="fill-div" href="#collapseGeneric.." data-toggle="collapse">........'
        $webVersionZoomVDID = $webRequest.RawContent | Select-String -Pattern $regexAppVersionD -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplitD = $webVersionZoomVDID.Split(">")
        $webSplitD = $webSplitD[2].Split("<")
        #$VersionD = $webSplitD[0]
        $regexAppVersion = 'ZoomCitrixHDXMediaPlugin.msi" target="_self" rel="undefined">..............'
        $webVersionZoomVDI = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersionZoomVDI.Split(">")
        $webSplit = $webSplit[1].Split("<")
        $Version = $webSplit[0]
        $VersionSplit = $Version.Split(".")
        $VersionApps = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[3]
        $x64 = "https://zoom.us/download/vdi/" + $Version + "/ZoomInstallerVDI.msi"
        
        $PSObjectx64 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x64"
        URI          = $x64
        VersionApps = $VersionApps
        }

        Write-Output -InputObject $PSObjectx64
    }
}

# Function Ditto Download
#========================================================================================================================================
Function Get-Ditto {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://ditto-cp.sourceforge.io/"
        $urlbeta = "https://ditto-cp.sourceforge.io/beta/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
        $webRequestbeta = Invoke-WebRequest -UseBasicParsing -Uri $urlbeta -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'versionDots=".*'
        $regexAppVersionD = 'versionUnder=".*'
        $regexAppVersionBeta = 'version .*'
        $webVersionDitto = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webVersionDittoD = $webRequest.RawContent | Select-String -Pattern $regexAppVersionD -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webVersionDittoBeta = $webRequestbeta.RawContent | Select-String -Pattern $regexAppVersionBeta -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersionDitto.Split('"')
        $webSplitD = $webVersionDittoD.Split('"')
        $webSplitBeta = $webVersionDittoBeta.Split(' ')
        $VersionBeta = $webSplitBeta[1].Split("<")
        $Version = $webSplit[1]
        $VersionD = $webSplitD[1]
        $VersionBeta = $VersionBeta[0]
        $VersionBetaD = $VersionBeta.Replace(".", "_")
        $x32 = "https://github.com/sabrogden/Ditto/releases/download/" + $Version + "/DittoSetup_" + $VersionD + ".exe"
        $x64 = "https://github.com/sabrogden/Ditto/releases/download/" + $Version + "/DittoSetup_64bit_" + $VersionD + ".exe"
        $x32beta = "https://ditto-cp.sourceforge.io/beta/files/DittoSetup_" + $VersionBetaD + ".exe"
        $x64beta = "https://ditto-cp.sourceforge.io/beta/files/DittoSetup_64bit_" + $VersionBetaD + ".exe"
        
        $PSObjectx32 = [PSCustomObject] @{
            Version      = $Version
            Architecture = "x86"
            Channel      = "Stable"
            URI          = $x32
            }

        $PSObjectx64 = [PSCustomObject] @{
        Version      = $Version
        Architecture = "x64"
        Channel      = "Stable"
        URI          = $x64
        }

        $PSObjectx32Beta = [PSCustomObject] @{
            Version      = $VersionBeta
            Architecture = "x86"
            Channel      = "Beta"
            URI          = $x32beta
            }

        $PSObjectx64Beta = [PSCustomObject] @{
        Version      = $VersionBeta
        Architecture = "x64"
        Channel      = "Beta"
        URI          = $x64beta
        }

        Write-Output -InputObject $PSObjectx32
        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx32Beta
        Write-Output -InputObject $PSObjectx64Beta
    }
}

# Function XCA Download
#========================================================================================================================================
Function Get-XCA {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://github.com/chris2511/xca/releases/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'RELEASE.2....'
        $webVersionXCA = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersionXCA.Split('.')
        $Version = $webSplit[1] + "." + $webSplit[2] + "." + $webSplit[3]
        $x32 = "https://github.com/chris2511/xca/releases/download/RELEASE." + $Version +  "/" + "xca-" + $Version + "-win64.msi"
        
        $PSObjectx32 = [PSCustomObject] @{
            Version      = $Version
            Channel      = "Stable"
            URI          = $x32
            }

        Write-Output -InputObject $PSObjectx32
    }
}

# Function Citrix Optimizer Download
#========================================================================================================================================
Function Get-CitrixOptimizer {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://www.deyda.net/wp-content/uploads/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'CitrixOptimizerTool-.*zip'
        $webVersionCO = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersionCO.Split('-')
        $Version = $webSplit[2].TrimEnd('.zip')
        $x32 = "https://www.deyda.net/wp-content/uploads/CitrixOptimizerTool-" + $Version + ".zip"
        
        $PSObjectx32 = [PSCustomObject] @{
            Version      = $Version
            URI          = $x32
            }

        Write-Output -InputObject $PSObjectx32
    }
}

# Function SDelete Download
#========================================================================================================================================
Function Get-SDelete {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://learn.microsoft.com/en-us/sysinternals/downloads/sdelete"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'SDelete v.*\<'
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersion.Split('v')
        $Version = $webSplit[1].TrimEnd('<')
        $x32 = "https://download.sysinternals.com/files/SDelete.zip"
        
        $PSObjectx32 = [PSCustomObject] @{
            Version      = $Version
            URI          = $x32
            }

        Write-Output -InputObject $PSObjectx32
    }
}

# Function DelProf2 Download
#========================================================================================================================================
Function Get-DelProf2 {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
        $url = "https://helgeklein.com/download/"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri $url -ErrorAction SilentlyContinue
    }
    Catch {
        Throw "Failed to connect to URL: $url with error $_."
        Break
    }
    Finally {
        $regexAppVersion = 'DelProf2 .*zip'
        $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $webSplit = $webVersion.Split(' ')
        $Version = $webSplit[1].TrimEnd('.zip')
        $x32 = "https://helgeklein.com/downloads/DelProf2/current/Delprof2 " + $Version + ".zip"
        
        $PSObjectx32 = [PSCustomObject] @{
            Version      = $Version
            URI          = $x32
            }

        Write-Output -InputObject $PSObjectx32
    }
}

# Function PuTTY Download Stable and Pre-Release Version
#========================================================================================================================================
Function Get-PuTTY() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html"
    $appURLVersionPre = "https://www.chiark.greenend.org.uk/~sgtatham/putty/prerel.html"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
        $webRequestPre = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersionPre) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion or $appURLVersionPre with error $_."
        Break
    }
    Finally {
        $regexAppVersion = "\(.*\)\<\/TITLE\>"
        $webVersionPutty = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        $CacheVersion = $webVersionPutty.Split()[0].Trim("</TITLE>")
        $CacheVersion = $CacheVersion.Split()[0].Trim("(")
        $CacheVersion = $CacheVersion.Split()[0].Trim(")")
        $appVersion = $CacheVersion
        $appx64URL = "https://the.earth.li/~sgtatham/putty/latest/w64/putty-64bit-$appVersion-installer.msi"
        $appx86URL = "https://the.earth.li/~sgtatham/putty/latest/w32/putty-$appVersion-installer.msi"
        $regexAppVersionPre = "of .*"
        $webVersionPre = $webRequestPre.RawContent | Select-String -Pattern $regexAppVersionPre -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
        If ($webVersionPre){
            $appVersionPre = $webVersionPre.Split()[1].Trim("of ")
            $appx64URLPre = "https://tartarus.org/~simon/putty-prerel-snapshots/w64/putty-64bit-installer.msi"
            $appx86URLPre = "https://tartarus.org/~simon/putty-prerel-snapshots/w32/putty-installer.msi"
        }
        $PSObjectx86 = [PSCustomObject] @{
            Version      = $appVersion
            Channel      = "Stable"
            Architecture = "x86"
            URI          = $appx86URL
        }

        $PSObjectx64 = [PSCustomObject] @{
            Version      = $appVersion
            Channel      = "Stable"
            Architecture = "x64"
            URI          = $appx64URL
        }
        If ($webVersionPre){
            $PSObjectx86Pre = [PSCustomObject] @{
                Version      = $appVersionPre
                Channel      = "Pre-Release"
                Architecture = "x86"
                URI          = $appx86URLPre
            }

            $PSObjectx64Pre = [PSCustomObject] @{
                Version      = $appVersionPre
                Channel      = "Pre-Release"
                Architecture = "x64"
                URI          = $appx64URLPre
            }
        }
        else {
            $PSObjectx86Pre = [PSCustomObject] @{
            Version      = $appVersion
            Channel      = "Pre-Release"
            Architecture = "x86"
            URI          = $appx86URL
            }

            $PSObjectx64Pre = [PSCustomObject] @{
                Version      = $appVersion
                Channel      = "Pre-Release"
                Architecture = "x64"
                URI          = $appx64URL
            }
        }

        Write-Output -InputObject $PSObjectx86
        Write-Output -InputObject $PSObjectx64
        Write-Output -InputObject $PSObjectx86Pre
        Write-Output -InputObject $PSObjectx64Pre
        
    }
}

# Function KeePass Language
#========================================================================================================================================
Function Get-KeePassLanguage() {
    [OutputType([System.Management.Automation.PSObject])]
    [CmdletBinding()]
    Param ()
    $appURLVersion = "https://keepass.info/translations.html"
    Try {
        $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($appURLVersion) -SessionVariable websession
    }
    Catch {
        Throw "Failed to connect to URL: $appURLVersion with error $_."
        Break
    }
    Finally {
        $regexLanguageGerman = 'https:\/\/.*German.zip'
        $URLGerman = $webRequest.RawContent | Select-String -Pattern $regexLanguageGerman -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionGerman = $URLGerman.Split("-")[1]
        $regexLanguageDutch = 'https:\/\/.*Dutch.zip'
        $URLDutch = $webRequest.RawContent | Select-String -Pattern $regexLanguageDutch -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionDutch = $URLDutch.Split("-")[1]
        $regexLanguageDanish = 'https:\/\/.*Danish.zip'
        $URLDanish = $webRequest.RawContent | Select-String -Pattern $regexLanguageDanish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionDanish = $URLDanish.Split("-")[1]
        $regexLanguageFinnish = 'https:\/\/.*Finnish.zip'
        $URLFinnish = $webRequest.RawContent | Select-String -Pattern $regexLanguageFinnish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionFinnish = $URLFinnish.Split("-")[1]
        $regexLanguageFrench = 'https:\/\/.*French.zip'
        $URLFrench = $webRequest.RawContent | Select-String -Pattern $regexLanguageFrench -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionFrench = $URLFrench.Split("-")[1]
        $regexLanguageItalian = 'https:\/\/.*Italian-b.zip'
        $URLItalian = $webRequest.RawContent | Select-String -Pattern $regexLanguageItalian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionItalian = $URLItalian.Split("-")[1]
        $regexLanguageJapanese = 'https:\/\/.*Japanese.zip'
        $URLJapanese = $webRequest.RawContent | Select-String -Pattern $regexLanguageJapanese -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionJapanese = $URLJapanese.Split("-")[1]
        $regexLanguageKorean = 'https:\/\/.*Korean.zip'
        $URLKorean = $webRequest.RawContent | Select-String -Pattern $regexLanguageKorean -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionKorean = $URLKorean.Split("-")[1]
        $regexLanguageNorwegian = 'https:\/\/.*Norwegian_NB.zip'
        $URLNorwegian = $webRequest.RawContent | Select-String -Pattern $regexLanguageNorwegian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionNorwegian = $URLNorwegian.Split("-")[1]
        $regexLanguagePolish = 'https:\/\/.*Polish.zip'
        $URLPolish = $webRequest.RawContent | Select-String -Pattern $regexLanguagePolish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionPolish = $URLPolish.Split("-")[1]
        $regexLanguagePortuguese = 'https:\/\/.*Portuguese_PT.zip'
        $URLPortuguese = $webRequest.RawContent | Select-String -Pattern $regexLanguagePortuguese -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionPortuguese = $URLPortuguese.Split("-")[1]
        $regexLanguageRussian = 'https:\/\/.*Russian.zip'
        $URLRussian = $webRequest.RawContent | Select-String -Pattern $regexLanguageRussian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionRussian = $URLRussian.Split("-")[1]
        $regexLanguageSpanish = 'https:\/\/.*Spanish.zip'
        $URLSpanish = $webRequest.RawContent | Select-String -Pattern $regexLanguageSpanish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionSpanish = $URLSpanish.Split("-")[1]
        $regexLanguageSwedish = 'https:\/\/.*Swedish.zip'
        $URLSwedish = $webRequest.RawContent | Select-String -Pattern $regexLanguageSwedish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionSwedish = $URLSwedish.Split("-")[1]
        $regexLanguageArabic = 'https:\/\/.*Arabic.zip'
        $URLArabic = $webRequest.RawContent | Select-String -Pattern $regexLanguageArabic -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionArabic = $URLArabic.Split("-")[1]
        $regexLanguageCzech = 'https:\/\/.*Czech.zip'
        $URLCzech = $webRequest.RawContent | Select-String -Pattern $regexLanguageCzech -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionCzech = $URLCzech.Split("-")[1]
        $regexLanguageSlovak = 'https:\/\/.*Slovak.zip'
        $URLSlovak = $webRequest.RawContent | Select-String -Pattern $regexLanguageSlovak -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionSlovak = $URLSlovak.Split("-")[1]
        $regexLanguageUkrainian = 'https:\/\/.*Ukrainian.zip'
        $URLUkrainian = $webRequest.RawContent | Select-String -Pattern $regexLanguageUkrainian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionUkrainian = $URLUkrainian.Split("-")[1]
        $regexLanguageHungarian = 'https:\/\/.*Hungarian.zip'
        $URLHungarian = $webRequest.RawContent | Select-String -Pattern $regexLanguageHungarian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionHungarian = $URLHungarian.Split("-")[1]
        $regexLanguageTurkish = 'https:\/\/.*Turkish.zip'
        $URLTurkish = $webRequest.RawContent | Select-String -Pattern $regexLanguageTurkish -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionTurkish = $URLTurkish.Split("-")[1]
        $regexLanguageSlovenian = 'https:\/\/.*Slovenian.zip'
        $URLSlovenian = $webRequest.RawContent | Select-String -Pattern $regexLanguageSlovenian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionSlovenian = $URLSlovenian.Split("-")[1]
        $regexLanguageRomanian = 'https:\/\/.*Romanian.zip'
        $URLRomanian = $webRequest.RawContent | Select-String -Pattern $regexLanguageRomanian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionRomanian = $URLRomanian.Split("-")[1]
        $regexLanguageCroatian = 'https:\/\/.*Croatian.zip'
        $URLCroatian = $webRequest.RawContent | Select-String -Pattern $regexLanguageCroatian -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionCroatian = $URLCroatian.Split("-")[1]
        $regexLanguageHebrew = 'https:\/\/.*Hebrew.zip'
        $URLHebrew = $webRequest.RawContent | Select-String -Pattern $regexLanguageHebrew -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionHebrew = $URLHebrew.Split("-")[1]
        $regexLanguageChinese = 'https:\/\/.*Chinese.zip'
        $URLChinese = $webRequest.RawContent | Select-String -Pattern $regexLanguageChinese -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -Last 1
        $VersionChinese = $URLChinese.Split("-")[1]

        $PSObjectGerman = [PSCustomObject] @{
            Language     = "German"
            Version      = $VersionGerman
            URI          = $URLGerman
        }

        $PSObjectDutch = [PSCustomObject] @{
            Language     = "Dutch"
            Version      = $VersionDutch
            URI          = $URLDutch
        }

        $PSObjectDanish = [PSCustomObject] @{
            Language     = "Danish"
            Version      = $VersionDanish
            URI          = $URLDanish
        }

        $PSObjectFinnish = [PSCustomObject] @{
            Language     = "Finnish"
            Version      = $VersionFinnish
            URI          = $URLFinnish
        }

        $PSObjectFrench = [PSCustomObject] @{
            Language     = "French"
            Version      = $VersionFrench
            URI          = $URLFrench
        }

        $PSObjectItalian = [PSCustomObject] @{
            Language     = "Italian"
            Version      = $VersionItalian
            URI          = $URLItalian
        }

        $PSObjectJapanese = [PSCustomObject] @{
            Language     = "Japanese"
            Version      = $VersionJapanese
            URI          = $URLJapanese
        }

        $PSObjectKorean = [PSCustomObject] @{
            Language     = "Korean"
            Version      = $VersionKorean
            URI          = $URLKorean
        }

        $PSObjectNorwegian = [PSCustomObject] @{
            Language     = "Norwegian"
            Version      = $VersionNorwegian
            URI          = $URLNorwegian
        }

        $PSObjectPolish = [PSCustomObject] @{
            Language     = "Polish"
            Version      = $VersionPolish
            URI          = $URLPolish
        }

        $PSObjectPortuguese = [PSCustomObject] @{
            Language     = "Portuguese"
            Version      = $VersionPortuguese
            URI          = $URLPortuguese
        }

        $PSObjectRussian = [PSCustomObject] @{
            Language     = "Russian"
            Version      = $VersionRussian
            URI          = $URLRussian
        }

        $PSObjectSpanish = [PSCustomObject] @{
            Language     = "Spanish"
            Version      = $VersionSpanish
            URI          = $URLSpanish
        }

        $PSObjectSwedish = [PSCustomObject] @{
            Language     = "Swedish"
            Version      = $VersionSwedish
            URI          = $URLSwedish
        }

        $PSObjectArabic = [PSCustomObject] @{
            Language     = "Arabic"
            Version      = $VersionArabic
            URI          = $URLArabic
        }

        $PSObjectCzech = [PSCustomObject] @{
            Language     = "Czech"
            Version      = $VersionCzech
            URI          = $URLCzech
        }

        $PSObjectSlovak = [PSCustomObject] @{
            Language     = "Slovak"
            Version      = $VersionSlovak
            URI          = $URLSlovak
        }

        $PSObjectUkrainian = [PSCustomObject] @{
            Language     = "Ukrainian"
            Version      = $VersionUkrainian
            URI          = $URLUkrainian
        }

        $PSObjectHungarian = [PSCustomObject] @{
            Language     = "Hungarian"
            Version      = $VersionHungarian
            URI          = $URLHungarian
        }

        $PSObjectTurkish = [PSCustomObject] @{
            Language     = "Turkish"
            Version      = $VersionTurkish
            URI          = $URLTurkish
        }

        $PSObjectSlovenian = [PSCustomObject] @{
            Language     = "Slovenian"
            Version      = $VersionSlovenian
            URI          = $URLSlovenian
        }

        $PSObjectRomanian = [PSCustomObject] @{
            Language     = "Romanian"
            Version      = $VersionRomanian
            URI          = $URLRomanian
        }

        $PSObjectCroatian = [PSCustomObject] @{
            Language     = "Croatian"
            Version      = $VersionCroatian
            URI          = $URLCroatian
        }

        $PSObjectHebrew = [PSCustomObject] @{
            Language     = "Hebrew"
            Version      = $VersionHebrew
            URI          = $URLHebrew
        }

        $PSObjectChinese = [PSCustomObject] @{
            Language     = "Chinese"
            Version      = $VersionChinese
            URI          = $URLChinese
        }

        Write-Output -InputObject $PSObjectArabic
        Write-Output -InputObject $PSObjectChinese
        Write-Output -InputObject $PSObjectCroatian
        Write-Output -InputObject $PSObjectCzech
        Write-Output -InputObject $PSObjectDutch
        Write-Output -InputObject $PSObjectDanish
        Write-Output -InputObject $PSObjectFinnish
        Write-Output -InputObject $PSObjectFrench
        Write-Output -InputObject $PSObjectGerman
        Write-Output -InputObject $PSObjectHebrew
        Write-Output -InputObject $PSObjectHungarian
        Write-Output -InputObject $PSObjectJapanese
        Write-Output -InputObject $PSObjectKorean
        Write-Output -InputObject $PSObjectItalian
        Write-Output -InputObject $PSObjectNorwegian
        Write-Output -InputObject $PSObjectPolish
        Write-Output -InputObject $PSObjectPortuguese
        Write-Output -InputObject $PSObjectRomanian
        Write-Output -InputObject $PSObjectRussian
        Write-Output -InputObject $PSObjectSlovak
        Write-Output -InputObject $PSObjectSlovenian
        Write-Output -InputObject $PSObjectSpanish
        Write-Output -InputObject $PSObjectSwedish
        Write-Output -InputObject $PSObjectTurkish
        Write-Output -InputObject $PSObjectUkrainian
    }
}

# Function Microsoft Office ADMX Download
#========================================================================================================================================
function Get-MicrosoftOfficeAdmx {
    $id = "49030"
    $urlversion = "https://www.microsoft.com/en-us/download/details.aspx?id=$($id)"
    $urldownload = "https://www.microsoft.com/en-us/download/confirmation.aspx?id=$($id)"
    try {
        $ProgressPreference = 'SilentlyContinue'
        $web = Invoke-WebRequest -UseBasicParsing -Uri $urlversion -ErrorAction SilentlyContinue
        $str = ($web.ToString() -split "[`r`n]" | Select-String "Version:").ToString()
        $Version = ($str | Select-String -Pattern "(\d+(\.\d+){1,4})" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }).ToString()
        $web = Invoke-WebRequest -UseBasicParsing -Uri $urldownload -ErrorAction SilentlyContinue -MaximumRedirection 0
        $hrefx64 = $web.Links | Where-Object { $_.outerHTML -like "*click here to download manually*" -and $_.href -like "*.exe" -and $_.href -like "*x64*" } | Select-Object -First 1
        $hrefx86 = $web.Links | Where-Object { $_.outerHTML -like "*click here to download manually*" -and $_.href -like "*.exe" -and $_.href -like "*x86*" } | Select-Object -First 1
        $PSObjectx86 = [PSCustomObject] @{
            Version      = $Version
            Architecture = "x86"
            URI          = $hrefx86.href
        }

        $PSObjectx64 = [PSCustomObject] @{
            Version      = $Version
            Architecture = "x64"
            URI          = $hrefx64.href
        }
    }
    catch {
        Throw $_
    }
    Write-Output -InputObject $PSObjectx86
    Write-Output -InputObject $PSObjectx64
}

# Function Google Chrome ADMX Download
#========================================================================================================================================
function Get-GoogleChromeAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $URI = "https://dl.google.com/dl/edgedl/chrome/policy/policy_templates.zip"
        Invoke-WebRequest -Uri $URI -OutFile "$($env:TEMP)\policy_templates.zip"
        Expand-Archive -Path "$($env:TEMP)\policy_templates.zip" -DestinationPath "$($env:TEMP)\chromeadmx" -Force
        $versionfile = (Get-Content -Path "$($env:TEMP)\chromeadmx\VERSION").Split('=')
        $Version = "$($versionfile[1]).$($versionfile[3]).$($versionfile[5]).$($versionfile[7])"
        return @{ Version = $Version; URI = $URI }
    }
    catch {
        Throw $_
    }
}

# Function Mozilla Firefox ADMX Download
#========================================================================================================================================
function Get-MozillaFirefoxAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $repo = "mozilla/policy-templates"
        $latest = (Invoke-WebRequest -Uri "https://api.github.com/repos/$($repo)/releases" -UseBasicParsing | ConvertFrom-Json)[0]
        $Version = ($latest.tag_name | Select-String -Pattern "(\d+(\.\d+){1,4})" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }).ToString()
        $URI = $latest.assets.browser_download_url
        return @{ Version = $Version; URI = $URI }
    }
    catch {
        Throw $_
    }
}

# Function Adobe Acrobat Reader DC ADMX Download
#========================================================================================================================================
function Get-AdobeAcrobatReaderDCAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $fileA = "ReaderADMTemplate.zip"
        $url = "ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/misc/"
        Write-Verbose "FTP $($url)"
        $listRequest = [Net.WebRequest]::Create($url)
        $listRequest.Method = [System.Net.WebRequestMethods+Ftp]::ListDirectoryDetails
        $lines = New-Object System.Collections.ArrayList
        $listResponse = $listRequest.GetResponse()
        $listStream = $listResponse.GetResponseStream()
        $listReader = New-Object System.IO.StreamReader($listStream)
        while (!$listReader.EndOfStream)
        {
            $line = $listReader.ReadLine()
            if ($line.Contains($fileA)) { $lines.Add($line) | Out-Null }
        }
        $listReader.Dispose()
        $listStream.Dispose()
        $listResponse.Dispose()
        Write-Verbose "received $($line.Length) characters response"
        $tokens = $lines[0].Split(" ", 9, [StringSplitOptions]::RemoveEmptyEntries)
        $Version = Get-Date -Date "$($tokens[6])/$($tokens[5])/$($tokens[7])" -Format "yy.M.d"
        return @{ Version = $Version; URI = "$($url)$($fileA)" }
    }
    catch {
        Throw $_
    }
}

# Function Citrix Workspace App Current ADMX Download
#========================================================================================================================================
function Get-CitrixWorkspaceAppCurrentAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $url = "https://www.citrix.com/downloads/workspace-app/windows/workspace-app-for-windows-latest.html"
        $web = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Ignore
        $str = ($web.Content -split "`r`n" | Select-String -Pattern "_ADMX_")[0].ToString().Trim()
        $URI = "https:$(((Select-String '(\/\/)([^\s,]+)(?=")' -Input $str).Matches.Value))"
        $filename = $URI.Split("/")[4].Split('?')[0].Split('_')[3]
        $Version = $filename.Replace(".zip", "") #($filename | Select-String -Pattern "(\d+(\.\d+){1,4})" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }).ToString()
        $Path = $Version
        if ($Version -notcontains '.') { $Version += ".0" }
        return @{ Version = $Version; URI = $URI; Path = $Path }
    }
    catch {
        Throw $_
    }
}

# Function Citrix Workspace App LTSR ADMX Download
#========================================================================================================================================
function Get-CitrixWorkspaceAppLTSRAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $url = "https://www.citrix.com/downloads/workspace-app/workspace-app-for-windows-long-term-service-release/workspace-app-for-windows-1912ltsr.html"
        $web = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Ignore
        $str = ($web.Content -split "`r`n" | Select-String -Pattern "_ADMX_")[0].ToString().Trim()
        $URI = "https:$(((Select-String '(\/\/)([^\s,]+)(?=")' -Input $str).Matches.Value))"
        $filename = $URI.Split("/")[4].Split('?')[0].Split('_')[4]
        $Version = $filename.Replace(".zip", "") 
        $Path = $filename.Replace(".zip", "") #($filename | Select-String -Pattern "(\d+(\.\d+){1,4})" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }).ToString()
        return @{ Version = $Version; URI = $URI; Path = $Path }
    }
    catch {
        Throw $_
    }
}

# Function Zoom ADMX Download
#========================================================================================================================================
function Get-ZoomAdmx {
    try {
        $ProgressPreference = 'SilentlyContinue'
        $url = "https://support.zoom.us/hc/en-us/articles/360039100051"
        # grab content
        $web = Invoke-WebRequest -Uri $url -UseBasicParsing -ErrorAction Ignore
        # find ADMX download
        $URI = (($web.Links | Where-Object {$_.href -like "*msi-templates*.zip"})[-1]).href
        # grab version
        $Version = ($URI.Split("/")[-1] | Select-String -Pattern "(\d+(\.\d+){1,4})" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }).ToString()

        # return object
        return @{ Version = $Version; URI = $URI }
    }
    catch {
        Throw $_
    }
}

# Function Test RegistryValue Pending Reboot
#========================================================================================================================================
Function Test-RegistryValue {
    Param (
        [parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Path,
        [parameter(Mandatory=$true)] [ValidateNotNullOrEmpty()]$Value
    )
    Try {
        Get-ItemProperty -Path $Path | Select-Object -ExpandProperty $Value -ErrorAction Stop | Out-Null
        Return $true
    }
    Catch {
        Return $false
    }
}

# Function Test RegistryValue
#========================================================================================================================================
Function Test-RegistryValue2 {
    Param (
        [parameter(Mandatory=$true)][ValidateNotNullOrEmpty()]$Path,
        [parameter(Mandatory=$true)] [ValidateNotNullOrEmpty()]$Value
    )
    Try {
        Get-ItemProperty -Path $Path | Select-Object -ExpandProperty $Value -ErrorAction SilentlyContinue | Out-Null
        Return $true
    }
    Catch {
        Return $false
    }
}

# Function Logging
#========================================================================================================================================
Function DS_WriteLog {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true, Position = 0)][ValidateSet("I","S","W","E","-",IgnoreCase = $True)][String]$InformationType,
        [Parameter(Mandatory=$true, Position = 1)][AllowEmptyString()][String]$Text,
        [Parameter(Mandatory=$true, Position = 2)][AllowEmptyString()][String]$LogFile
    )
    Begin {
    }
    Process {
        $DateTime = (Get-Date -format dd-MM-yyyy) + " " + (Get-Date -format HH:mm:ss)
        If ( $Text -eq "" ) {
            Add-Content $LogFile -value ("") # Write an empty line
        } Else {
            Add-Content $LogFile -value ($DateTime + " " + $InformationType.ToUpper() + " - " + $Text)
        }
    }
    End {
    }
}

# Disable progress bar while downloading
$ProgressPreference = 'SilentlyContinue'
$ErrorActionPreference = 'SilentlyContinue'

# Is there a newer NeverRed Script version?
# ========================================================================================================================================
$eVersion = "2.10.42"
$WebVersion = ""
[bool]$NewerVersion = $false
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$WebResponseVersion = Invoke-WebRequest -UseBasicParsing "https://raw.githubusercontent.com/Deyda/NeverRed/master/NeverRed.ps1"
If ($WebResponseVersion) {
    $WebVersion = (($WebResponseVersion.tostring() -split "[`r`n]" | select-string "Version:" | Select-Object -First 1) -split ":")[1].Trim()
}
If ($WebVersion -gt $eVersion) {
    $NewerVersion = $true
}

# Do you run the script as admin?
# ========================================================================================================================================
$myWindowsID=[System.Security.Principal.WindowsIdentity]::GetCurrent()
$myWindowsPrincipal=new-object System.Security.Principal.WindowsPrincipal($myWindowsID)
$adminRole=[System.Security.Principal.WindowsBuiltInRole]::Administrator

# Which PowerShell Version do u use?
# ========================================================================================================================================
$PowerShellVersion = $PSVersionTable.PSVersion
$PSVersion = $PowerShellVersion.Major

# Is there a pending reboot?
# ========================================================================================================================================
[bool]$PendingReboot = $false
#Check for Keys
If ((Test-Path -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") -eq $true) {
    $PendingReboot = $true
}
If ((Test-Path -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\PostRebootReporting") -eq $true) {
    $PendingReboot = $true
}
If ((Test-Path -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") -eq $true) {
    $PendingReboot = $true
}
If ((Test-Path -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") -eq $true) {
    $PendingReboot = $true
}
If ((Test-Path -Path "HKLM:\SOFTWARE\Microsoft\ServerManager\CurrentRebootAttempts") -eq $true) {
    $PendingReboot = $true
}
#Check for Values
If ((Test-RegistryValue -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing" -Value "RebootInProgress") -eq $true) {
    $PendingReboot = $true
}
If ((Test-RegistryValue -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Component Based Servicing" -Value "PackagesPending") -eq $true) {
    $PendingReboot = $true
}
If ((Test-RegistryValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Value "PendingFileRenameOperations") -eq $true) {
    $PendingReboot = $true
}
If ((Test-RegistryValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Value "PendingFileRenameOperations2") -eq $true) {
    $PendingReboot = $true
}
<#If ((Test-RegistryValue -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" -Value "DVDRebootSignal") -eq $true) {
    $PendingReboot = $true
}#>
If ((Test-RegistryValue -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon" -Value "JoinDomain") -eq $true) {
    $PendingReboot = $true
}
If ((Test-RegistryValue -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon" -Value "AvoidSpnSet") -eq $true) {
    $PendingReboot = $true
}

# GLobal Log
# ========================================================================================================================================
$GlobalLogDir = "$PSScriptRoot\_Global Logs"
If (!(Test-Path $GlobalLogDir)) { New-Item -Path $GlobalLogDir -ItemType directory | Out-Null }
$LogGlobal = "$PSScriptRoot\_Global Logs\GlobalLog - " + $env:computername + ".log"
Start-Transcript $LogGlobal | Out-Null

# Script Version
# ========================================================================================================================================
Write-Output ""
Write-Host -BackgroundColor DarkGreen -ForegroundColor Yellow "       NeverRed - Update your Software, the lazy way        "
Write-Host -BackgroundColor DarkGreen -ForegroundColor Yellow "      Manuel Winkel - Deyda Consulting (www.deyda.net)      "
Write-Host -BackgroundColor DarkGreen -ForegroundColor Yellow "                      Version $eVersion                       "
$host.ui.RawUI.WindowTitle ="NeverRed - Update your Software, the lazy way - Manuel Winkel (www.deyda.net) - Version $eVersion"

If (Test-Path "$PSScriptRoot\update.ps1" -PathType leaf) {
    Remove-Item -Path "$PSScriptRoot\Update.ps1" -Force
    Remove-Item -Path "$PSScriptRoot\Rename.ps1" -Force
} Else {
    If (!(Test-Path -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed")) {
        New-Item -Path "HKLM:\SOFTWARE\Deyda Consulting" -ErrorAction SilentlyContinue | Out-Null
        New-Item -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -ErrorAction SilentlyContinue | Out-Null
        New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
        New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
    }
    Else {
        If (!(Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Deyda Consulting\NeverRed" | Select-Object $_.Version).Version -ne "") {
            New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
        } Else {
            Set-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -ErrorAction SilentlyContinue | Out-Null
        }
        If (!(Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Deyda Consulting\NeverRed" | Select-Object $_.PSVersion).Version -ne "") {
            New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
        } Else {
            Set-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -ErrorAction SilentlyContinue | Out-Null
        }
    }
    If (((Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Deyda Consulting\NeverRed" | Select-Object $_.UpdateLanguage).UpdateLanguage -eq "1") -eq $true) {} else {
        New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name UpdateLanguage -Value 1 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
    }
}

If (Test-Path -Path "$PSScriptRoot\Evergreen.ps1") {
    Write-Host -Foregroundcolor Green "Renaming Evergreen.ps1 to NeverRed.ps1"
    Write-Output ""
    Write-Host -Foregroundcolor Green "Start NeverRed.ps1"
    Write-Output ""
    $rename = @'
                Rename-Item -Path "$PSScriptRoot\Evergreen.ps1" -NewName "NeverRed.ps1"
                & "$PSScriptRoot\NeverRed.ps1"
'@
            $rename > $PSScriptRoot\rename.ps1
            & "$PSScriptRoot\rename.ps1"
            Break
}

If (!($NoUpdate)) {
    Write-Output ""
    Write-Host -Foregroundcolor DarkGray "Is there a newer NeverRed version?"
    
    If ($NewerVersion -eq $false) {
        # No new version available
        Write-Host -Foregroundcolor Green "OK, NeverRed is newest version!"
        Write-Output ""

        # Change old LastSetting.txt files to the new format (AddScript)
        If (!(Test-Path -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed")) {
            New-Item -Path "HKLM:\SOFTWARE\Deyda Consulting" -ErrorAction SilentlyContinue | Out-Null
            New-Item -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -ErrorAction SilentlyContinue | Out-Null
            New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
            New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
        }
        Else {
            If (!(Get-ItemProperty -Path "Registry::HKEY_LOCAL_MACHINE\SOFTWARE\Deyda Consulting\NeverRed" | Select-Object $_.Version).Version -ne "") {
                New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
                New-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -PropertyType STRING -ErrorAction SilentlyContinue | Out-Null
            } Else {
                Set-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name Version -Value "$eVersion" -ErrorAction SilentlyContinue | Out-Null
                Set-ItemProperty -Path "HKLM:\SOFTWARE\Deyda Consulting\NeverRed" -Name PSVersion -Value "$PSVersion" -ErrorAction SilentlyContinue | Out-Null
            }
        }
    }
    Else {
        # There is a new Evergreen Script Version
        Write-Host -Foregroundcolor Red "Attention! There is a new version of NeverRed."
        Write-Output ""
        If ($ESfile) {
            $update = @'
                Remove-Item -Path "$PSScriptRoot\Evergreen.ps1" -Force
                Remove-Item -Path "$PSScriptRoot\NeverRed.ps1" -Force 
                Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/NeverRed.ps1 -OutFile ("$PSScriptRoot\" + "NeverRed.ps1")
                & "$PSScriptRoot\NeverRed.ps1" -ESfile $ESfile
'@
            $update > $PSScriptRoot\update.ps1
            & "$PSScriptRoot\update.ps1"
            Break
        }
        ElseIf ($GUIfile) {
            $update = @'
                Remove-Item -Path "$PSScriptRoot\Evergreen.ps1" -Force
                Remove-Item -Path "$PSScriptRoot\NeverRed.ps1" -Force
                Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/NeverRed.ps1 -OutFile ("$PSScriptRoot\" + "NeverRed.ps1")
                & "$PSScriptRoot\NeverRed.ps1" -GUIfile $GUIfile
'@
            $update > $PSScriptRoot\update.ps1
            & "$PSScriptRoot\update.ps1"
            Break
            
        }
        Else {
            $wshell = New-Object -ComObject Wscript.Shell
            $AnswerPending = $wshell.Popup("Do you want to download the new version?",0,"New Version Alert!",32+4)
            If ($AnswerPending -eq "6") {
                Start-Process "https://www.deyda.net/index.php/en/NeverRed/"
                $update = @'
                    Remove-Item -Path "$PSScriptRoot\Evergreen.ps1" -Force
                    Remove-Item -Path "$PSScriptRoot\NeverRed.ps1" -Force
                    Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/NeverRed.ps1 -OutFile ("$PSScriptRoot\" + "NeverRed.ps1")
                    & "$PSScriptRoot\NeverRed.ps1"
'@
                $update > $PSScriptRoot\update.ps1
                & "$PSScriptRoot\update.ps1"
                Break
            }
        }
    }
}

Write-Host -Foregroundcolor DarkGray "Does the script run under admin rights?"
If ($myWindowsPrincipal.IsInRole($adminRole)) {
    # OK, runs as admin
    Write-Host -Foregroundcolor Green "OK, script is running with admin rights."
    Write-Output ""

    If (!(Test-Path -Path "$PSScriptRoot\shortcut")) { New-Item -Path "$PSScriptRoot\shortcut" -ItemType Directory | Out-Null }
    If (!(Test-Path -Path "$PSScriptRoot\shortcut\NeverRed.ico")) {Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/shortcut/NeverRed.ico -OutFile ("$PSScriptRoot\shortcut\" + "NeverRed.ico")}
}
Else {
    # Script doesn't run as admin, stop!
    Write-Host -Foregroundcolor Red "Error! Script is NOT running with admin rights!"
    Break
}

Write-Host -Foregroundcolor DarkGray "Which PowerShell version is used??"
If ($PowerShellVersion.Major -lt "7") {
    # PowerShell Version < 7
    Write-Host -Foregroundcolor Green "PowerShell $PowerShellVersion is used."
    Write-Host -Foregroundcolor Yellow "PowerShell 7 is not used and therefore the download of ZoomVDI is unfortunately not possible."
    Write-Output ""
}
Else {
    # PowerShell Version > 7
    Write-Host -Foregroundcolor Green "PowerShell $PowerShellVersion is used."
    Write-Output ""
}

If ($ESfile -eq $False) {
    Write-Host -Foregroundcolor DarkGray "Are there still pending reboots?"
    If ($PendingReboot -eq $false) {
        # OK, no pending reboot
        Write-Host -Foregroundcolor Green "OK, no pending reboot"
        Write-Output ""
    }
    Else {
        # Oh Oh pending reboot, stop the script and reboot!
        Write-Host -Foregroundcolor Red "Error! Pending reboot! Reboot System!"
        Write-Output ""
        $wshell = New-Object -ComObject Wscript.Shell
        $AnswerPending = $wshell.Popup("Do you want to restart?",0,"Pending reboot alert!",32+4)
        If ($AnswerPending -eq "6") {
            Restart-Computer -Force
        }
        #Break
    }
}

# Function GUI
# ========================================================================================================================================

Function gui_mode {
#// MARK: XAML Code (AddScript)
$inputXML = @"
<Window x:Class="GUI.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GUI"
        mc:Ignorable="d"
        Title="NeverRed - Update your Software, the lazy way - Version $eVersion" Height="910" Width="1250"
        Icon="$PSScriptRoot\shortcut\NeverRed.ico"
        WindowStartupLocation="CenterScreen">
    <TabControl Grid.Column="1">
        <TabItem Header="General">
            <ScrollViewer ScrollViewer.VerticalScrollBarVisibility="Auto">
                <Grid x:Name="General_Grid" Margin="8,0,0,0" VerticalAlignment="Stretch">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="455" />
                        <ColumnDefinition Width="455"/>
                        <ColumnDefinition Width="300"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="60"/>
                        <RowDefinition Height="760"/>
                    </Grid.RowDefinitions>
                    <Image x:Name="Image_Logo" Height="100" Margin="0,3,25,0" HorizontalAlignment="Right" VerticalAlignment="Top" Width="100" Source="$PSScriptRoot\img\Logo_DEYDA.png" Grid.Column="2" Grid.Row="0" Grid.RowSpan="2" ToolTip="www.deyda.net"/>
                    <Label x:Name="Label_SelectMode" Content="Select Mode" HorizontalAlignment="Left" Margin="3,3,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_Download" Content="Download" HorizontalAlignment="Left" Margin="12,34,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_Install" Content="Install" HorizontalAlignment="Left" Margin="100,34,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="0"/>
                    <Label x:Name="Label_SelectLanguage" Content="Select Language" HorizontalAlignment="Left" Margin="2,3,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_Language" HorizontalAlignment="Left" Margin="17,30,0,0" VerticalAlignment="Top" SelectedIndex="6" ToolTip="If this is selectable at download!" Grid.Column="1" Grid.Row="0">
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <Label x:Name="Label_SelectArchitecture" Content="Select Architecture" HorizontalAlignment="Left" Margin="108,3,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0"/>
                    <ComboBox x:Name="Box_Architecture" HorizontalAlignment="Left" Margin="142,30,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" ToolTip="If this is selectable at download!" Grid.Row="0">
                        <ListBoxItem Content="x64"/>
                        <ListBoxItem Content="x86"/>
                    </ComboBox>
                    <Label x:Name="Label_SelectInstaller" Content="Select Installer Type" HorizontalAlignment="Left" Margin="222,3,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0"/>
                    <ComboBox x:Name="Box_Installer" HorizontalAlignment="Left" Margin="227,30,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" ToolTip="If this is different at install!" Grid.Row="0">
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <Label x:Name="Label_Explanation" Content="Selected globally, can be defined individually via Detail tab." HorizontalAlignment="Left" Margin="43,50,0,0" VerticalAlignment="Top" FontSize="10" Grid.RowSpan="2" Grid.Column="1"/>
                    <Label x:Name="Label_Software" Content="Select Software" HorizontalAlignment="Left" Margin="3,0,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_1Password" Content="1Password" HorizontalAlignment="Left" Margin="12,30,0,0" VerticalAlignment="Top" Grid.Column="0" ToolTip="No silent installation!" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_7Zip" Content="7 Zip" HorizontalAlignment="Left" Margin="12,50,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_AdobeProDC" Content="Adobe Pro DC" HorizontalAlignment="Left" Margin="12,70,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_AdobeReaderDC" Content="Adobe Reader DC" HorizontalAlignment="Left" Margin="12,90,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_AdoptOpenJDK" Content="Adopt Open JDK" HorizontalAlignment="Left" Margin="12,110,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_AdoptOpenJDK" HorizontalAlignment="Left" Margin="214,107,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="8 (LTS)"/>
                        <ListBoxItem Content="11 (LTS)"/>
                        <ListBoxItem Content="16 (Latest)"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_AdoptOpenJDKIcedTeaWeb" Content="Add Iced Tea Web" HorizontalAlignment="Left" Margin="325,110,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_AutodeskDWGTrueView" Content="Autodesk DWG TrueView" HorizontalAlignment="Left" Margin="12,130,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_BISF" Content="BIS-F" HorizontalAlignment="Left" Margin="12,150,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_BISF_Tools" HorizontalAlignment="Left" Margin="214,147,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="0" Grid.Row="1" ToolTip="Citrix Opimizer, SDelete and DelProf2">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="+ Additional Tools"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Bloomberg" Content="Bloomberg" HorizontalAlignment="Left" Margin="12,170,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_CiscoWebexTeams" Content="Cisco Webex Teams" HorizontalAlignment="Left" Margin="12,190,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_CiscoWebexTeams" HorizontalAlignment="Left" Margin="214,188,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="0" Grid.Row="1" ToolTip="Client VDI Plugin is for the client system!">
                        <ListBoxItem Content="Client"/>
                        <ListBoxItem Content="Client VDI Plugin"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_CitrixFiles" Content="Citrix Files" HorizontalAlignment="Left" Margin="12,210,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_CitrixHypervisorTools" Content="Citrix Hypervisor Tools" HorizontalAlignment="Left" Margin="12,230,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_CitrixWorkspaceApp" Content="Citrix Workspace App" HorizontalAlignment="Left" Margin="12,250,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_CitrixWorkspaceApp" HorizontalAlignment="Left" Margin="214,246,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Current Release"/>
                        <ListBoxItem Content="Long Term Service Release"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_ControlUpAgent" Content="ControlUp Agent" HorizontalAlignment="Left" Margin="12,270,0,0" VerticalAlignment="Top" Grid.Column="0" ToolTip="Authentication Key can be defined via Detail tab!" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_ControlUpConsole" Content="ControlUp Console" HorizontalAlignment="Left" Margin="12,290,0,0" VerticalAlignment="Top" Grid.Column="0" ToolTip="Only Download for Cloud Deployment!" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_ControlUpEdgeDX" Content="ControlUp Edge DX Agent Manager" HorizontalAlignment="Left" Margin="12,310,0,0" VerticalAlignment="Top" Grid.Column="0" ToolTip="Device Registration Code and Tenant Name can be defined via Detail tab!" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_ControlUpRemoteDX" Content="ControlUp Remote DX" HorizontalAlignment="Left" Margin="12,330,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_ControlUpRemoteDX" HorizontalAlignment="Left" Margin="214,326,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="for Citrix Workspace App"/>
                        <ListBoxItem Content="for Microsoft AVD and RDP"/>
                        <ListBoxItem Content="for VMware Horizon Client"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_deviceTRUST" Content="deviceTRUST" HorizontalAlignment="Left" Margin="12,350,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_deviceTRUST" HorizontalAlignment="Left" Margin="214,347,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Client"/>
                        <ListBoxItem Content="Agent"/>
                        <ListBoxItem Content="Console"/>
                        <ListBoxItem Content="Client + Agent"/>
                        <ListBoxItem Content="Agent + Console"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Ditto" Content="Ditto" HorizontalAlignment="Left" Margin="12,370,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Ditto" HorizontalAlignment="Left" Margin="214,368,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Beta"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Filezilla" Content="Filezilla" HorizontalAlignment="Left" Margin="12,390,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_FoxitPDFEditor" Content="Foxit PDF Editor" HorizontalAlignment="Left" Margin="12,410,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_FoxitReader" Content="Foxit Reader" HorizontalAlignment="Left" Margin="12,430,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_GIMP" Content="GIMP" HorizontalAlignment="Left" Margin="12,450,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_GitForWindows" Content="Git for Windows" HorizontalAlignment="Left" Margin="12,470,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_GoogleChrome" Content="Google Chrome" HorizontalAlignment="Left" Margin="12,490,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_GoogleChrome" HorizontalAlignment="Left" Margin="214,487,0,0" VerticalAlignment="Top" SelectedIndex="2" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Developer"/>
                        <ListBoxItem Content="Beta"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_GoogleDrive" Content="Google Drive" HorizontalAlignment="Left" Margin="12,510,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Greenshot" Content="Greenshot" HorizontalAlignment="Left" Margin="12,530,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_IISCrypto" Content="IIS Crypto" HorizontalAlignment="Left" Margin="12,550,0,0" VerticalAlignment="Top" Grid.Column="0" ToolTip="Only Download" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_ImageGlass" Content="ImageGlass" HorizontalAlignment="Left" Margin="12,570,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_IrfanView" Content="IrfanView" HorizontalAlignment="Left" Margin="12,590,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_JabraDirect" Content="Jabra Direct" HorizontalAlignment="Left" Margin="12,610,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_KeePass" Content="KeePass" HorizontalAlignment="Left" Margin="12,630,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_LogMeInGoToMeeting" Content="LogMeIn GoToMeeting" HorizontalAlignment="Left" Margin="12,650,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSDotNetFramework" Content="Microsoft .Net Framework" HorizontalAlignment="Left" Margin="12,670,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSDotNetFramework" HorizontalAlignment="Left" Margin="214,665,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Current"/>
                        <ListBoxItem Content="LTS (Long Term Support)"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MS365Apps" Content="Microsoft 365 Apps" HorizontalAlignment="Left" Margin="12,690,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MS365Apps" HorizontalAlignment="Left" Margin="214,686,0,0" VerticalAlignment="Top" SelectedIndex="4" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Beta Channel"/>
                        <ListBoxItem Content="Current Channel (Preview)"/>
                        <ListBoxItem Content="Current Channel"/>
                        <ListBoxItem Content="Semi-Annual Channel (Preview)"/>
                        <ListBoxItem Content="Monthly Enterprise Channel"/>
                        <ListBoxItem Content="Semi-Annual Channel"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSAVDRemoteDesktop" Content="Microsoft AVD Remote Desktop" HorizontalAlignment="Left" Margin="12,710,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSAVDRemoteDesktop" HorizontalAlignment="Left" Margin="214,707,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="0" Grid.Row="1">
                        <ListBoxItem Content="Insider"/>
                        <ListBoxItem Content="Public"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSAzureCLI" Content="Microsoft Azure CLI" HorizontalAlignment="Left" Margin="12,30,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSAzureDataStudio" Content="Microsoft Azure Data Studio" HorizontalAlignment="Left" Margin="12,50,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSAzureDataStudio" HorizontalAlignment="Left" Margin="214,45,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Insider"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSEdge" Content="Microsoft Edge" HorizontalAlignment="Left" Margin="12,70,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSEdge" HorizontalAlignment="Left" Margin="214,66,0,0" VerticalAlignment="Top" SelectedIndex="2" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Developer"/>
                        <ListBoxItem Content="Beta"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSEdgeWebView2" Content="Microsoft Edge WebView2" HorizontalAlignment="Left" Margin="12,90,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSFSlogix" Content="Microsoft FSLogix" HorizontalAlignment="Left" Margin="12,110,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSFSlogix" HorizontalAlignment="Left" Margin="214,105,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Preview"/>
                        <ListBoxItem Content="Production"/>
                        <ListBoxItem Content="Stable (Preferred by Deyda)"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSOffice" Content="Microsoft Office" HorizontalAlignment="Left" Margin="12,130,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSOffice" HorizontalAlignment="Left" Margin="214,126,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="2019"/>
                        <ListBoxItem Content="2021 LTSC"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSOneDrive" Content="Microsoft OneDrive" HorizontalAlignment="Left" Margin="12,150,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSOneDrive" HorizontalAlignment="Left" Margin="214,147,0,0" VerticalAlignment="Top" SelectedIndex="2" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Insider Ring"/>
                        <ListBoxItem Content="Production Ring"/>
                        <ListBoxItem Content="Enterprise Ring"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSPowerBIDesktop" Content="Microsoft Power BI Desktop" HorizontalAlignment="Left" Margin="12,170,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSPowerBIReportBuilder" Content="Microsoft Power BI Report Builder" HorizontalAlignment="Left" Margin="12,190,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSPowerShell" Content="Microsoft PowerShell" HorizontalAlignment="Left" Margin="12,210,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSPowerShell" HorizontalAlignment="Left" Margin="214,206,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Stable"/>
                        <ListBoxItem Content="LTS (Long Term Support)"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSPowerToys" Content="Microsoft PowerToys" HorizontalAlignment="Left" Margin="12,230,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSSQLServerManagementStudio" Content="Microsoft SQL Server Management Studio" Margin="12,250,0,0" VerticalAlignment="Top" Grid.Column="1" HorizontalAlignment="Left" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSSysinternals" Content="Microsoft Sysinternals" Margin="12,270,0,0" VerticalAlignment="Top" Grid.Column="1" HorizontalAlignment="Left" ToolTip="Only Download" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSTeams" Content="Microsoft Teams" HorizontalAlignment="Left" Margin="12,290,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSTeamsAVD" Content="for AVD" HorizontalAlignment="Left" Margin="148,290,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSTeams_No_AutoStart" Content="No AutoStart" HorizontalAlignment="Left" Margin="345,290,0,0" VerticalAlignment="Top" Grid.Column="1" ToolTip="Delete the HKLM Run entry to AutoStart Microsoft Teams" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSTeams" HorizontalAlignment="Left" Margin="214,285,0,0" VerticalAlignment="Top" SelectedIndex="3" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Continuous Ring"/>
                        <ListBoxItem Content="Exploration Ring"/>
                        <ListBoxItem Content="Preview Ring"/>
                        <ListBoxItem Content="General Ring"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSTeamsNew" Content="Microsoft Teams 2" HorizontalAlignment="Left" Margin="12,310,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSTeamsAVDNew" Content="for AVD" HorizontalAlignment="Left" Margin="148,310,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSVisualCPlusPlusRuntime" Content="Microsoft Visual C++ Runtime" HorizontalAlignment="Left" Margin="12,330,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSVisualCPlusPlusRuntime" HorizontalAlignment="Left" Margin="214,326,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="2012"/>
                        <ListBoxItem Content="2013"/>
                        <ListBoxItem Content="2022"/>
                        <ListBoxItem Content="All"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSVisualStudio" Content="Microsoft Visual Studio 2019" HorizontalAlignment="Left" Margin="12,350,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSVisualStudio" HorizontalAlignment="Left" Margin="214,347,0,0" VerticalAlignment="Top" SelectedIndex="2" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Enterprise Edition"/>
                        <ListBoxItem Content="Professional Edition"/>
                        <ListBoxItem Content="Community Edition"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSVisualStudioCode" Content="Microsoft Visual Studio Code" HorizontalAlignment="Left" Margin="12,370,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSVisualStudioCode" HorizontalAlignment="Left" Margin="214,368,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Insider"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MindView7" Content="MindView" HorizontalAlignment="Left" Margin="12,390,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MobaXterm" Content="MobaXterm" HorizontalAlignment="Left" Margin="12,410,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Firefox" Content="Mozilla Firefox" HorizontalAlignment="Left" Margin="12,430,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Firefox" HorizontalAlignment="Left" Margin="214,427,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Current"/>
                        <ListBoxItem Content="ESR"/>
                        <ListBoxItem Content="Developer"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MozillaThunderbird" Content="Mozilla Thunderbird" HorizontalAlignment="Left" Margin="12,450,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_mRemoteNG" Content="mRemoteNG" HorizontalAlignment="Left" Margin="12,470,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Nmap" Content="Nmap" HorizontalAlignment="Left" Margin="12,490,0,0" VerticalAlignment="Top" Grid.Column="1" ToolTip="No silent installation!" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_NotepadPlusPlus" Content="Notepad ++" HorizontalAlignment="Left" Margin="12,510,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_OpenJDK" Content="Open JDK (Outdated)" HorizontalAlignment="Left" Margin="12,530,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OpenJDK" HorizontalAlignment="Left" Margin="214,527,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="8"/>
                        <ListBoxItem Content="11"/>
                        <ListBoxItem Content="17"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OpenWebStart" Content="Open Web Start" HorizontalAlignment="Left" Margin="12,550,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_OpenShellMenu" Content="Open-Shell Menu" HorizontalAlignment="Left" Margin="12,570,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_OperaBrowser" Content="Opera Browser" HorizontalAlignment="Left" Margin="12,590,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OperaBrowser" HorizontalAlignment="Left" Margin="214,587,0,0" VerticalAlignment="Top" SelectedIndex="2" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Beta"/>
                        <ListBoxItem Content="Developer"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OracleJava8" Content="Oracle Java 8" HorizontalAlignment="Left" Margin="12,610,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_PaintDotNet" Content="Paint.Net" HorizontalAlignment="Left" Margin="12,630,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_PDF24Creator" Content="PDF24 Creator" HorizontalAlignment="Left" Margin="12,650,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_PDFForgeCreator" Content="pdfforge PDFCreator" HorizontalAlignment="Left" Margin="12,670,0,0" VerticalAlignment="Top" Grid.Column="1" ToolTip="No Silent Installation!" Grid.Row="1"/>
                    <ComboBox x:Name="Box_pdfforgePDFCreator" HorizontalAlignment="Left" Margin="214,667,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="Free"/>
                        <ListBoxItem Content="Professional"/>
                        <ListBoxItem Content="Terminal Server"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_PDFsam" Content="PDF Split and Merge" HorizontalAlignment="Left" Margin="12,690,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_PeaZip" Content="PeaZip" HorizontalAlignment="Left" Margin="12,710,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Putty" Content="PuTTY" HorizontalAlignment="Left" Margin="12,30,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Putty" HorizontalAlignment="Left" Margin="214,27,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="Pre-Release"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_RemoteDesktopManager" Content="Remote Desktop Manager" HorizontalAlignment="Left" Margin="12,50,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_RemoteDesktopManager" HorizontalAlignment="Left" Margin="214,48,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="Free"/>
                        <ListBoxItem Content="Enterprise"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_RDAnalyzer" Content="Remote Display Analyzer" HorizontalAlignment="Left" Margin="12,70,0,0" VerticalAlignment="Top" Grid.Column="2" ToolTip="Only Download" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Screenpresso" Content="Screenpresso" HorizontalAlignment="Left" Margin="12,90,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_ShareX" Content="ShareX" HorizontalAlignment="Left" Margin="12,110,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Slack" Content="Slack" HorizontalAlignment="Left" Margin="12,130,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_SumatraPDF" Content="Sumatra PDF" HorizontalAlignment="Left" Margin="12,150,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_TeamViewer" Content="TeamViewer" HorizontalAlignment="Left" Margin="12,170,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_TechSmithCamtasia" Content="TechSmith Camtasia" HorizontalAlignment="Left" Margin="12,190,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_TechSmithSnagIt" Content="TechSmith SnagIt" HorizontalAlignment="Left" Margin="12,210,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_TotalCommander" Content="Total Commander" HorizontalAlignment="Left" Margin="12,230,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_TreeSize" Content="TreeSize" HorizontalAlignment="Left" Margin="12,250,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_TreeSize" HorizontalAlignment="Left" Margin="214,247,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="Free"/>
                        <ListBoxItem Content="Professional"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_VLCPlayer" Content="VLC Player" HorizontalAlignment="Left" Margin="12,270,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_VMwareTools" Content="VMware Tools" HorizontalAlignment="Left" Margin="12,290,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_WinMerge" Content="WinMerge" HorizontalAlignment="Left" Margin="12,310,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_WinRAR" Content="WinRAR" HorizontalAlignment="Left" Margin="12,330,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_WinRAR" HorizontalAlignment="Left" Margin="214,327,0,0" VerticalAlignment="Top" SelectedIndex="1" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="Beta"/>
                        <ListBoxItem Content="Stable"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_WinSCP" Content="WinSCP" HorizontalAlignment="Left" Margin="12,350,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Wireshark" Content="Wireshark" HorizontalAlignment="Left" Margin="12,370,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_XCA" Content="XCA" HorizontalAlignment="Left" Margin="12,390,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_Zoom" Content="Zoom" HorizontalAlignment="Left" Margin="12,410,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Zoom" HorizontalAlignment="Left" Margin="214,407,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1" ToolTip="Citrix HDX Media Plugin is for the client system!">
                        <ListBoxItem Content="Client"/>
                        <ListBoxItem Content="Citrix HDX Media Plugin"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_SelectAll" Content="Select All" HorizontalAlignment="Left" Margin="12,0,0,120" VerticalAlignment="Bottom" Grid.Column="2" Grid.Row="1"/>
                    <Button x:Name="Button_Start" Content="Start" Margin="0,0,218,40" VerticalAlignment="Bottom" HorizontalAlignment="Right" Width="75" Grid.Column="2" Grid.Row="1"/>
                    <Button x:Name="Button_Cancel" Content="Cancel" Margin="0,0,128,40" VerticalAlignment="Bottom" HorizontalAlignment="Right" Width="75" Grid.Column="2" Grid.Row="1"/>
                    <Button x:Name="Button_Save" Content="Save" Margin="0,0,38,40" VerticalAlignment="Bottom" HorizontalAlignment="Right" Width="75" Grid.Column="2" ToolTip="Save Selected Software in LastSetting.txt or -GUIFile Parameter file" Grid.Row="1"/>
                    <Label x:Name="Label_author" Content="Manuel Winkel / @deyda84 / Deyda Consulting / www.deyda.net / 2024 / Version $eVersion" HorizontalAlignment="Right" Margin="0,0,8,-20" VerticalAlignment="Bottom" FontSize="10" Grid.Column="1" Grid.Row="1" Grid.ColumnSpan="2"/>
                </Grid>
            </ScrollViewer>
        </TabItem>
        <TabItem Header="Detail">
            <ScrollViewer ScrollViewer.VerticalScrollBarVisibility="Auto">
                <Grid x:Name="Detail_Grid" Margin="8,0,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="23"/>
                        <ColumnDefinition Width="380"/>
                        <ColumnDefinition Width="403"/>
                        <ColumnDefinition Width="404"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="60"/>
                        <RowDefinition Height="780"/>
                    </Grid.RowDefinitions>
                    <Image x:Name="Image_Logo_Detail" Height="100" Margin="0,3,25,0" HorizontalAlignment="Right" VerticalAlignment="Top" Width="100" Source="$PSScriptRoot\img\Logo_DEYDA.png" Grid.Column="3" Grid.Row="0" Grid.RowSpan="2" ToolTip="www.deyda.net"/>
                    <Label x:Name="Label_OptionalMode" Content="Optional Mode" HorizontalAlignment="Left" Margin="3,3,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="0" Grid.ColumnSpan="2"/>
                    <CheckBox x:Name="Checkbox_WhatIf" Content="WhatIf" HorizontalAlignment="Left" Margin="12,34,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="0" Grid.ColumnSpan="2"/>
                    <CheckBox x:Name="Checkbox_Repository" Content="Installer Repository" HorizontalAlignment="Left" Margin="53,34,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_CleanUp" Content="Installer CleanUp" HorizontalAlignment="Left" Margin="182,34,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_CleanUpStartMenu" Content="Start Menu CleanUp" HorizontalAlignment="Left" Margin="299,34,0,0" VerticalAlignment="Top" Grid.Column="1" Grid.Row="0" Grid.ColumnSpan="2"/>
                    <CheckBox x:Name="Checkbox_Report" Content="Report Mode" HorizontalAlignment="Left" Margin="54,34,0,0" VerticalAlignment="Top" Grid.Column="2" ToolTip="Only report generation, no download or install." Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_NoDesktopIcon" Content="Disable NeverRed Icon" HorizontalAlignment="Left" Margin="152,34,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="0"/>
                    <CheckBox x:Name="Checkbox_WindowsUpdate" Content="Install Windows Update" HorizontalAlignment="Left" Margin="299,34,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="0" Grid.ColumnSpan="2"/>
                    <Label x:Name="Label_Software_Detail" Content="Select Software" HorizontalAlignment="Left" Margin="3,0,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <Label x:Name="Label_Architecture_Detail" Content="Architecture" HorizontalAlignment="Left" Margin="177,0,0,0" VerticalAlignment="Top" FontSize="10" Grid.Row="1" Grid.Column="1"/>
                    <Label x:Name="Label_Language_Detail" Content="Language" HorizontalAlignment="Left" Margin="249,0,0,0" VerticalAlignment="Top" Grid.Column="1" FontSize="10" Grid.Row="1"/>
                    <Label x:Name="Label_InstallerType_Detail" Content="Installer Type" HorizontalAlignment="Left" Margin="311,0,0,0" VerticalAlignment="Top" Grid.Column="1" Width="75" FontSize="10" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <CheckBox x:Name="Checkbox_7Zip_Detail" Content="7 Zip" HorizontalAlignment="Left" Margin="12,30,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_7Zip_Architecture" HorizontalAlignment="Left" Margin="194,27,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Row="1" Grid.Column="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_AdobeProDC_Detail" Content="Adobe Pro DC" HorizontalAlignment="Left" Margin="12,55,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_AdobeProDC_Architecture" HorizontalAlignment="Left" Margin="194,52,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_AdobeReaderDC_Detail" Content="Adobe Reader DC" HorizontalAlignment="Left" Margin="12,80,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_AdobeReaderDC_Architecture" HorizontalAlignment="Left" Margin="194,77,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_AdobeReaderDC_Language" HorizontalAlignment="Left" Margin="260,77,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Chinese (Simplified)"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                        <ListBoxItem Content="MUI"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_AdoptOpenJDK_Detail" Content="Adopt Open JDK" HorizontalAlignment="Left" Margin="12,105,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_AdoptOpenJDK_Architecture" HorizontalAlignment="Left" Margin="194,102,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_CiscoWebexTeams_Detail" Content="Cisco Webex Teams" HorizontalAlignment="Left" Margin="12,130,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_CiscoWebexTeams_Architecture" HorizontalAlignment="Left" Margin="194,127,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_CitrixHypervisorTools_Detail" Content="Citrix Hypervisor Tools" HorizontalAlignment="Left" Margin="12,155,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_CitrixHypervisorTools_Architecture" HorizontalAlignment="Left" Margin="194,152,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_ControlUpAgent_Detail" Content="ControlUp Agent" HorizontalAlignment="Left" Margin="12,180,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_ControlUpAgent_Architecture" HorizontalAlignment="Left" Margin="194,177,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_ControlUpEdgeDX_Detail" Content="ControlUp Edge DX Agent Manager" HorizontalAlignment="Left" Margin="12,205,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_ControlUpEdgeDX_Installer" HorizontalAlignment="Left" Margin="330,202,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="FatClient"/>
                        <ListBoxItem Content="VDI"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_deviceTRUST_Detail" Content="deviceTRUST" HorizontalAlignment="Left" Margin="12,230,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_deviceTRUST_Architecture" HorizontalAlignment="Left" Margin="194,227,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Ditto_Detail" Content="Ditto" HorizontalAlignment="Left" Margin="12,255,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_Ditto_Architecture" HorizontalAlignment="Left" Margin="194,252,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_FoxitPDFEditor_Detail" Content="Foxit PDF Editor" HorizontalAlignment="Left" Margin="12,280,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_FoxitPDFEditor_Language" HorizontalAlignment="Left" Margin="260,277,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_FoxitReader_Detail" Content="Foxit Reader" HorizontalAlignment="Left" Margin="12,305,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_FoxitReader_Language" HorizontalAlignment="Left" Margin="260,302,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_GitForWindows_Detail" Content="Git for Windows" HorizontalAlignment="Left" Margin="12,330,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_GitForWindows_Architecture" HorizontalAlignment="Left" Margin="194,327,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_GoogleChrome_Detail" Content="Google Chrome" HorizontalAlignment="Left" Margin="12,355,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_GoogleChrome_Architecture" HorizontalAlignment="Left" Margin="194,352,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_ImageGlass_Detail" Content="ImageGlass" HorizontalAlignment="Left" Margin="12,380,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_ImageGlass_Architecture" HorizontalAlignment="Left" Margin="194,377,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_IrfanView_Detail" Content="IrfanView" HorizontalAlignment="Left" Margin="12,405,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_IrfanView_Architecture" HorizontalAlignment="Left" Margin="194,402,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_IrfanView_Language" HorizontalAlignment="Left" Margin="260,402,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_KeePass_Detail" Content="KeePass" HorizontalAlignment="Left" Margin="12,430,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_KeePass_Language" HorizontalAlignment="Left" Margin="260,427,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_LogMeInGoToMeeting_Detail" Content="LogMeIn GoToMeeting" HorizontalAlignment="Left" Margin="12,455,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_LogMeInGoToMeeting_Installer" HorizontalAlignment="Left" Margin="330,452,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="XenApp"/>
                        <ListBoxItem Content="FatClient"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSDotNetFramework_Detail" Content="Microsoft .Net Framework" HorizontalAlignment="Left" Margin="12,480,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSDotNetFramework_Architecture" HorizontalAlignment="Left" Margin="194,477,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MS365Apps_Detail" Content="Microsoft 365 Apps" HorizontalAlignment="Left" Margin="12,505,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MS365Apps_Architecture" HorizontalAlignment="Left" Margin="194,502,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MS365Apps_Language" HorizontalAlignment="Left" Margin="260,502,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MS365Apps_Installer" HorizontalAlignment="Left" Margin="330,502,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MS365Apps_Visio_Detail" Content="     + Microsoft Visio" HorizontalAlignment="Left" Margin="12,530,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MS365Apps_Visio_Language" HorizontalAlignment="Left" Margin="260,527,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MS365Apps_Project_Detail" Content="     + Microsoft Project" HorizontalAlignment="Left" Margin="12,555,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MS365Apps_Project_Language" HorizontalAlignment="Left" Margin="260,552,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSAVDRemoteDesktop_Detail" Content="Microsoft AVD Remote Desktop" HorizontalAlignment="Left" Margin="12,580,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSAVDRemoteDesktop_Architecture" HorizontalAlignment="Left" Margin="194,577,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSAzureDataStudio_Detail" Content="Microsoft Azure Data Studio" HorizontalAlignment="Left" Margin="12,605,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSAzureDataStudio_Architecture" HorizontalAlignment="Left" Margin="194,602,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MSAzureDataStudio_Installer" HorizontalAlignment="Left" Margin="330,602,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSEdge_Detail" Content="Microsoft Edge" HorizontalAlignment="Left" Margin="12,630,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSEdge_Architecture" HorizontalAlignment="Left" Margin="194,627,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSEdgeWebView2_Detail" Content="Microsoft Edge WebView2" HorizontalAlignment="Left" Margin="12,655,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSEdgeWebView2_Architecture" HorizontalAlignment="Left" Margin="194,652,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSFSLogix_Detail" Content="Microsoft FSLogix" HorizontalAlignment="Left" Margin="12,680,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSFSLogix_Architecture" HorizontalAlignment="Left" Margin="194,677,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSOffice_Detail" Content="Microsoft Office" HorizontalAlignment="Left" Margin="12,705,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSOffice_Architecture" HorizontalAlignment="Left" Margin="194,702,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MSOffice_Language" HorizontalAlignment="Left" Margin="260,702,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSOffice_Visio_Detail" Content="     + Microsoft Visio" HorizontalAlignment="Left" Margin="12,730,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSOffice_Visio_Language" HorizontalAlignment="Left" Margin="260,727,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSOffice_Project_Detail" Content="     + Microsoft Project" HorizontalAlignment="Left" Margin="12,755,0,0" VerticalAlignment="Top" Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2"/>
                    <ComboBox x:Name="Box_MSOffice_Project_Language" HorizontalAlignment="Left" Margin="260,752,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="1" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <Label x:Name="Label_Architecture2_Detail" Content="Architecture" HorizontalAlignment="Left" Margin="200,0,0,0" VerticalAlignment="Top" Grid.Column="2" FontSize="10" Grid.Row="1"/>
                    <Label x:Name="Label_Language2_Detail" Content="Language" HorizontalAlignment="Left" Margin="272,0,0,0" VerticalAlignment="Top" Grid.Column="2" FontSize="10" Grid.Row="1"/>
                    <Label x:Name="Label_InstallerType2_Detail" Content="Installer Type" HorizontalAlignment="Left" Margin="334,0,0,0" VerticalAlignment="Top" Grid.Column="2" FontSize="10" Grid.Row="1"/>
                    <CheckBox x:Name="Checkbox_MSOneDrive_Detail" Content="Microsoft OneDrive" HorizontalAlignment="Left" Margin="12,30,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSOneDrive_Architecture" HorizontalAlignment="Left" Margin="217,27,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MSOneDrive_Installer" HorizontalAlignment="Left" Margin="353,27,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSPowerBIDesktop_Detail" Content="Microsoft Power BI Desktop" HorizontalAlignment="Left" Margin="12,55,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSPowerBIDesktop_Architecture" HorizontalAlignment="Left" Margin="217,52,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSPowerShell_Detail" Content="Microsoft PowerShell" HorizontalAlignment="Left" Margin="12,80,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSPowerShell_Architecture" HorizontalAlignment="Left" Margin="217,77,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSSQLServerManagementStudio_Detail" Content="Microsoft SQL Server Management Studio" Margin="12,105,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSSQLServerManagementStudio_Language" HorizontalAlignment="Left" Margin="283,102,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Spanish"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSTeams_Detail" Content="Microsoft Teams" HorizontalAlignment="Left" Margin="12,130,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSTeams_Architecture" HorizontalAlignment="Left" Margin="217,127,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MSTeams_Installer" HorizontalAlignment="Left" Margin="353,127,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSTeamsNew_Detail" Content="Microsoft Teams 2" HorizontalAlignment="Left" Margin="12,155,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSTeamsNew_Architecture" HorizontalAlignment="Left" Margin="217,152,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSVisualCPlusPlusRuntime_Detail" Content="Microsoft Visual C++ Runtime" HorizontalAlignment="Left" Margin="12,180,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSVisualCPlusPlusRuntime_Architecture" HorizontalAlignment="Left" Margin="217,177,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                        <ListBoxItem Content="x86 and x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MSVisualStudioCode_Detail" Content="Microsoft Visual Studio Code" HorizontalAlignment="Left" Margin="12,205,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MSVisualStudioCode_Architecture" HorizontalAlignment="Left" Margin="217,202,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MSVisualStudioCode_Installer" HorizontalAlignment="Left" Margin="353,202,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MindView7_Detail" Content="MindView" HorizontalAlignment="Left" Margin="12,230,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MindView7_Language" HorizontalAlignment="Left" Margin="283,227,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Firefox_Detail" Content="Mozilla Firefox" HorizontalAlignment="Left" Margin="12,255,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Firefox_Architecture" HorizontalAlignment="Left" Margin="217,252,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_Firefox_Language" HorizontalAlignment="Left" Margin="283,252,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_MozillaThunderbird_Detail" Content="Mozilla Thunderbird" HorizontalAlignment="Left" Margin="12,280,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_MozillaThunderbird_Architecture" HorizontalAlignment="Left" Margin="217,277,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_MozillaThunderbird_Language" HorizontalAlignment="Left" Margin="283,277,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_NotepadPlusPlus_Detail" Content="Notepad ++" HorizontalAlignment="Left" Margin="12,305,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_NotepadPlusPlus_Architecture" HorizontalAlignment="Left" Margin="217,302,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OpenJDK_Detail" Content="Open JDK (Outdated)" HorizontalAlignment="Left" Margin="12,330,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OpenJDK_Architecture" HorizontalAlignment="Left" Margin="217,327,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                        <ListBoxItem Content="x86 and x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OpenWebStart_Detail" Content="Open Web Start" HorizontalAlignment="Left" Margin="12,355,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OpenWebStart_Architecture" HorizontalAlignment="Left" Margin="217,352,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OperaBrowser_Detail" Content="Opera Browser" HorizontalAlignment="Left" Margin="12,380,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OperaBrowser_Architecture" HorizontalAlignment="Left" Margin="217,377,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_OracleJava8_Detail" Content="Oracle Java 8" HorizontalAlignment="Left" Margin="12,405,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_OracleJava8_Architecture" HorizontalAlignment="Left" Margin="217,402,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                        <ListBoxItem Content="x86 and x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_PaintDotNet_Detail" Content="Paint.Net" HorizontalAlignment="Left" Margin="12,430,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_PaintDotNet_Architecture" HorizontalAlignment="Left" Margin="217,427,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_PeaZip_Detail" Content="PeaZip" HorizontalAlignment="Left" Margin="12,455,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_PeaZip_Architecture" HorizontalAlignment="Left" Margin="217,452,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Putty_Detail" Content="PuTTY" HorizontalAlignment="Left" Margin="12,480,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Putty_Architecture" HorizontalAlignment="Left" Margin="217,477,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Slack_Detail" Content="Slack" HorizontalAlignment="Left" Margin="12,505,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Slack_Architecture" HorizontalAlignment="Left" Margin="217,502,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_Slack_Installer" HorizontalAlignment="Left" Margin="353,502,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Machine Based"/>
                        <ListBoxItem Content="User Based"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_SumatraPDF_Detail" Content="Sumatra PDF" HorizontalAlignment="Left" Margin="12,530,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_SumatraPDF_Architecture" HorizontalAlignment="Left" Margin="217,527,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_TeamViewer_Detail" Content="TeamViewer" HorizontalAlignment="Left" Margin="12,555,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_TeamViewer_Architecture" HorizontalAlignment="Left" Margin="217,552,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_TechSmithSnagIt_Detail" Content="TechSmith SnagIt" HorizontalAlignment="Left" Margin="12,580,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_TechSmithSnagIt_Architecture" HorizontalAlignment="Left" Margin="217,552,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_TotalCommander_Detail" Content="Total Commander" HorizontalAlignment="Left" Margin="12,605,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_TotalCommander_Architecture" HorizontalAlignment="Left" Margin="217,602,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_VLCPlayer_Detail" Content="VLC Player" HorizontalAlignment="Left" Margin="12,630,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_VLCPlayer_Architecture" HorizontalAlignment="Left" Margin="217,627,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_VMwareTools_Detail" Content="VMware Tools" HorizontalAlignment="Left" Margin="12,655,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_VMwareTools_Architecture" HorizontalAlignment="Left" Margin="217,652,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_WinMerge_Detail" Content="WinMerge" HorizontalAlignment="Left" Margin="12,680,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_WinMerge_Architecture" HorizontalAlignment="Left" Margin="217,677,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_WinRAR_Detail" Content="WinRAR" HorizontalAlignment="Left" Margin="12,705,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_WinRAR_Architecture" HorizontalAlignment="Left" Margin="217,702,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_WinRAR_Language" HorizontalAlignment="Left" Margin="283,702,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="Arabic"/>
                        <ListBoxItem Content="Chinese"/>
                        <ListBoxItem Content="Croatian"/>
                        <ListBoxItem Content="Czech"/>
                        <ListBoxItem Content="Danish"/>
                        <ListBoxItem Content="Dutch"/>
                        <ListBoxItem Content="English"/>
                        <ListBoxItem Content="Finnish"/>
                        <ListBoxItem Content="French"/>
                        <ListBoxItem Content="German"/>
                        <ListBoxItem Content="Hebrew"/>
                        <ListBoxItem Content="Hungarian"/>
                        <ListBoxItem Content="Italian"/>
                        <ListBoxItem Content="Japanese"/>
                        <ListBoxItem Content="Korean"/>
                        <ListBoxItem Content="Norwegian"/>
                        <ListBoxItem Content="Polish"/>
                        <ListBoxItem Content="Portuguese"/>
                        <ListBoxItem Content="Romanian"/>
                        <ListBoxItem Content="Russian"/>
                        <ListBoxItem Content="Slovak"/>
                        <ListBoxItem Content="Slovenian"/>
                        <ListBoxItem Content="Spanish"/>
                        <ListBoxItem Content="Swedish"/>
                        <ListBoxItem Content="Turkish"/>
                        <ListBoxItem Content="Ukrainian"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Wireshark_Detail" Content="Wireshark" HorizontalAlignment="Left" Margin="12,730,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Wireshark_Architecture" HorizontalAlignment="Left" Margin="217,727,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <CheckBox x:Name="Checkbox_Zoom_Detail" Content="Zoom" HorizontalAlignment="Left" Margin="12,755,0,0" VerticalAlignment="Top" Grid.Column="2" Grid.Row="1"/>
                    <ComboBox x:Name="Box_Zoom_Architecture" HorizontalAlignment="Left" Margin="217,752,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="x86"/>
                        <ListBoxItem Content="x64"/>
                    </ComboBox>
                    <ComboBox x:Name="Box_Zoom_Installer" HorizontalAlignment="Left" Margin="353,752,0,0" VerticalAlignment="Top" SelectedIndex="0" Grid.Column="2" Grid.Row="1">
                        <ListBoxItem Content="-"/>
                        <ListBoxItem Content="VDI"/>
                        <ListBoxItem Content="Full Client"/>
                    </ComboBox>
                    <Label x:Name="Label_ControlUpAgentAuthKey" Content="ControlUp Agent Authentication Key" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="9,50,0,0" VerticalAlignment="Top" Grid.Column="3" Grid.Row="1" Width="376"/>
                    <TextBox Name="TextBox_ControlUpAgentAuthKey" HorizontalAlignment="Left" Height="40" Margin="8,76,0,0" TextWrapping="Wrap" Text="" VerticalContentAlignment="Center" VerticalAlignment="Top" Width="377" Grid.Column="3" Grid.Row="1"/>
                    <Label x:Name="Label_ControlUpAgentAuthKey_Text" Content="In the ControlUp Console under Settings > Agent > Agents Authentication Keys" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="10,116,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="375"/>
                    <Label x:Name="Label_ControlUpEdgeDXDevRegCode" Content="ControlUp Edge DX Device Registration Code" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="9,141,0,0" VerticalAlignment="Top" Grid.Column="3" Grid.Row="1" Width="376"/>
                    <TextBox Name="TextBox_ControlUpEdgeDXDevRegCode" HorizontalAlignment="Left" Height="40" Margin="8,167,0,0" TextWrapping="Wrap" Text="" VerticalContentAlignment="Center" VerticalAlignment="Top" Width="377" Grid.Column="3" Grid.Row="1"/>
                    <Label x:Name="Label_ControlUpEdgeDXDevRegCode_Text" Content="In Solve under Edge DX Click on Configuration > Downloads >" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="10,206,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="375"/>
                    <Label x:Name="Label_ControlUpEdgeDXDevRegCode_Text2" Content="Device Registration Code" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="10,218,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="375"/>
                    <Label x:Name="Label_ControlUpEdgeDXTenant" Content="ControlUp Edge DX Tenant Name" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="9,243,0,0" VerticalAlignment="Top" Grid.Column="3" Grid.Row="1" Width="376"/>
                    <TextBox Name="TextBox_ControlUpEdgeDXTenantName" HorizontalAlignment="Left" Height="40" Margin="8,270,0,0" TextWrapping="Wrap" Text="" VerticalContentAlignment="Center" VerticalAlignment="Top" Width="377" Grid.Column="3" Grid.Row="1"/>
                    <Label x:Name="Label_ControlUpEdgeDXTenant_Text" Content="In Solve under Edge DX Click on Configuration > Downloads > Tenant Name" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="10,309,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="375"/>
                    <Label x:Name="Label_MS365Apps_XML" Content="Custom Microsoft 365 Apps or Microsoft Office XML File" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="6,351,0,0" VerticalAlignment="Top" Grid.Column="3" Grid.Row="1" Width="379"/>
                    <TextBox Name="TextBox_FileName" HorizontalAlignment="Left" Height="40" Margin="5,377,0,0" TextWrapping="Wrap" Text="" VerticalContentAlignment="Center" VerticalAlignment="Top" Width="380" Grid.Column="3" Grid.Row="1"/>
                    <Label x:Name="Label_MS365Apps_Text" Content="When a custom file is uploaded, the settings for" HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="6,415,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="289"/>
                    <Label x:Name="Label_MS365Apps_Text2" Content="the XML made in the GUI will be overwritten." HorizontalContentAlignment="Center" HorizontalAlignment="Left" Margin="6,427,0,0" Grid.Row="1" VerticalAlignment="Top" Grid.Column="3" FontSize="10" Width="289"/>
                    <Button x:Name="Button_Browse" Content="Browse" HorizontalAlignment="Left" Margin="295,427,0,0" VerticalAlignment="Top" Width="90" Height="26" Grid.Column="3" Grid.Row="1"/>
                    <Button x:Name="Button_Start_Detail" Content="Start" HorizontalAlignment="Right" Margin="0,0,218,40" VerticalAlignment="Bottom" Width="75" Grid.Column="3" Grid.Row="1"/>
                    <Button x:Name="Button_Cancel_Detail" Content="Cancel" HorizontalAlignment="Right" Margin="0,0,128,40" VerticalAlignment="Bottom" Width="75" Grid.Column="3" Grid.Row="1"/>
                    <Button x:Name="Button_Save_Detail" Content="Save" HorizontalAlignment="Right" Margin="0,0,38,40" VerticalAlignment="Bottom" Width="75" Grid.Column="3" ToolTip="Save Selected Software in LastSetting.txt or -GUIFile Parameter file" Grid.Row="1"/>
                    <Label x:Name="Label_author_Detail" Content="Manuel Winkel / @deyda84 / Deyda Consulting / www.deyda.net / 2024 / Version $eVersion" HorizontalAlignment="Right" Margin="0,0,8,0" VerticalAlignment="Bottom" FontSize="10" Grid.Column="2" Grid.Row="1" Grid.ColumnSpan="2"/>
                </Grid>
            </ScrollViewer>
        </TabItem>
    </TabControl>
</Window>
"@

    #Correction XAML
    $inputXML = $inputXML -replace 'mc:Ignorable="d"','' -replace "x:N",'N' -replace 'x:Class=".*?"','' -replace 'd:DesignHeight="\d*?"','' -replace 'd:DesignWidth="\d*?"',''
    [void][System.Reflection.Assembly]::LoadWithPartialName('presentationframework')
    [xml]$XAML = $inputXML

    #Read XAML
    $reader=(New-Object System.Xml.XmlNodeReader $xaml)
    Try {
        $Form=[Windows.Markup.XamlReader]::Load( $reader )
    }
    Catch {
        Write-Warning "Unable to parse XML, with error: $($Error[0])`n Ensure that there are NO SelectionChanged or TextChanged properties in your textboxes (PowerShell cannot process them)"
        Throw
    }

    # Load XAML Objects In PowerShell  
    $xaml.SelectNodes("//*[@Name]") | ForEach-Object{"trying item $($_.Name)";
        Try {Set-Variable -Name "WPF$($_.Name)" -Value $Form.FindName($_.Name) -ErrorAction Stop}
        Catch {Throw}
    } | out-null

    # Read LastSetting.txt or -GUIFile Parameter file to get the settings of the last session. (AddScript)
    If (!$GUIfile) {$GUIfile = "LastSetting.txt"}
    If (Test-Path "$PSScriptRoot\$GUIfile" -PathType leaf) {
        $LastSetting = Get-Content "$PSScriptRoot\$GUIfile"
        $WPFBox_Language.SelectedIndex = $LastSetting[0] -as [int]
        $WPFBox_Architecture.SelectedIndex = $LastSetting[1] -as [int]
        $WPFBox_CitrixWorkspaceApp.SelectedIndex = $LastSetting[2] -as [int]
        $WPFBox_MS365Apps.SelectedIndex = $LastSetting[3] -as [int]
        $WPFBox_MSOneDrive.SelectedIndex = $LastSetting[4] -as [int]
        $WPFBox_MSTeams.SelectedIndex = $LastSetting[5] -as [int]
        $WPFBox_Firefox.SelectedIndex = $LastSetting[6] -as [int]
        $WPFBox_TreeSize.SelectedIndex = $LastSetting[7] -as [int]
        $WPFBox_MSDotNetFramework.SelectedIndex = $LastSetting[40] -as [int]
        $WPFBox_MSPowerShell.SelectedIndex = $LastSetting[42] -as [int]
        $WPFBox_RemoteDesktopManager.SelectedIndex = $LastSetting[44] -as [int]
        $WPFBox_Zoom.SelectedIndex = $LastSetting[49] -as [int]
        $WPFBox_deviceTRUST.SelectedIndex = $LastSetting[50] -as [int]
        $WPFBox_MSEdge.SelectedIndex = $LastSetting[51] -as [int]
        $WPFBox_MSVisualStudioCode.SelectedIndex = $LastSetting[56] -as [int]
        $WPFBox_Installer.SelectedIndex = $LastSetting[60] -as [int]
        $WPFBox_MSVisualStudio.SelectedIndex = $LastSetting[61] -as [int]
        $WPFBox_Putty.SelectedIndex = $LastSetting[62] -as [int]
        $WPFBox_MSAzureDataStudio.SelectedIndex = $LastSetting[64] -as [int]
        $WPFBox_MSFSLogix.SelectedIndex = $LastSetting[66] -as [int]
        $WPFBox_OperaBrowser.SelectedIndex = $LastSetting[71] -as [int]
        $WPFBox_MSAVDRemoteDesktop.SelectedIndex = $LastSetting[75] -as [int]
        $WPFBox_7Zip_Architecture.SelectedIndex = $LastSetting[93] -as [int]
        $WPFBox_AdobeReaderDC_Architecture.SelectedIndex = $LastSetting[94] -as [int]
        $WPFBox_AdobeReaderDC_Language.SelectedIndex = $LastSetting[95] -as [int]
        $WPFBox_CiscoWebexTeams_Architecture.SelectedIndex = $LastSetting[96] -as [int]
        $WPFBox_CitrixHypervisorTools_Architecture.SelectedIndex = $LastSetting[97] -as [int]
        $WPFBox_ControlUpAgent_Architecture.SelectedIndex = $LastSetting[98] -as [int]
        $WPFBox_deviceTRUST_Architecture.SelectedIndex = $LastSetting[99] -as [int]
        $WPFBox_FoxitPDFEditor_Language.SelectedIndex = $LastSetting[100] -as [int]
        $WPFBox_FoxitReader_Language.SelectedIndex = $LastSetting[101] -as [int]
        $WPFBox_GitForWindows_Architecture.SelectedIndex = $LastSetting[102] -as [int]
        $WPFBox_GoogleChrome_Architecture.SelectedIndex = $LastSetting[103] -as [int]
        $WPFBox_ImageGlass_Architecture.SelectedIndex = $LastSetting[104] -as [int]
        $WPFBox_IrfanView_Architecture.SelectedIndex = $LastSetting[105] -as [int]
        $WPFBox_KeePass_Language.SelectedIndex = $LastSetting[106] -as [int]
        $WPFBox_MSDotNetFramework_Architecture.SelectedIndex = $LastSetting[107] -as [int]
        $WPFBox_MS365Apps_Architecture.SelectedIndex = $LastSetting[108] -as [int]
        $WPFBox_MS365Apps_Language.SelectedIndex = $LastSetting[109] -as [int]
        $WPFBox_MS365Apps_Visio_Language.SelectedIndex = $LastSetting[111] -as [int]
        $WPFBox_MS365Apps_Project_Language.SelectedIndex = $LastSetting[113] -as [int]
        $WPFBox_MSAVDRemoteDesktop_Architecture.SelectedIndex = $LastSetting[114] -as [int]
        $WPFBox_MSEdge_Architecture.SelectedIndex = $LastSetting[115] -as [int]
        $WPFBox_MSFSLogix_Architecture.SelectedIndex = $LastSetting[116] -as [int]
        $WPFBox_MSOffice_Architecture.SelectedIndex = $LastSetting[117] -as [int]
        $WPFBox_MSOneDrive_Architecture.SelectedIndex = $LastSetting[118] -as [int]
        $WPFBox_MSPowerBIDesktop_Architecture.SelectedIndex = $LastSetting[119] -as [int]
        $WPFBox_MSPowerShell_Architecture.SelectedIndex = $LastSetting[120] -as [int]
        $WPFBox_MSSQLServerManagementStudio_Language.SelectedIndex = $LastSetting[121] -as [int]
        $WPFBox_MSTeams_Architecture.SelectedIndex = $LastSetting[122] -as [int]
        $WPFBox_MSVisualStudioCode_Architecture.SelectedIndex = $LastSetting[123] -as [int]
        $WPFBox_Firefox_Architecture.SelectedIndex = $LastSetting[124] -as [int]
        $WPFBox_Firefox_Language.SelectedIndex = $LastSetting[125] -as [int]
        $WPFBox_NotepadPlusPlus_Architecture.SelectedIndex = $LastSetting[126] -as [int]
        $WPFBox_OpenJDK_Architecture.SelectedIndex = $LastSetting[127] -as [int]
        $WPFBox_OracleJava8_Architecture.SelectedIndex = $LastSetting[128] -as [int]
        $WPFBox_PeaZip_Architecture.SelectedIndex = $LastSetting[129] -as [int]
        $WPFBox_Putty_Architecture.SelectedIndex = $LastSetting[130] -as [int]
        $WPFBox_Slack_Architecture.SelectedIndex = $LastSetting[131] -as [int]
        $WPFBox_SumatraPDF_Architecture.SelectedIndex = $LastSetting[132] -as [int]
        $WPFBox_TechSmithSnagIT_Architecture.SelectedIndex = $LastSetting[133] -as [int]
        $WPFBox_VLCPlayer_Architecture.SelectedIndex = $LastSetting[134] -as [int]
        $WPFBox_VMwareTools_Architecture.SelectedIndex = $LastSetting[135] -as [int]
        $WPFBox_WinMerge_Architecture.SelectedIndex = $LastSetting[136] -as [int]
        $WPFBox_Wireshark_Architecture.SelectedIndex = $LastSetting[137] -as [int]
        $WPFBox_IrfanView_Language.SelectedIndex = $LastSetting[138] -as [int]
        $WPFBox_MSOffice_Language.SelectedIndex = $LastSetting[139] -as [int]
        $WPFBox_MSEdgeWebView2_Architecture.SelectedIndex = $LastSetting[141] -as [int]
        $WPFBox_MindView7_Language.SelectedIndex = $LastSetting[144] -as [int]
        $WPFBox_MSOffice.SelectedIndex = $LastSetting[146] -as [int]
        $WPFBox_LogMeInGoToMeeting_Installer.SelectedIndex = $LastSetting[150] -as [int]
        $WPFBox_MSAzureDataStudio_Installer.SelectedIndex = $LastSetting[151] -as [int]
        $WPFBox_MSVisualStudioCode_Installer.SelectedIndex = $LastSetting[152] -as [int]
        $WPFBox_MS365Apps_Installer.SelectedIndex = $LastSetting[153] -as [int]
        $WPFBox_Zoom_Architecture.SelectedIndex = $LastSetting[154] -as [int]
        $WPFBox_MSTeams_Installer.SelectedIndex = $LastSetting[155] -as [int]
        $WPFBox_Zoom_Installer.SelectedIndex = $LastSetting[156] -as [int]
        $WPFBox_MSOneDrive_Installer.SelectedIndex = $LastSetting[157] -as [int]
        $WPFBox_Slack_Installer.SelectedIndex = $LastSetting[158] -as [int]
        $WPFBox_pdfforgePDFCreator.SelectedIndex = $LastSetting[159] -as [int]
        $WPFBox_TotalCommander_Architecture.SelectedIndex = $LastSetting[160] -as [int]
        $WPFBox_MSVisualCPlusPlusRuntime.SelectedIndex = $LastSetting[164] -as [int]
        $WPFBox_MSVisualCPlusPlusRuntime_Architecture.SelectedIndex = $LastSetting[165] -as [int]
        $WPFBox_MSOffice_Visio_Language.SelectedIndex = $LastSetting[167] -as [int]
        $WPFBox_MSOffice_Project_Language.SelectedIndex = $LastSetting[169] -as [int]
        $WPFBox_CiscoWebexTeams.SelectedIndex = $LastSetting[170] -as [int]
        $WPFBox_BISF_Tools.SelectedIndex = $LastSetting[171] -as [int]
        $WPFBox_AdobeProDC_Architecture.SelectedIndex = $LastSetting[175] -as [int]
        $WPFBox_GoogleChrome.SelectedIndex = $LastSetting[176] -as [int]
        $WPFBox_OpenJDK.SelectedIndex = $LastSetting[177] -as [int]
        $WPFBox_PaintDotNet_Architecture.SelectedIndex = $LastSetting[178] -as [int]
        $WPFBox_WinRAR_Architecture.SelectedIndex = $LastSetting[179] -as [int]
        $WPFBox_WinRAR_Language.SelectedIndex = $LastSetting[180] -as [int]
        $WPFBox_WinRAR.SelectedIndex = $LastSetting[181] -as [int]
        $WPFBox_MozillaThunderbird_Architecture.SelectedIndex = $LastSetting[182] -as [int]
        $WPFBox_MozillaThunderbird_Language.SelectedIndex = $LastSetting[183] -as [int]
        $WPFBox_MSAzureDataStudio_Architecture.SelectedIndex = $LastSetting[184] -as [int]
        $WPFBox_TeamViewer_Architecture.SelectedIndex = $LastSetting[185] -as [int]
        $WPFBox_OperaBrowser_Architecture.SelectedIndex = $LastSetting[187] -as [int]
        $WPFBox_Ditto_Architecture.SelectedIndex = $LastSetting[189] -as [int]
        $WPFBox_Ditto.SelectedIndex = $LastSetting[190] -as [int]
        $WPFBox_ControlUpEdgeDX_Installer.SelectedIndex = $LastSetting[192] -as [int]
        $WPFBox_ControlUpRemoteDX.SelectedIndex = $LastSetting[198] -as [int]
        $WPFBox_AdoptOpenJDK.SelectedIndex = $LastSetting[201] -as [int]
        $WPFBox_AdoptOpenJDK_Architecture.SelectedIndex = $LastSetting[207] -as [int]
        $WPFBox_OpenWebStart_Architecture.SelectedIndex = $LastSetting[208] -as [int]
        $WPFBox_MSTeamsNew_Architecture.SelectedIndex = $LastSetting[213] -as [int]

        Switch ($LastSetting[8]) {
            1 {
                $WPFCheckbox_7ZIP.IsChecked = "True"
                $WPFCheckbox_7ZIP_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[9]) {
            1 {
                $WPFCheckbox_AdobeProDC.IsChecked = "True"
                $WPFCheckbox_AdobeProDC_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[10]) {
            1 {
                $WPFCheckbox_AdobeReaderDC.IsChecked = "True"
                $WPFCheckbox_AdobeReaderDC_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[11]) {
            1 { $WPFCheckbox_BISF.IsChecked = "True"}
        }
        Switch ($LastSetting[12]) {
            1 {
                $WPFCheckbox_CitrixHypervisorTools.IsChecked = "True"
                $WPFCheckbox_CitrixHypervisorTools_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[13]) {
            1 { $WPFCheckbox_CitrixWorkspaceApp.IsChecked = "True"}
        }
        Switch ($LastSetting[14]) {
            1 { $WPFCheckbox_Filezilla.IsChecked = "True"}
        }
        Switch ($LastSetting[15]) {
            1 {
                $WPFCheckbox_Firefox.IsChecked = "True"
                $WPFCheckbox_Firefox_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[16]) {
            1 {
                $WPFCheckbox_FoxitReader.IsChecked = "True"
                $WPFCheckbox_FoxitReader_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[17]) {
            1 {
                $WPFCheckbox_MSFSLogix.IsChecked = "True"
                $WPFCheckbox_MSFSLogix_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[18]) {
            1 {
                $WPFCheckbox_GoogleChrome.IsChecked = "True"
                $WPFCheckbox_GoogleChrome_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[19]) {
            1 { $WPFCheckbox_Greenshot.IsChecked = "True"}
        }
        Switch ($LastSetting[20]) {
            1 {
                $WPFCheckbox_KeePass.IsChecked = "True"
                $WPFCheckbox_KeePass_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[21]) {
            1 { $WPFCheckbox_mRemoteNG.IsChecked = "True"}
        }
        Switch ($LastSetting[22]) {
            1 {
                $WPFCheckbox_MS365Apps.IsChecked = "True"
                $WPFCheckbox_MS365Apps_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[23]) {
            1 {
                $WPFCheckbox_MSEdge.IsChecked = "True"
                $WPFCheckbox_MSEdge_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[24]) {
            1 {
                $WPFCheckbox_MSOffice.IsChecked = "True"
                $WPFCheckbox_MSOffice_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[25]) {
            1 {
                $WPFCheckbox_MSOneDrive.IsChecked = "True"
                $WPFCheckbox_MSOneDrive_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[26]) {
            1 {
                $WPFCheckbox_MSTeams.IsChecked = "True"
                $WPFCheckbox_MSTeams_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[27]) {
            1 {
                $WPFCheckbox_NotePadPlusPlus.IsChecked = "True"
                $WPFCheckbox_NotepadPlusPlus_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[28]) {
            1 {
                $WPFCheckbox_OpenJDK.IsChecked = "True"
                $WPFCheckbox_OpenJDK_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[29]) {
            1 {
                $WPFCheckbox_OracleJava8.IsChecked = "True"
                $WPFCheckbox_OracleJava8_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[30]) {
            1 { $WPFCheckbox_TreeSize.IsChecked = "True"}
        }
        Switch ($LastSetting[31]) {
            1 {
                $WPFCheckbox_VLCPlayer.IsChecked = "True"
                $WPFCheckbox_VLCPlayer_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[32]) {
            1 {
                $WPFCheckbox_VMwareTools.IsChecked = "True"
                $WPFCheckbox_VMwareTools_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[33]) {
            1 { $WPFCheckbox_WinSCP.IsChecked = "True"}
        }
        Switch ($LastSetting[34]) {
            True { $WPFCheckbox_Download.IsChecked = "True"}
            1 { $WPFCheckbox_Download.IsChecked = "True"}
        }
        Switch ($LastSetting[35]) {
            True { $WPFCheckbox_Install.IsChecked = "True"}
            1 { $WPFCheckbox_Install.IsChecked = "True"}
        }
        Switch ($LastSetting[36]) {
            1 {
                $WPFCheckbox_IrfanView.IsChecked = "True"
                $WPFCheckbox_IrfanView_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[37]) {
            1 { $WPFCheckbox_MSTeams_No_AutoStart.IsChecked = "True"}
        }
        Switch ($LastSetting[38]) {
            1 {
                $WPFCheckbox_deviceTRUST.IsChecked = "True"
                $WPFCheckbox_deviceTRUST_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[39]) {
            1 {
                $WPFCheckbox_MSDotNetFramework.IsChecked = "True"
                $WPFCheckbox_MSDotNetFramework_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[41]) {
            1 {
                $WPFCheckbox_MSPowerShell.IsChecked = "True"
                $WPFCheckbox_MSPowerShell_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[43]) {
            1 { $WPFCheckbox_RemoteDesktopManager.IsChecked = "True"}
        }
        Switch ($LastSetting[45]) {
            1 {
                $WPFCheckbox_Slack.IsChecked = "True"
                $WPFCheckbox_Slack_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[46]) {
            1 {
                $WPFCheckbox_Wireshark.IsChecked = "True"
                $WPFCheckbox_Wireshark_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[47]) {
            1 { $WPFCheckbox_ShareX.IsChecked = "True"}
        }
        Switch ($LastSetting[48]) {
            1 { 
                $WPFCheckbox_Zoom.IsChecked = "True"
                $WPFCheckbox_Zoom_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[52]) {
            1 { $WPFCheckbox_GIMP.IsChecked = "True"}
        }
        Switch ($LastSetting[53]) {
            1 { $WPFCheckbox_MSPowerToys.IsChecked = "True"}
        }
        Switch ($LastSetting[54]) {
            1 { $WPFCheckbox_MSVisualStudio.IsChecked = "True"}
        }
        Switch ($LastSetting[55]) {
            1 {
                $WPFCheckbox_MSVisualStudioCode.IsChecked = "True"
                $WPFCheckbox_MSVisualStudioCode_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[57]) {
            1 {
                $WPFCheckbox_PaintDotNet.IsChecked = "True"
                $WPFCheckbox_PaintDotNet_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[58]) {
            1 {
                $WPFCheckbox_Putty.IsChecked = "True"
                $WPFCheckbox_Putty_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[59]) {
            1 { $WPFCheckbox_TeamViewer.IsChecked = "True"}
            1 { $WPFCheckbox_TeamViewer_Detail.IsChecked = "True"}
        }
        Switch ($LastSetting[63]) {
            1 { $WPFCheckbox_MSAzureDataStudio.IsChecked = "True"}
        }
        Switch ($LastSetting[65]) {
            1 {
                $WPFCheckbox_ImageGlass.IsChecked = "True"
                $WPFCheckbox_ImageGlass_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[67]) {
            1 { 
                $WPFCheckbox_ControlUpEdgeDX.IsChecked = "True"
                $WPFCheckbox_ControlUpEdgeDX_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[68]) {
            1 { $WPFCheckbox_1Password.IsChecked = "True"}
        }
        Switch ($LastSetting[69]) {
            1 {
                $WPFCheckbox_SumatraPDF.IsChecked = "True"
                $WPFCheckbox_SumatraPDF_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[70]) {
            1 {
                $WPFCheckbox_ControlUpAgent.IsChecked = "True"
                $WPFCheckbox_ControlUpAgent_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[72]) {
            1 { $WPFCheckbox_ControlUpConsole.IsChecked = "True"}
        }
        Switch ($LastSetting[73]) {
            1 {
                $WPFCheckbox_MSSQLServerManagementStudio.IsChecked = "True"
                $WPFCheckbox_MSSQLServerManagementStudio_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[74]) {
            1 {
                $WPFCheckbox_MSAVDRemoteDesktop.IsChecked = "True"
                $WPFCheckbox_MSAVDRemoteDesktop_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[76]) {
            1 {
                $WPFCheckbox_MSPowerBIDesktop.IsChecked = "True"
                $WPFCheckbox_MSPowerBIDesktop_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[77]) {
            1 { $WPFCheckbox_RDAnalyzer.IsChecked = "True"}
        }
        Switch ($LastSetting[78]) {
            1 {
                $WPFCheckbox_CiscoWebexTeams.IsChecked = "True"
                $WPFCheckbox_CiscoWebexTeams_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[79]) {
            1 { $WPFCheckbox_CitrixFiles.IsChecked = "True"}
        }
        Switch ($LastSetting[80]) {
            1 {
                $WPFCheckbox_FoxitPDFEditor.IsChecked = "True"
                $WPFCheckbox_FoxitPDFEditor_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[81]) {
            1 {
                $WPFCheckbox_GitForWindows.IsChecked = "True"
                $WPFCheckbox_GitForWindows_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[82]) {
            1 { $WPFCheckbox_LogMeInGoToMeeting.IsChecked = "True"}
        }
        Switch ($LastSetting[83]) {
            1 { $WPFCheckbox_MSAzureCLI.IsChecked = "True"}
        }
        Switch ($LastSetting[84]) {
            1 { $WPFCheckbox_MSPowerBIReportBuilder.IsChecked = "True"}
        }
        Switch ($LastSetting[85]) {
            1 { $WPFCheckbox_MSSysinternals.IsChecked = "True"}
        }
        Switch ($LastSetting[86]) {
            1 { $WPFCheckbox_Nmap.IsChecked = "True"}
        }
        Switch ($LastSetting[87]) {
            1 {
                $WPFCheckbox_PeaZip.IsChecked = "True"
                $WPFCheckbox_PeaZip_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[88]) {
            1 { $WPFCheckbox_TechSmithCamtasia.IsChecked = "True"}
        }
        Switch ($LastSetting[89]) {
            1 {
                $WPFCheckbox_TechSmithSnagIt.IsChecked = "True"
                $WPFCheckbox_TechSmithSnagIt_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[90]) {
            1 {
                $WPFCheckbox_WinMerge.IsChecked = "True"
                $WPFCheckbox_WinMerge_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[91]) {
            1 { $WPFCheckbox_WhatIf.IsChecked = "True"}
        }
        Switch ($LastSetting[92]) {
            1 { $WPFCheckbox_CleanUp.IsChecked = "True"}
        }
        Switch ($LastSetting[110]) {
            1 { $WPFCheckbox_MS365Apps_Visio_Detail.IsChecked = "True"}
        }
        Switch ($LastSetting[112]) {
            1 { $WPFCheckbox_MS365Apps_Project_Detail.IsChecked = "True"}
        }
        Switch ($LastSetting[140]) {
            1 {
                $WPFCheckbox_MSEdgeWebView2.IsChecked = "True"
                $WPFCheckbox_MSEdgeWebView2_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[142]) {
            1 {
                $WPFCheckbox_AutodeskDWGTrueView.IsChecked = "True"
            }
        }
        Switch ($LastSetting[143]) {
            1 {
                $WPFCheckbox_MindView7.IsChecked = "True"
                $WPFCheckbox_MindView7_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[145]) {
            1 {
                $WPFCheckbox_PDFsam.IsChecked = "True"
            }
        }
        Switch ($LastSetting[147]) {
            1 {
                $WPFCheckbox_OpenShellMenu.IsChecked = "True"
            }
        }
        Switch ($LastSetting[148]) {
            1 {
                $WPFCheckbox_PDFForgeCreator.IsChecked = "True"
            }
        }
        Switch ($LastSetting[149]) {
            1 {
                $WPFCheckbox_TotalCommander.IsChecked = "True"
                $WPFCheckbox_TotalCommander_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[161]) {
            1 { $WPFCheckbox_Repository.IsChecked = "True"}
        }
        Switch ($LastSetting[162]) {
            1 { $WPFCheckbox_CleanUpStartMenu.IsChecked = "True"}
        }
        Switch ($LastSetting[163]) {
            1 {
                $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked = "True"
                $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[166]) {
            1 {
                $WPFCheckbox_MSOffice_Visio_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[168]) {
            1 {
                $WPFCheckbox_MSOffice_Project_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[172]) {
            1 {
                $WPFCheckbox_MozillaThunderbird.IsChecked = "True"
                $WPFCheckbox_MozillaThunderbird_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[173]) {
            1 {
                $WPFCheckbox_PDF24Creator.IsChecked = "True"
            }
        }
        Switch ($LastSetting[174]) {
            1 {
                $WPFCheckbox_WinRAR.IsChecked = "True"
                $WPFCheckbox_WinRAR_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[186]) {
            1 {
                $WPFCheckbox_OperaBrowser.IsChecked = "True"
                $WPFCheckbox_OperaBrowser_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[188]) {
            1 {
                $WPFCheckbox_Ditto.IsChecked = "True"
                $WPFCheckbox_Ditto_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[191]) {
            1 {
                $WPFCheckbox_XCA.IsChecked = "True"
            }
        }
        Switch ($LastSetting[193]) {
            1 {
                $WPFCheckbox_ControlUpRemoteDX.IsChecked = "True"
            }
        }
        Switch ($LastSetting[194]) {
            1 {
                $WPFCheckbox_IISCrypto.IsChecked = "True"
            }
        }
        Switch ($LastSetting[195]) {
            1 {
                $WPFCheckbox_Screenpresso.IsChecked = "True"
            }
        }
        Switch ($LastSetting[196]) {
            1 {
                $WPFCheckbox_Report.IsChecked = "True"
            }
        }
        Switch ($LastSetting[197]) {
            1 {
                $WPFCheckbox_NoDesktopIcon.IsChecked = "True"
            }
        }
        Switch ($LastSetting[199]) {
            1 {
                $WPFCheckbox_MSTeamsAVD.IsChecked = "True"
            }
        }
        Switch ($LastSetting[200]) {
            1 {
                $WPFCheckbox_AdoptOpenJDK.IsChecked = "True"
                $WPFCheckbox_AdoptOpenJDK_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[202]) {
            1 {
                $WPFCheckbox_Bloomberg.IsChecked = "True"
            }
        }
        Switch ($LastSetting[203]) {
            1 {
                $WPFCheckbox_GoogleDrive.IsChecked = "True"
            }
        }
        Switch ($LastSetting[204]) {
            1 {
                $WPFCheckbox_JabraDirect.IsChecked = "True"
            }
        }
        Switch ($LastSetting[205]) {
            1 {
                $WPFCheckbox_AdoptOpenJDKIcedTeaWeb.IsChecked = "True"
            }
        }
        Switch ($LastSetting[206]) {
            1 {
                $WPFCheckbox_OpenWebStart.IsChecked = "True"
            }
        }
        Switch ($LastSetting[209]) {
            1 {
                $WPFCheckbox_WindowsUpdate.IsChecked = "True"
            }
        }
        Switch ($LastSetting[210]) {
            1 {
                $WPFCheckbox_MSTeamsNew.IsChecked = "True"
                $WPFCheckbox_MSTeamsNew_Detail.IsChecked = "True"
            }
        }
        Switch ($LastSetting[211]) {
            1 {
                $WPFCheckbox_MSTeamsAVDNew.IsChecked = "True"
            }
        }
        Switch ($LastSetting[212]) {
            1 {
                $WPFCheckbox_MobaXterm.IsChecked = "True"
            }
        }
    }

    # Read local ControlUp files to get the settings of the last session.
    If (Test-Path "$PSScriptRoot\ControlUp Agent\AuthKey.txt" -PathType leaf) {
        $ControlUpAgentAuthKey = Get-Content "$PSScriptRoot\ControlUp Agent\AuthKey.txt"
        $WPFTextBox_ControlUpAgentAuthKey.Text = $ControlUpAgentAuthKey
    }
    If (Test-Path "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt" -PathType leaf) {
        $ControlUpEdgeDXDevRegCode = Get-Content "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt"
        $WPFTextBox_ControlUpEdgeDXDevRegCode.Text = $ControlUpEdgeDXDevRegCode
    }
    If (Test-Path "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt" -PathType leaf) {
        $ControlUpEdgeDXTenantName = Get-Content "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt"
        $WPFTextBox_ControlUpEdgeDXTenantName.Text = $ControlUpEdgeDXTenantName
    }

    #// MARK: Event Handler
    # Checkbox Detail (AddScript)
    $WPFCheckbox_7ZIP.Add_Checked({
        $WPFCheckbox_7Zip_Detail.IsChecked = $WPFCheckbox_7ZIP.IsChecked
    })
    $WPFCheckbox_7ZIP.Add_Unchecked({
        $WPFCheckbox_7Zip_Detail.IsChecked = $WPFCheckbox_7Zip.IsChecked
    })
    $WPFCheckbox_7ZIP_Detail.Add_Checked({
        $WPFCheckbox_7Zip.IsChecked = $WPFCheckbox_7ZIP_Detail.IsChecked
    })
    $WPFCheckbox_7ZIP_Detail.Add_Unchecked({
        $WPFCheckbox_7Zip.IsChecked = $WPFCheckbox_7Zip_Detail.IsChecked
    })
    $WPFCheckbox_AdobeProDC.Add_Checked({
        $WPFCheckbox_AdobeProDC_Detail.IsChecked = $WPFCheckbox_AdobeProDC.IsChecked
    })
    $WPFCheckbox_AdobeProDC.Add_Unchecked({
        $WPFCheckbox_AdobeProDC_Detail.IsChecked = $WPFCheckbox_AdobeProDC.IsChecked
    })
    $WPFCheckbox_AdobeProDC_Detail.Add_Checked({
        $WPFCheckbox_AdobeProDC.IsChecked = $WPFCheckbox_AdobeProDC_Detail.IsChecked
    })
    $WPFCheckbox_AdobeProDC_Detail.Add_Unchecked({
        $WPFCheckbox_AdobeProDC.IsChecked = $WPFCheckbox_AdobeProDC_Detail.IsChecked
    })
    $WPFCheckbox_AdobeReaderDC.Add_Checked({
        $WPFCheckbox_AdobeReaderDC_Detail.IsChecked = $WPFCheckbox_AdobeReaderDC.IsChecked
    })
    $WPFCheckbox_AdobeReaderDC.Add_Unchecked({
        $WPFCheckbox_AdobeReaderDC_Detail.IsChecked = $WPFCheckbox_AdobeReaderDC.IsChecked
    })
    $WPFCheckbox_AdobeReaderDC_Detail.Add_Checked({
        $WPFCheckbox_AdobeReaderDC.IsChecked = $WPFCheckbox_AdobeReaderDC_Detail.IsChecked
    })
    $WPFCheckbox_AdobeReaderDC_Detail.Add_Unchecked({
        $WPFCheckbox_AdobeReaderDC.IsChecked = $WPFCheckbox_AdobeReaderDC_Detail.IsChecked
    })
    $WPFCheckbox_AdoptOpenJDK.Add_Checked({
        $WPFCheckbox_AdoptOpenJDK_Detail.IsChecked = $WPFCheckbox_AdoptOpenJDK.IsChecked
    })
    $WPFCheckbox_AdoptOpenJDK.Add_Unchecked({
        $WPFCheckbox_AdoptOpenJDK_Detail.IsChecked = $WPFCheckbox_AdoptOpenJDK.IsChecked
    })
    $WPFCheckbox_AdoptOpenJDK_Detail.Add_Checked({
        $WPFCheckbox_AdoptOpenJDK.IsChecked = $WPFCheckbox_AdoptOpenJDK_Detail.IsChecked
    })
    $WPFCheckbox_AdoptOpenJDK_Detail.Add_Unchecked({
        $WPFCheckbox_AdoptOpenJDK.IsChecked = $WPFCheckbox_AdoptOpenJDK_Detail.IsChecked
    })
    $WPFCheckbox_CiscoWebexTeams.Add_Checked({
        $WPFCheckbox_CiscoWebexTeams_Detail.IsChecked = $WPFCheckbox_CiscoWebexTeams.IsChecked
    })
    $WPFCheckbox_CiscoWebexTeams.Add_Unchecked({
        $WPFCheckbox_CiscoWebexTeams_Detail.IsChecked = $WPFCheckbox_CiscoWebexTeams.IsChecked
    })
    $WPFCheckbox_CiscoWebexTeams_Detail.Add_Checked({
        $WPFCheckbox_CiscoWebexTeams.IsChecked = $WPFCheckbox_CiscoWebexTeams_Detail.IsChecked
    })
    $WPFCheckbox_CiscoWebexTeams_Detail.Add_Unchecked({
        $WPFCheckbox_CiscoWebexTeams.IsChecked = $WPFCheckbox_CiscoWebexTeams_Detail.IsChecked
    })
    $WPFCheckbox_CitrixHypervisorTools.Add_Checked({
        $WPFCheckbox_CitrixHypervisorTools_Detail.IsChecked = $WPFCheckbox_CitrixHypervisorTools.IsChecked
    })
    $WPFCheckbox_CitrixHypervisorTools.Add_Unchecked({
        $WPFCheckbox_CitrixHypervisorTools_Detail.IsChecked = $WPFCheckbox_CitrixHypervisorTools.IsChecked
    })
    $WPFCheckbox_CitrixHypervisorTools_Detail.Add_Checked({
        $WPFCheckbox_CitrixHypervisorTools.IsChecked = $WPFCheckbox_CitrixHypervisorTools_Detail.IsChecked
    })
    $WPFCheckbox_CitrixHypervisorTools_Detail.Add_Unchecked({
        $WPFCheckbox_CitrixHypervisorTools.IsChecked = $WPFCheckbox_CitrixHypervisorTools_Detail.IsChecked
    })
    $WPFCheckbox_ControlUpEdgeDX.Add_Checked({
        $WPFCheckbox_ControlUpEdgeDX_Detail.IsChecked = $WPFCheckbox_ControlUpEdgeDX.IsChecked
    })
    $WPFCheckbox_ControlUpEdgeDX.Add_Unchecked({
        $WPFCheckbox_ControlUpEdgeDX_Detail.IsChecked = $WPFCheckbox_ControlUpEdgeDX.IsChecked
    })
    $WPFCheckbox_ControlUpEdgeDX_Detail.Add_Checked({
        $WPFCheckbox_ControlUpEdgeDX.IsChecked = $WPFCheckbox_ControlUpEdgeDX_Detail.IsChecked
    })
    $WPFCheckbox_ControlUpEdgeDX_Detail.Add_Unchecked({
        $WPFCheckbox_ControlUpEdgeDX.IsChecked = $WPFCheckbox_ControlUpEdgeDX_Detail.IsChecked
    })
    $WPFCheckbox_deviceTRUST.Add_Checked({
        $WPFCheckbox_deviceTRUST_Detail.IsChecked = $WPFCheckbox_deviceTRUST.IsChecked
    })
    $WPFCheckbox_deviceTRUST.Add_Unchecked({
        $WPFCheckbox_deviceTRUST_Detail.IsChecked = $WPFCheckbox_deviceTRUST.IsChecked
    })
    $WPFCheckbox_deviceTRUST_Detail.Add_Checked({
        $WPFCheckbox_deviceTRUST.IsChecked = $WPFCheckbox_deviceTRUST_Detail.IsChecked
    })
    $WPFCheckbox_deviceTRUST_Detail.Add_Unchecked({
        $WPFCheckbox_deviceTRUST.IsChecked = $WPFCheckbox_deviceTRUST_Detail.IsChecked
    })
    $WPFCheckbox_Ditto.Add_Checked({
        $WPFCheckbox_Ditto_Detail.IsChecked = $WPFCheckbox_Ditto.IsChecked
    })
    $WPFCheckbox_Ditto.Add_Unchecked({
        $WPFCheckbox_Ditto_Detail.IsChecked = $WPFCheckbox_Ditto.IsChecked
    })
    $WPFCheckbox_Ditto_Detail.Add_Checked({
        $WPFCheckbox_Ditto.IsChecked = $WPFCheckbox_Ditto_Detail.IsChecked
    })
    $WPFCheckbox_Ditto_Detail.Add_Unchecked({
        $WPFCheckbox_Ditto.IsChecked = $WPFCheckbox_Ditto_Detail.IsChecked
    })
    $WPFCheckbox_ControlUpAgent.Add_Checked({
        $WPFCheckbox_ControlUpAgent_Detail.IsChecked = $WPFCheckbox_ControlUpAgent.IsChecked
    })
    $WPFCheckbox_ControlUpAgent.Add_Unchecked({
        $WPFCheckbox_ControlUpAgent_Detail.IsChecked = $WPFCheckbox_ControlUpAgent.IsChecked
    })
    $WPFCheckbox_ControlUpAgent_Detail.Add_Checked({
        $WPFCheckbox_ControlUpAgent.IsChecked = $WPFCheckbox_ControlUpAgent_Detail.IsChecked
    })
    $WPFCheckbox_ControlUpAgent_Detail.Add_Unchecked({
        $WPFCheckbox_ControlUpAgent.IsChecked = $WPFCheckbox_ControlUpAgent_Detail.IsChecked
    })
    $WPFCheckbox_FoxitPDFEditor.Add_Checked({
        $WPFCheckbox_FoxitPDFEditor_Detail.IsChecked = $WPFCheckbox_FoxitPDFEditor.IsChecked
    })
    $WPFCheckbox_FoxitPDFEditor.Add_Unchecked({
        $WPFCheckbox_FoxitPDFEditor_Detail.IsChecked = $WPFCheckbox_FoxitPDFEditor.IsChecked
    })
    $WPFCheckbox_FoxitPDFEditor_Detail.Add_Checked({
        $WPFCheckbox_FoxitPDFEditor.IsChecked = $WPFCheckbox_FoxitPDFEditor_Detail.IsChecked
    })
    $WPFCheckbox_FoxitPDFEditor_Detail.Add_Unchecked({
        $WPFCheckbox_FoxitPDFEditor.IsChecked = $WPFCheckbox_FoxitPDFEditor_Detail.IsChecked
    })
    $WPFCheckbox_FoxitReader.Add_Checked({
        $WPFCheckbox_FoxitReader_Detail.IsChecked = $WPFCheckbox_FoxitReader.IsChecked
    })
    $WPFCheckbox_FoxitReader.Add_Unchecked({
        $WPFCheckbox_FoxitReader_Detail.IsChecked = $WPFCheckbox_FoxitReader.IsChecked
    })
    $WPFCheckbox_FoxitReader_Detail.Add_Checked({
        $WPFCheckbox_FoxitReader.IsChecked = $WPFCheckbox_FoxitReader_Detail.IsChecked
    })
    $WPFCheckbox_FoxitReader_Detail.Add_Unchecked({
        $WPFCheckbox_FoxitReader.IsChecked = $WPFCheckbox_FoxitReader_Detail.IsChecked
    })
    $WPFCheckbox_GitForWindows.Add_Checked({
        $WPFCheckbox_GitForWindows_Detail.IsChecked = $WPFCheckbox_GitForWindows.IsChecked
    })
    $WPFCheckbox_GitForWindows.Add_Unchecked({
        $WPFCheckbox_GitForWindows_Detail.IsChecked = $WPFCheckbox_GitForWindows.IsChecked
    })
    $WPFCheckbox_GitForWindows_Detail.Add_Checked({
        $WPFCheckbox_GitForWindows.IsChecked = $WPFCheckbox_GitForWindows_Detail.IsChecked
    })
    $WPFCheckbox_GitForWindows_Detail.Add_Unchecked({
        $WPFCheckbox_GitForWindows.IsChecked = $WPFCheckbox_GitForWindows_Detail.IsChecked
    })
    $WPFCheckbox_GoogleChrome.Add_Checked({
        $WPFCheckbox_GoogleChrome_Detail.IsChecked = $WPFCheckbox_GoogleChrome.IsChecked
    })
    $WPFCheckbox_GoogleChrome.Add_Unchecked({
        $WPFCheckbox_GoogleChrome_Detail.IsChecked = $WPFCheckbox_GoogleChrome.IsChecked
    })
    $WPFCheckbox_GoogleChrome_Detail.Add_Checked({
        $WPFCheckbox_GoogleChrome.IsChecked = $WPFCheckbox_GoogleChrome_Detail.IsChecked
    })
    $WPFCheckbox_GoogleChrome_Detail.Add_Unchecked({
        $WPFCheckbox_GoogleChrome.IsChecked = $WPFCheckbox_GoogleChrome_Detail.IsChecked
    })
    $WPFCheckbox_ImageGlass.Add_Checked({
        $WPFCheckbox_ImageGlass_Detail.IsChecked = $WPFCheckbox_ImageGlass.IsChecked
    })
    $WPFCheckbox_ImageGlass.Add_Unchecked({
        $WPFCheckbox_ImageGlass_Detail.IsChecked = $WPFCheckbox_ImageGlass.IsChecked
    })
    $WPFCheckbox_ImageGlass_Detail.Add_Checked({
        $WPFCheckbox_ImageGlass.IsChecked = $WPFCheckbox_ImageGlass_Detail.IsChecked
    })
    $WPFCheckbox_ImageGlass_Detail.Add_Unchecked({
        $WPFCheckbox_ImageGlass.IsChecked = $WPFCheckbox_ImageGlass_Detail.IsChecked
    })
    $WPFCheckbox_IrfanView.Add_Checked({
        $WPFCheckbox_IrfanView_Detail.IsChecked = $WPFCheckbox_IrfanView.IsChecked
    })
    $WPFCheckbox_IrfanView.Add_Unchecked({
        $WPFCheckbox_IrfanView_Detail.IsChecked = $WPFCheckbox_IrfanView.IsChecked
    })
    $WPFCheckbox_IrfanView_Detail.Add_Checked({
        $WPFCheckbox_IrfanView.IsChecked = $WPFCheckbox_IrfanView_Detail.IsChecked
    })
    $WPFCheckbox_IrfanView_Detail.Add_Unchecked({
        $WPFCheckbox_IrfanView.IsChecked = $WPFCheckbox_IrfanView_Detail.IsChecked
    })
    $WPFCheckbox_KeePass.Add_Checked({
        $WPFCheckbox_KeePass_Detail.IsChecked = $WPFCheckbox_KeePass.IsChecked
    })
    $WPFCheckbox_KeePass.Add_Unchecked({
        $WPFCheckbox_KeePass_Detail.IsChecked = $WPFCheckbox_KeePass.IsChecked
    })
    $WPFCheckbox_KeePass_Detail.Add_Checked({
        $WPFCheckbox_KeePass.IsChecked = $WPFCheckbox_KeePass_Detail.IsChecked
    })
    $WPFCheckbox_KeePass_Detail.Add_Unchecked({
        $WPFCheckbox_KeePass.IsChecked = $WPFCheckbox_KeePass_Detail.IsChecked
    })
    $WPFCheckbox_LogMeInGoToMeeting.Add_Checked({
        $WPFCheckbox_LogMeInGoToMeeting_Detail.IsChecked = $WPFCheckbox_LogMeInGoToMeeting.IsChecked
    })
    $WPFCheckbox_LogMeInGoToMeeting.Add_Unchecked({
        $WPFCheckbox_LogMeInGoToMeeting_Detail.IsChecked = $WPFCheckbox_LogMeInGoToMeeting.IsChecked
    })
    $WPFCheckbox_LogMeInGoToMeeting_Detail.Add_Checked({
        $WPFCheckbox_LogMeInGoToMeeting.IsChecked = $WPFCheckbox_LogMeInGoToMeeting_Detail.IsChecked
    })
    $WPFCheckbox_LogMeInGoToMeeting_Detail.Add_Unchecked({
        $WPFCheckbox_LogMeInGoToMeeting.IsChecked = $WPFCheckbox_LogMeInGoToMeeting_Detail.IsChecked
    })
    $WPFCheckbox_MSDotNetFramework.Add_Checked({
        $WPFCheckbox_MSDotNetFramework_Detail.IsChecked = $WPFCheckbox_MSDotNetFramework.IsChecked
    })
    $WPFCheckbox_MSDotNetFramework.Add_Unchecked({
        $WPFCheckbox_MSDotNetFramework_Detail.IsChecked = $WPFCheckbox_MSDotNetFramework.IsChecked
    })
    $WPFCheckbox_MSDotNetFramework_Detail.Add_Checked({
        $WPFCheckbox_MSDotNetFramework.IsChecked = $WPFCheckbox_MSDotNetFramework_Detail.IsChecked
    })
    $WPFCheckbox_MSDotNetFramework_Detail.Add_Unchecked({
        $WPFCheckbox_MSDotNetFramework.IsChecked = $WPFCheckbox_MSDotNetFramework_Detail.IsChecked
    })
    $WPFCheckbox_MS365Apps.Add_Checked({
        $WPFCheckbox_MS365Apps_Detail.IsChecked = $WPFCheckbox_MS365Apps.IsChecked
    })
    $WPFCheckbox_MS365Apps.Add_Unchecked({
        $WPFCheckbox_MS365Apps_Detail.IsChecked = $WPFCheckbox_MS365Apps.IsChecked
    })
    $WPFCheckbox_MS365Apps_Detail.Add_Checked({
        $WPFCheckbox_MS365Apps.IsChecked = $WPFCheckbox_MS365Apps_Detail.IsChecked
    })
    $WPFCheckbox_MS365Apps_Detail.Add_Unchecked({
        $WPFCheckbox_MS365Apps.IsChecked = $WPFCheckbox_MS365Apps_Detail.IsChecked
    })
    $WPFCheckbox_MSAVDRemoteDesktop.Add_Checked({
        $WPFCheckbox_MSAVDRemoteDesktop_Detail.IsChecked = $WPFCheckbox_MSAVDRemoteDesktop.IsChecked
    })
    $WPFCheckbox_MSAVDRemoteDesktop.Add_Unchecked({
        $WPFCheckbox_MSAVDRemoteDesktop_Detail.IsChecked = $WPFCheckbox_MSAVDRemoteDesktop.IsChecked
    })
    $WPFCheckbox_MSAVDRemoteDesktop_Detail.Add_Checked({
        $WPFCheckbox_MSAVDRemoteDesktop.IsChecked = $WPFCheckbox_MSAVDRemoteDesktop_Detail.IsChecked
    })
    $WPFCheckbox_MSAVDRemoteDesktop_Detail.Add_Unchecked({
        $WPFCheckbox_MSAVDRemoteDesktop.IsChecked = $WPFCheckbox_MSAVDRemoteDesktop_Detail.IsChecked
    })
    $WPFCheckbox_MSAzureDataStudio.Add_Checked({
        $WPFCheckbox_MSAzureDataStudio_Detail.IsChecked = $WPFCheckbox_MSAzureDataStudio.IsChecked
    })
    $WPFCheckbox_MSAzureDataStudio.Add_Unchecked({
        $WPFCheckbox_MSAzureDataStudio_Detail.IsChecked = $WPFCheckbox_MSAzureDataStudio.IsChecked
    })
    $WPFCheckbox_MSAzureDataStudio_Detail.Add_Checked({
        $WPFCheckbox_MSAzureDataStudio.IsChecked = $WPFCheckbox_MSAzureDataStudio_Detail.IsChecked
    })
    $WPFCheckbox_MSAzureDataStudio_Detail.Add_Unchecked({
        $WPFCheckbox_MSAzureDataStudio.IsChecked = $WPFCheckbox_MSAzureDataStudio_Detail.IsChecked
    })
    $WPFCheckbox_MSEdge.Add_Checked({
        $WPFCheckbox_MSEdge_Detail.IsChecked = $WPFCheckbox_MSEdge.IsChecked
    })
    $WPFCheckbox_MSEdge.Add_Unchecked({
        $WPFCheckbox_MSEdge_Detail.IsChecked = $WPFCheckbox_MSEdge.IsChecked
    })
    $WPFCheckbox_MSEdge_Detail.Add_Checked({
        $WPFCheckbox_MSEdge.IsChecked = $WPFCheckbox_MSEdge_Detail.IsChecked
    })
    $WPFCheckbox_MSEdge_Detail.Add_Unchecked({
        $WPFCheckbox_MSEdge.IsChecked = $WPFCheckbox_MSEdge_Detail.IsChecked
    })
    $WPFCheckbox_MSEdgeWebView2.Add_Checked({
        $WPFCheckbox_MSEdgeWebView2_Detail.IsChecked = $WPFCheckbox_MSEdgeWebView2.IsChecked
    })
    $WPFCheckbox_MSEdgeWebView2.Add_Unchecked({
        $WPFCheckbox_MSEdgeWebView2_Detail.IsChecked = $WPFCheckbox_MSEdgeWebView2.IsChecked
    })
    $WPFCheckbox_MSEdgeWebView2_Detail.Add_Checked({
        $WPFCheckbox_MSEdgeWebView2.IsChecked = $WPFCheckbox_MSEdgeWebView2_Detail.IsChecked
    })
    $WPFCheckbox_MSEdgeWebView2_Detail.Add_Unchecked({
        $WPFCheckbox_MSEdgeWebView2.IsChecked = $WPFCheckbox_MSEdgeWebView2_Detail.IsChecked
    })
    $WPFCheckbox_MSFSLogix.Add_Checked({
        $WPFCheckbox_MSFSLogix_Detail.IsChecked = $WPFCheckbox_MSFSLogix.IsChecked
    })
    $WPFCheckbox_MSFSLogix.Add_Unchecked({
        $WPFCheckbox_MSFSLogix_Detail.IsChecked = $WPFCheckbox_MSFSLogix.IsChecked
    })
    $WPFCheckbox_MSFSLogix_Detail.Add_Checked({
        $WPFCheckbox_MSFSLogix.IsChecked = $WPFCheckbox_MSFSLogix_Detail.IsChecked
    })
    $WPFCheckbox_MSFSLogix_Detail.Add_Unchecked({
        $WPFCheckbox_MSFSLogix.IsChecked = $WPFCheckbox_MSFSLogix_Detail.IsChecked
    })
    $WPFCheckbox_MSOffice.Add_Checked({
        $WPFCheckbox_MSOffice_Detail.IsChecked = $WPFCheckbox_MSOffice.IsChecked
    })
    $WPFCheckbox_MSOffice.Add_Unchecked({
        $WPFCheckbox_MSOffice_Detail.IsChecked = $WPFCheckbox_MSOffice.IsChecked
    })
    $WPFCheckbox_MSOffice_Detail.Add_Checked({
        $WPFCheckbox_MSOffice.IsChecked = $WPFCheckbox_MSOffice_Detail.IsChecked
    })
    $WPFCheckbox_MSOffice_Detail.Add_Unchecked({
        $WPFCheckbox_MSOffice.IsChecked = $WPFCheckbox_MSOffice_Detail.IsChecked
    })
    $WPFCheckbox_MSOneDrive.Add_Checked({
        $WPFCheckbox_MSOneDrive_Detail.IsChecked = $WPFCheckbox_MSOneDrive.IsChecked
    })
    $WPFCheckbox_MSOneDrive.Add_Unchecked({
        $WPFCheckbox_MSOneDrive_Detail.IsChecked = $WPFCheckbox_MSOneDrive.IsChecked
    })
    $WPFCheckbox_MSOneDrive_Detail.Add_Checked({
        $WPFCheckbox_MSOneDrive.IsChecked = $WPFCheckbox_MSOneDrive_Detail.IsChecked
    })
    $WPFCheckbox_MSOneDrive_Detail.Add_Unchecked({
        $WPFCheckbox_MSOneDrive.IsChecked = $WPFCheckbox_MSOneDrive_Detail.IsChecked
    })
    $WPFCheckbox_MSPowerBIDesktop.Add_Checked({
        $WPFCheckbox_MSPowerBIDesktop_Detail.IsChecked = $WPFCheckbox_MSPowerBIDesktop.IsChecked
    })
    $WPFCheckbox_MSPowerBIDesktop.Add_Unchecked({
        $WPFCheckbox_MSPowerBIDesktop_Detail.IsChecked = $WPFCheckbox_MSPowerBIDesktop.IsChecked
    })
    $WPFCheckbox_MSPowerBIDesktop_Detail.Add_Checked({
        $WPFCheckbox_MSPowerBIDesktop.IsChecked = $WPFCheckbox_MSPowerBIDesktop_Detail.IsChecked
    })
    $WPFCheckbox_MSPowerBIDesktop_Detail.Add_Unchecked({
        $WPFCheckbox_MSPowerBIDesktop.IsChecked = $WPFCheckbox_MSPowerBIDesktop_Detail.IsChecked
    })
    $WPFCheckbox_MSPowerShell.Add_Checked({
        $WPFCheckbox_MSPowerShell_Detail.IsChecked = $WPFCheckbox_MSPowerShell.IsChecked
    })
    $WPFCheckbox_MSPowerShell.Add_Unchecked({
        $WPFCheckbox_MSPowerShell_Detail.IsChecked = $WPFCheckbox_MSPowerShell.IsChecked
    })
    $WPFCheckbox_MSPowerShell_Detail.Add_Checked({
        $WPFCheckbox_MSPowerShell.IsChecked = $WPFCheckbox_MSPowerShell_Detail.IsChecked
    })
    $WPFCheckbox_MSPowerShell_Detail.Add_Unchecked({
        $WPFCheckbox_MSPowerShell.IsChecked = $WPFCheckbox_MSPowerShell_Detail.IsChecked
    })
    $WPFCheckbox_MSSQLServerManagementStudio.Add_Checked({
        $WPFCheckbox_MSSQLServerManagementStudio_Detail.IsChecked = $WPFCheckbox_MSSQLServerManagementStudio.IsChecked
    })
    $WPFCheckbox_MSSQLServerManagementStudio.Add_Unchecked({
        $WPFCheckbox_MSSQLServerManagementStudio_Detail.IsChecked = $WPFCheckbox_MSSQLServerManagementStudio.IsChecked
    })
    $WPFCheckbox_MSSQLServerManagementStudio_Detail.Add_Checked({
        $WPFCheckbox_MSSQLServerManagementStudio.IsChecked = $WPFCheckbox_MSSQLServerManagementStudio_Detail.IsChecked
    })
    $WPFCheckbox_MSSQLServerManagementStudio_Detail.Add_Unchecked({
        $WPFCheckbox_MSSQLServerManagementStudio.IsChecked = $WPFCheckbox_MSSQLServerManagementStudio_Detail.IsChecked
    })
    $WPFCheckbox_MSTeams.Add_Checked({
        $WPFCheckbox_MSTeams_Detail.IsChecked = $WPFCheckbox_MSTeams.IsChecked
    })
    $WPFCheckbox_MSTeams.Add_Unchecked({
        $WPFCheckbox_MSTeams_Detail.IsChecked = $WPFCheckbox_MSTeams.IsChecked
    })
    $WPFCheckbox_MSTeams_Detail.Add_Checked({
        $WPFCheckbox_MSTeams.IsChecked = $WPFCheckbox_MSTeams_Detail.IsChecked
    })
    $WPFCheckbox_MSTeams_Detail.Add_Unchecked({
        $WPFCheckbox_MSTeams.IsChecked = $WPFCheckbox_MSTeams_Detail.IsChecked
    })
    $WPFCheckbox_MSTeamsNew.Add_Checked({
        $WPFCheckbox_MSTeamsNew_Detail.IsChecked = $WPFCheckbox_MSTeamsNew.IsChecked
    })
    $WPFCheckbox_MSTeamsNew.Add_Unchecked({
        $WPFCheckbox_MSTeamsNew_Detail.IsChecked = $WPFCheckbox_MSTeamsNew.IsChecked
    })
    $WPFCheckbox_MSTeamsNew_Detail.Add_Checked({
        $WPFCheckbox_MSTeamsNew.IsChecked = $WPFCheckbox_MSTeamsNew_Detail.IsChecked
    })
    $WPFCheckbox_MSTeamsNew_Detail.Add_Unchecked({
        $WPFCheckbox_MSTeamsNew.IsChecked = $WPFCheckbox_MSTeamsNew_Detail.IsChecked
    })
    $WPFCheckbox_MSVisualCPlusPlusRuntime.Add_Checked({
        $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.IsChecked = $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked
    })
    $WPFCheckbox_MSVisualCPlusPlusRuntime.Add_Unchecked({
        $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.IsChecked = $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked
    })
    $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.Add_Checked({
        $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked = $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.IsChecked
    })
    $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.Add_Unchecked({
        $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked = $WPFCheckbox_MSVisualCPlusPlusRuntime_Detail.IsChecked
    })
    $WPFCheckbox_MSVisualStudioCode.Add_Checked({
        $WPFCheckbox_MSVisualStudioCode_Detail.IsChecked = $WPFCheckbox_MSVisualStudioCode.IsChecked
    })
    $WPFCheckbox_MSVisualStudioCode.Add_Unchecked({
        $WPFCheckbox_MSVisualStudioCode_Detail.IsChecked = $WPFCheckbox_MSVisualStudioCode.IsChecked
    })
    $WPFCheckbox_MSVisualStudioCode_Detail.Add_Checked({
        $WPFCheckbox_MSVisualStudioCode.IsChecked = $WPFCheckbox_MSVisualStudioCode_Detail.IsChecked
    })
    $WPFCheckbox_MSVisualStudioCode_Detail.Add_Unchecked({
        $WPFCheckbox_MSVisualStudioCode.IsChecked = $WPFCheckbox_MSVisualStudioCode_Detail.IsChecked
    })
    $WPFCheckbox_MindView7.Add_Checked({
        $WPFCheckbox_MindView7_Detail.IsChecked = $WPFCheckbox_MindView7.IsChecked
    })
    $WPFCheckbox_MindView7.Add_Unchecked({
        $WPFCheckbox_MindView7_Detail.IsChecked = $WPFCheckbox_MindView7.IsChecked
    })
    $WPFCheckbox_MindView7_Detail.Add_Checked({
        $WPFCheckbox_MindView7.IsChecked = $WPFCheckbox_MindView7_Detail.IsChecked
    })
    $WPFCheckbox_MindView7_Detail.Add_Unchecked({
        $WPFCheckbox_MindView7.IsChecked = $WPFCheckbox_MindView7_Detail.IsChecked
    })
    $WPFCheckbox_Firefox.Add_Checked({
        $WPFCheckbox_Firefox_Detail.IsChecked = $WPFCheckbox_Firefox.IsChecked
    })
    $WPFCheckbox_Firefox.Add_Unchecked({
        $WPFCheckbox_Firefox_Detail.IsChecked = $WPFCheckbox_Firefox.IsChecked
    })
    $WPFCheckbox_Firefox_Detail.Add_Checked({
        $WPFCheckbox_Firefox.IsChecked = $WPFCheckbox_Firefox_Detail.IsChecked
    })
    $WPFCheckbox_Firefox_Detail.Add_Unchecked({
        $WPFCheckbox_Firefox.IsChecked = $WPFCheckbox_Firefox_Detail.IsChecked
    })
    $WPFCheckbox_MozillaThunderbird.Add_Checked({
        $WPFCheckbox_MozillaThunderbird_Detail.IsChecked = $WPFCheckbox_MozillaThunderbird.IsChecked
    })
    $WPFCheckbox_MozillaThunderbird.Add_Unchecked({
        $WPFCheckbox_MozillaThunderbird_Detail.IsChecked = $WPFCheckbox_MozillaThunderbird.IsChecked
    })
    $WPFCheckbox_MozillaThunderbird_Detail.Add_Checked({
        $WPFCheckbox_MozillaThunderbird.IsChecked = $WPFCheckbox_MozillaThunderbird_Detail.IsChecked
    })
    $WPFCheckbox_MozillaThunderbird_Detail.Add_Unchecked({
        $WPFCheckbox_MozillaThunderbird.IsChecked = $WPFCheckbox_MozillaThunderbird_Detail.IsChecked
    })
    $WPFCheckbox_SumatraPDF.Add_Checked({
        $WPFCheckbox_SumatraPDF_Detail.IsChecked = $WPFCheckbox_SumatraPDF.IsChecked
    })
    $WPFCheckbox_SumatraPDF.Add_Unchecked({
        $WPFCheckbox_SumatraPDF_Detail.IsChecked = $WPFCheckbox_SumatraPDF.IsChecked
    })
    $WPFCheckbox_SumatraPDF_Detail.Add_Checked({
        $WPFCheckbox_SumatraPDF.IsChecked = $WPFCheckbox_SumatraPDF_Detail.IsChecked
    })
    $WPFCheckbox_SumatraPDF_Detail.Add_Unchecked({
        $WPFCheckbox_SumatraPDF.IsChecked = $WPFCheckbox_SumatraPDF_Detail.IsChecked
    })
    $WPFCheckbox_TechSmithSnagIt.Add_Checked({
        $WPFCheckbox_TechSmithSnagIt_Detail.IsChecked = $WPFCheckbox_TechSmithSnagIt.IsChecked
    })
    $WPFCheckbox_TechSmithSnagIt.Add_Unchecked({
        $WPFCheckbox_TechSmithSnagIt_Detail.IsChecked = $WPFCheckbox_TechSmithSnagIt.IsChecked
    })
    $WPFCheckbox_TechSmithSnagIt_Detail.Add_Checked({
        $WPFCheckbox_TechSmithSnagIt.IsChecked = $WPFCheckbox_TechSmithSnagIt_Detail.IsChecked
    })
    $WPFCheckbox_TechSmithSnagIt_Detail.Add_Unchecked({
        $WPFCheckbox_TechSmithSnagIt.IsChecked = $WPFCheckbox_TechSmithSnagIt_Detail.IsChecked
    })
    $WPFCheckbox_NotepadPlusPlus.Add_Checked({
        $WPFCheckbox_NotepadPlusPlus_Detail.IsChecked = $WPFCheckbox_NotepadPlusPlus.IsChecked
    })
    $WPFCheckbox_NotepadPlusPlus.Add_Unchecked({
        $WPFCheckbox_NotepadPlusPlus_Detail.IsChecked = $WPFCheckbox_NotepadPlusPlus.IsChecked
    })
    $WPFCheckbox_NotepadPlusPlus_Detail.Add_Checked({
        $WPFCheckbox_NotepadPlusPlus.IsChecked = $WPFCheckbox_NotepadPlusPlus_Detail.IsChecked
    })
    $WPFCheckbox_NotepadPlusPlus_Detail.Add_Unchecked({
        $WPFCheckbox_NotepadPlusPlus.IsChecked = $WPFCheckbox_NotepadPlusPlus_Detail.IsChecked
    })
    $WPFCheckbox_OpenJDK.Add_Checked({
        $WPFCheckbox_OpenJDK_Detail.IsChecked = $WPFCheckbox_OpenJDK.IsChecked
    })
    $WPFCheckbox_OpenJDK.Add_Unchecked({
        $WPFCheckbox_OpenJDK_Detail.IsChecked = $WPFCheckbox_OpenJDK.IsChecked
    })
    $WPFCheckbox_OpenJDK_Detail.Add_Checked({
        $WPFCheckbox_OpenJDK.IsChecked = $WPFCheckbox_OpenJDK_Detail.IsChecked
    })
    $WPFCheckbox_OpenJDK_Detail.Add_Unchecked({
        $WPFCheckbox_OpenJDK.IsChecked = $WPFCheckbox_OpenJDK_Detail.IsChecked
    })
    $WPFCheckbox_OpenWebStart.Add_Checked({
        $WPFCheckbox_OpenWebStart_Detail.IsChecked = $WPFCheckbox_OpenWebStart.IsChecked
    })
    $WPFCheckbox_OpenWebStart.Add_Unchecked({
        $WPFCheckbox_OpenWebStart_Detail.IsChecked = $WPFCheckbox_OpenWebStart.IsChecked
    })
    $WPFCheckbox_OpenWebStart_Detail.Add_Checked({
        $WPFCheckbox_OpenWebStart.IsChecked = $WPFCheckbox_OpenWebStart_Detail.IsChecked
    })
    $WPFCheckbox_OpenWebStart_Detail.Add_Unchecked({
        $WPFCheckbox_OpenWebStart.IsChecked = $WPFCheckbox_OpenWebStart_Detail.IsChecked
    })
    $WPFCheckbox_OperaBrowser.Add_Checked({
        $WPFCheckbox_OperaBrowser_Detail.IsChecked = $WPFCheckbox_OperaBrowser.IsChecked
    })
    $WPFCheckbox_OperaBrowser.Add_Unchecked({
        $WPFCheckbox_OperaBrowser_Detail.IsChecked = $WPFCheckbox_OperaBrowser.IsChecked
    })
    $WPFCheckbox_OperaBrowser_Detail.Add_Checked({
        $WPFCheckbox_OperaBrowser.IsChecked = $WPFCheckbox_OperaBrowser_Detail.IsChecked
    })
    $WPFCheckbox_OperaBrowser_Detail.Add_Unchecked({
        $WPFCheckbox_OperaBrowser.IsChecked = $WPFCheckbox_OperaBrowser_Detail.IsChecked
    })
    $WPFCheckbox_OracleJava8.Add_Checked({
        $WPFCheckbox_OracleJava8_Detail.IsChecked = $WPFCheckbox_OracleJava8.IsChecked
    })
    $WPFCheckbox_OracleJava8.Add_Unchecked({
        $WPFCheckbox_OracleJava8_Detail.IsChecked = $WPFCheckbox_OracleJava8.IsChecked
    })
    $WPFCheckbox_OracleJava8_Detail.Add_Checked({
        $WPFCheckbox_OracleJava8.IsChecked = $WPFCheckbox_OracleJava8_Detail.IsChecked
    })
    $WPFCheckbox_OracleJava8_Detail.Add_Unchecked({
        $WPFCheckbox_OracleJava8.IsChecked = $WPFCheckbox_OracleJava8_Detail.IsChecked
    })
    $WPFCheckbox_PaintDotNet.Add_Checked({
        $WPFCheckbox_PaintDotNet_Detail.IsChecked = $WPFCheckbox_PaintDotNet.IsChecked
    })
    $WPFCheckbox_PaintDotNet.Add_Unchecked({
        $WPFCheckbox_PaintDotNet_Detail.IsChecked = $WPFCheckbox_PaintDotNet.IsChecked
    })
    $WPFCheckbox_PaintDotNet_Detail.Add_Checked({
        $WPFCheckbox_PaintDotNet.IsChecked = $WPFCheckbox_PaintDotNet_Detail.IsChecked
    })
    $WPFCheckbox_PaintDotNet_Detail.Add_Unchecked({
        $WPFCheckbox_PaintDotNet.IsChecked = $WPFCheckbox_PaintDotNet_Detail.IsChecked
    })
    $WPFCheckbox_PeaZip.Add_Checked({
        $WPFCheckbox_PeaZip_Detail.IsChecked = $WPFCheckbox_PeaZip.IsChecked
    })
    $WPFCheckbox_PeaZip.Add_Unchecked({
        $WPFCheckbox_PeaZip_Detail.IsChecked = $WPFCheckbox_PeaZip.IsChecked
    })
    $WPFCheckbox_PeaZip_Detail.Add_Checked({
        $WPFCheckbox_PeaZip.IsChecked = $WPFCheckbox_PeaZip_Detail.IsChecked
    })
    $WPFCheckbox_PeaZip_Detail.Add_Unchecked({
        $WPFCheckbox_PeaZip.IsChecked = $WPFCheckbox_PeaZip_Detail.IsChecked
    })
    $WPFCheckbox_Putty.Add_Checked({
        $WPFCheckbox_Putty_Detail.IsChecked = $WPFCheckbox_Putty.IsChecked
    })
    $WPFCheckbox_Putty.Add_Unchecked({
        $WPFCheckbox_Putty_Detail.IsChecked = $WPFCheckbox_Putty.IsChecked
    })
    $WPFCheckbox_Putty_Detail.Add_Checked({
        $WPFCheckbox_Putty.IsChecked = $WPFCheckbox_Putty_Detail.IsChecked
    })
    $WPFCheckbox_Putty_Detail.Add_Unchecked({
        $WPFCheckbox_Putty.IsChecked = $WPFCheckbox_Putty_Detail.IsChecked
    })
    $WPFCheckbox_Slack.Add_Checked({
        $WPFCheckbox_Slack_Detail.IsChecked = $WPFCheckbox_Slack.IsChecked
    })
    $WPFCheckbox_Slack.Add_Unchecked({
        $WPFCheckbox_Slack_Detail.IsChecked = $WPFCheckbox_Slack.IsChecked
    })
    $WPFCheckbox_Slack_Detail.Add_Checked({
        $WPFCheckbox_Slack.IsChecked = $WPFCheckbox_Slack_Detail.IsChecked
    })
    $WPFCheckbox_Slack_Detail.Add_Unchecked({
        $WPFCheckbox_Slack.IsChecked = $WPFCheckbox_Slack_Detail.IsChecked
    })
    $WPFCheckbox_TotalCommander.Add_Checked({
        $WPFCheckbox_TotalCommander_Detail.IsChecked = $WPFCheckbox_TotalCommander.IsChecked
    })
    $WPFCheckbox_TotalCommander.Add_Unchecked({
        $WPFCheckbox_TotalCommander_Detail.IsChecked = $WPFCheckbox_TotalCommander.IsChecked
    })
    $WPFCheckbox_TotalCommander_Detail.Add_Checked({
        $WPFCheckbox_TotalCommander.IsChecked = $WPFCheckbox_TotalCommander_Detail.IsChecked
    })
    $WPFCheckbox_TotalCommander_Detail.Add_Unchecked({
        $WPFCheckbox_TotalCommander.IsChecked = $WPFCheckbox_TotalCommander_Detail.IsChecked
    })
    $WPFCheckbox_TeamViewer.Add_Checked({
        $WPFCheckbox_TeamViewer_Detail.IsChecked = $WPFCheckbox_TeamViewer.IsChecked
    })
    $WPFCheckbox_TeamViewer.Add_Unchecked({
        $WPFCheckbox_TeamViewer_Detail.IsChecked = $WPFCheckbox_TeamViewer.IsChecked
    })
    $WPFCheckbox_TeamViewer_Detail.Add_Checked({
        $WPFCheckbox_TeamViewer.IsChecked = $WPFCheckbox_TeamViewer_Detail.IsChecked
    })
    $WPFCheckbox_TeamViewer_Detail.Add_Unchecked({
        $WPFCheckbox_TeamViewer.IsChecked = $WPFCheckbox_TeamViewer_Detail.IsChecked
    })
    $WPFCheckbox_VLCPlayer.Add_Checked({
        $WPFCheckbox_VLCPlayer_Detail.IsChecked = $WPFCheckbox_VLCPlayer.IsChecked
    })
    $WPFCheckbox_VLCPlayer.Add_Unchecked({
        $WPFCheckbox_VLCPlayer_Detail.IsChecked = $WPFCheckbox_VLCPlayer.IsChecked
    })
    $WPFCheckbox_VLCPlayer_Detail.Add_Checked({
        $WPFCheckbox_VLCPlayer.IsChecked = $WPFCheckbox_VLCPlayer_Detail.IsChecked
    })
    $WPFCheckbox_VLCPlayer_Detail.Add_Unchecked({
        $WPFCheckbox_VLCPlayer.IsChecked = $WPFCheckbox_VLCPlayer_Detail.IsChecked
    })
    $WPFCheckbox_VMwareTools.Add_Checked({
        $WPFCheckbox_VMwareTools_Detail.IsChecked = $WPFCheckbox_VMwareTools.IsChecked
    })
    $WPFCheckbox_VMwareTools.Add_Unchecked({
        $WPFCheckbox_VMwareTools_Detail.IsChecked = $WPFCheckbox_VMwareTools.IsChecked
    })
    $WPFCheckbox_VMwareTools_Detail.Add_Checked({
        $WPFCheckbox_VMwareTools.IsChecked = $WPFCheckbox_VMwareTools_Detail.IsChecked
    })
    $WPFCheckbox_VMwareTools_Detail.Add_Unchecked({
        $WPFCheckbox_VMwareTools.IsChecked = $WPFCheckbox_VMwareTools_Detail.IsChecked
    })
    $WPFCheckbox_WinMerge.Add_Checked({
        $WPFCheckbox_WinMerge_Detail.IsChecked = $WPFCheckbox_WinMerge.IsChecked
    })
    $WPFCheckbox_WinMerge.Add_Unchecked({
        $WPFCheckbox_WinMerge_Detail.IsChecked = $WPFCheckbox_WinMerge.IsChecked
    })
    $WPFCheckbox_WinMerge_Detail.Add_Checked({
        $WPFCheckbox_WinMerge.IsChecked = $WPFCheckbox_WinMerge_Detail.IsChecked
    })
    $WPFCheckbox_WinMerge_Detail.Add_Unchecked({
        $WPFCheckbox_WinMerge.IsChecked = $WPFCheckbox_WinMerge_Detail.IsChecked
    })
    $WPFCheckbox_WinRAR.Add_Checked({
        $WPFCheckbox_WinRAR_Detail.IsChecked = $WPFCheckbox_WinRAR.IsChecked
    })
    $WPFCheckbox_WinRAR.Add_Unchecked({
        $WPFCheckbox_WinRAR_Detail.IsChecked = $WPFCheckbox_WinRAR.IsChecked
    })
    $WPFCheckbox_WinRAR_Detail.Add_Checked({
        $WPFCheckbox_WinRAR.IsChecked = $WPFCheckbox_WinRAR_Detail.IsChecked
    })
    $WPFCheckbox_WinRAR_Detail.Add_Unchecked({
        $WPFCheckbox_WinRAR.IsChecked = $WPFCheckbox_WinRAR_Detail.IsChecked
    })
    $WPFCheckbox_Wireshark.Add_Checked({
        $WPFCheckbox_Wireshark_Detail.IsChecked = $WPFCheckbox_Wireshark.IsChecked
    })
    $WPFCheckbox_Wireshark.Add_Unchecked({
        $WPFCheckbox_Wireshark_Detail.IsChecked = $WPFCheckbox_Wireshark.IsChecked
    })
    $WPFCheckbox_Wireshark_Detail.Add_Checked({
        $WPFCheckbox_Wireshark.IsChecked = $WPFCheckbox_Wireshark_Detail.IsChecked
    })
    $WPFCheckbox_Wireshark_Detail.Add_Unchecked({
        $WPFCheckbox_Wireshark.IsChecked = $WPFCheckbox_Wireshark_Detail.IsChecked
    })
    $WPFCheckbox_Zoom.Add_Checked({
        $WPFCheckbox_Zoom_Detail.IsChecked = $WPFCheckbox_Zoom.IsChecked
    })
    $WPFCheckbox_Zoom.Add_Unchecked({
        $WPFCheckbox_Zoom_Detail.IsChecked = $WPFCheckbox_Zoom.IsChecked
    })
    $WPFCheckbox_Zoom_Detail.Add_Checked({
        $WPFCheckbox_Zoom.IsChecked = $WPFCheckbox_Zoom_Detail.IsChecked
    })
    $WPFCheckbox_Zoom_Detail.Add_Unchecked({
        $WPFCheckbox_Zoom.IsChecked = $WPFCheckbox_Zoom_Detail.IsChecked
    })

    # Checkbox SelectAll (AddScript)
    $WPFCheckbox_SelectAll.Add_Checked({
        $WPFCheckbox_7Zip.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdobeProDC.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdobeReaderDC.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_BISF.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixHypervisorTools.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixWorkspaceApp.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Filezilla.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Firefox.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_FoxitReader.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GoogleChrome.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Greenshot.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_IrfanView.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_KeePass.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_mRemoteNG.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MS365Apps.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSEdge.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSFSLogix.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSOffice.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSOneDrive.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSTeams.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_NotePadPlusPlus.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenJDK.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenShellMenu.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OracleJava8.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TreeSize.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_VLCPlayer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_VMwareTools.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinSCP.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_deviceTRUST.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSDotNetFramework.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerShell.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_RemoteDesktopManager.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Slack.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ShareX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Zoom.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Putty.IsChecked = $WPFCheckbox_SelectAll.Ischecked
        $WPFCheckbox_PaintDotNet.IsChecked = $WPFCheckbox_SelectAll.Ischecked
        $WPFCheckbox_MSVisualStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSVisualStudioCode.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerToys.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GIMP.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TeamViewer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Wireshark.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAzureDataStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ImageGlass.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpEdgeDX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_1Password.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpAgent.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpConsole.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSSQLServerManagementStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAVDRemoteDesktop.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerBIDesktop.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_RDAnalyzer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_SumatraPDF.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CiscoWebexTeams.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixFiles.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_FoxitPDFEditor.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GitForWindows.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_LogMeInGoToMeeting.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAzureCLI.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerBIReportBuilder.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSSysinternals.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Nmap.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PeaZip.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TechSmithCamtasia.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TechSmithSnagIt.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinMerge.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSEdgeWebView2.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AutodeskDWGTrueView.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MindView7.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDFsam.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDFForgeCreator.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TotalCommander.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MozillaThunderbird.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDF24Creator.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinRAR.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Ditto.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OperaBrowser.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_XCA.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpRemoteDX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_IISCrypto.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Screenpresso.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSTeamsNew.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MobaXterm.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdoptOpenJDK.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Bloomberg.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GoogleDrive.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_JabraDirect.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenWebStart.IsChecked = $WPFCheckbox_SelectAll.IsChecked
    })

    # Checkbox SelectAll to Uncheck (AddScript)
    $WPFCheckbox_SelectAll.Add_Unchecked({
        $WPFCheckbox_7Zip.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdobeProDC.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdobeReaderDC.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_BISF.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixHypervisorTools.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixWorkspaceApp.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Filezilla.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Firefox.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_FoxitReader.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GoogleChrome.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Greenshot.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_IrfanView.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_KeePass.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_mRemoteNG.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MS365Apps.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSEdge.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSFSLogix.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSOffice.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSOneDrive.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSTeams.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_NotePadPlusPlus.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenJDK.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OracleJava8.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TreeSize.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_VLCPlayer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_VMwareTools.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinSCP.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_deviceTRUST.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSDotNetFramework.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerShell.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_RemoteDesktopManager.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Slack.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ShareX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Zoom.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Putty.IsChecked = $WPFCheckbox_SelectAll.Ischecked
        $WPFCheckbox_PaintDotNet.IsChecked = $WPFCheckbox_SelectAll.Ischecked
        $WPFCheckbox_MSVisualStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSVisualStudioCode.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerToys.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GIMP.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TeamViewer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Wireshark.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAzureDataStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ImageGlass.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpEdgeDX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_1Password.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpAgent.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpConsole.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSSQLServerManagementStudio.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAVDRemoteDesktop.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerBIDesktop.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_RDAnalyzer.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_SumatraPDF.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CiscoWebexTeams.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_CitrixFiles.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_FoxitPDFEditor.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GitForWindows.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_LogMeInGoToMeeting.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSAzureCLI.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSPowerBIReportBuilder.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSSysinternals.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Nmap.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PeaZip.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TechSmithCamtasia.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TechSmithSnagIt.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinMerge.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSEdgeWebView2.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AutodeskDWGTrueView.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MindView7.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDFsam.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenShellMenu.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDFForgeCreator.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_TotalCommander.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSVisualCPlusPlusRuntime.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MozillaThunderbird.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_PDF24Creator.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_WinRAR.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Ditto.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OperaBrowser.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_XCA.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_ControlUpRemoteDX.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_IISCrypto.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Screenpresso.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_AdoptOpenJDK.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_Bloomberg.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_GoogleDrive.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_JabraDirect.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_OpenWebStart.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MSTeamsNew.IsChecked = $WPFCheckbox_SelectAll.IsChecked
        $WPFCheckbox_MobaXterm.IsChecked = $WPFCheckbox_SelectAll.IsChecked
    })

    # Button Browse
    $WPFButton_Browse.Add_Click({
        Show-OpenFileDialog
    })

    # Button Start (AddScript)
    $WPFButton_Start.Add_Click({
        If ($WPFCheckbox_Download.IsChecked -eq $True) {$Script:Download = 1}
        Else {$Script:Download = 0}
        If ($WPFCheckbox_Install.IsChecked -eq $True) {$Script:Install = 1}
        Else {$Script:Install = 0}
        If ($WPFCheckbox_7Zip.IsChecked -eq $true) {$Script:7ZIP = 1}
        Else {$Script:7ZIP = 0}
        If ($WPFCheckbox_AdobeProDC.IsChecked -eq $true) {$Script:AdobeProDC = 1}
        Else {$Script:AdobeProDC = 0}
        If ($WPFCheckbox_AdobeReaderDC.IsChecked -eq $true) {$Script:AdobeReaderDC = 1}
        Else {$Script:AdobeReaderDC = 0}
        If ($WPFCheckbox_BISF.IsChecked -eq $true) {$Script:BISF = 1}
        Else {$Script:BISF = 0}
        If ($WPFCheckbox_CitrixHypervisorTools.IsChecked -eq $true) {$Script:Citrix_Hypervisor_Tools = 1}
        Else {$Script:Citrix_Hypervisor_Tools = 0}
        If ($WPFCheckbox_CitrixWorkspaceApp.IsChecked -eq $true) {$Script:Citrix_WorkspaceApp = 1}
        Else {$Script:Citrix_WorkspaceApp = 0}
        If ($WPFCheckbox_Filezilla.IsChecked -eq $true) {$Script:Filezilla = 1}
        Else {$Script:Filezilla = 0}
        If ($WPFCheckbox_Firefox.IsChecked -eq $true) {$Script:Firefox = 1}
        Else {$Script:Firefox = 0}
        If ($WPFCheckbox_MSFSLogix.IsChecked -eq $true) {$Script:MSFSLogix = 1}
        Else {$Script:MSFSLogix = 0}
        If ($WPFCheckbox_FoxitReader.Ischecked -eq $true) {$Script:Foxit_Reader = 1}
        Else {$Script:Foxit_Reader = 0}
        If ($WPFCheckbox_GoogleChrome.ischecked -eq $true) {$Script:GoogleChrome = 1}
        Else {$Script:GoogleChrome = 0}
        If ($WPFCheckbox_Greenshot.ischecked -eq $true) {$Script:Greenshot = 1}
        Else {$Script:Greenshot = 0}
        If ($WPFCheckbox_IrfanView.ischecked -eq $true) {$Script:IrfanView = 1}
        Else {$Script:IrfanView = 0}
        If ($WPFCheckbox_KeePass.ischecked -eq $true) {$Script:KeePass = 1}
        Else {$Script:KeePass = 0}
        If ($WPFCheckbox_mRemoteNG.ischecked -eq $true) {$Script:mRemoteNG = 1}
        Else {$Script:mRemoteNG = 0}
        If ($WPFCheckbox_MS365Apps.ischecked -eq $true) {$Script:MS365Apps = 1}
        Else {$Script:MS365Apps = 0}
        If ($WPFCheckbox_MSEdge.ischecked -eq $true) {$Script:MSEdge = 1}
        Else {$Script:MSEdge = 0}
        If ($WPFCheckbox_MSEdgeWebView2.ischecked -eq $true) {$Script:MSEdgeWebView2 = 1}
        Else {$Script:MSEdgeWebView2 = 0}
        If ($WPFCheckbox_MSOffice.ischecked -eq $true) {$Script:MSOffice = 1}
        Else {$Script:MSOffice = 0}
        If ($WPFCheckbox_MSOneDrive.ischecked -eq $true) {$Script:MSOneDrive = 1}
        Else {$Script:MSOneDrive = 0}
        If ($WPFCheckbox_MSTeams.ischecked -eq $true) {$Script:MSTeams = 1}
        Else {$Script:MSTeams = 0}
        If ($WPFCheckbox_NotePadPlusPlus.ischecked -eq $true) {$Script:NotePadPlusPlus = 1}
        Else {$Script:NotePadPlusPlus = 0}
        If ($WPFCheckbox_OpenJDK.ischecked -eq $true) {$Script:OpenJDK = 1}
        Else {$Script:OpenJDK = 0}
        If ($WPFCheckbox_OracleJava8.ischecked -eq $true) {$Script:OracleJava8 = 1}
        Else {$Script:OracleJava8 = 0}
        If ($WPFCheckbox_TreeSize.ischecked -eq $true) {$Script:TreeSize = 1}
        Else {$Script:TreeSize = 0}
        If ($WPFCheckbox_VLCPlayer.ischecked -eq $true) {$Script:VLCPlayer = 1}
        Else {$Script:VLCPlayer = 0}
        If ($WPFCheckbox_VMwareTools.ischecked -eq $true) {$Script:VMwareTools = 1}
        Else {$Script:VMwareTools = 0}
        If ($WPFCheckbox_WinSCP.ischecked -eq $true) {$Script:WinSCP = 1}
        Else {$Script:WinSCP = 0}        
        If ($WPFCheckbox_MSTeams_No_AutoStart.ischecked -eq $true) {$Script:MSTeamsNoAutoStart = 1}
        Else {$Script:MSTeamsNoAutoStart = 0}
        If ($WPFCheckbox_deviceTRUST.ischecked -eq $true) {$Script:deviceTRUST = 1}
        Else {$Script:deviceTRUST = 0}
        If ($WPFCheckbox_MSDotNetFramework.ischecked -eq $true) {$Script:MSDotNetFramework = 1}
        Else {$Script:MSDotNetFramework = 0}
        If ($WPFCheckbox_MSPowerShell.ischecked -eq $true) {$Script:MSPowerShell = 1}
        Else {$Script:MSPowerShell = 0}
        If ($WPFCheckbox_RemoteDesktopManager.ischecked -eq $true) {$Script:RemoteDesktopManager = 1}
        Else {$Script:RemoteDesktopManager = 0}
        If ($WPFCheckbox_Slack.ischecked -eq $true) {$Script:Slack = 1}
        Else {$Script:Slack = 0}
        If ($WPFCheckbox_ShareX.ischecked -eq $true) {$Script:ShareX = 1}
        Else {$Script:ShareX = 0}
        If ($WPFCheckbox_Zoom.ischecked -eq $true) {$Script:Zoom = 1}
        Else {$Script:Zoom = 0}
        If ($WPFCheckbox_GIMP.ischecked -eq $true) {$Script:GIMP = 1}
        Else {$Script:GIMP = 0}
        If ($WPFCheckbox_MSPowerToys.ischecked -eq $true) {$Script:MSPowerToys = 1}
        Else {$Script:MSPowerToys = 0}
        If ($WPFCheckbox_MSVisualStudio.ischecked -eq $true) {$Script:MSVisualStudio = 1}
        Else {$Script:MSVisualStudio = 0}
        If ($WPFCheckbox_MSVisualStudioCode.ischecked -eq $true) {$Script:MSVisualStudioCode = 1}
        Else {$Script:MSVisualStudioCode = 0}
        If ($WPFCheckbox_PaintDotNet.ischecked -eq $true) {$Script:PaintDotNet = 1}
        Else {$Script:PaintDotNet = 0}
        If ($WPFCheckbox_Putty.ischecked -eq $true) {$Script:Putty = 1}
        Else {$Script:Putty = 0}
        If ($WPFCheckbox_TeamViewer.ischecked -eq $true) {$Script:TeamViewer = 1}
        Else {$Script:TeamViewer = 0}
        If ($WPFCheckbox_Wireshark.ischecked -eq $true) {$Script:Wireshark = 1}
        Else {$Script:Wireshark = 0}
        If ($WPFCheckbox_MSAzureDataStudio.ischecked -eq $true) {$Script:MSAzureDataStudio = 1}
        Else {$Script:MSAzureDataStudio = 0}
        If ($WPFCheckbox_ImageGlass.ischecked -eq $true) {$Script:ImageGlass = 1}
        Else {$Script:ImageGlass = 0}
        If ($WPFCheckbox_ControlUpEdgeDX.ischecked -eq $true) {$Script:ControlUpEdgeDX = 1}
        Else {$Script:ControlUpEdgeDX = 0}
        If ($WPFCheckbox_1Password.ischecked -eq $true) {$Script:1Password = 1}
        Else {$Script:1Password = 0}
        If ($WPFCheckbox_ControlUpAgent.ischecked -eq $true) {$Script:ControlUpAgent = 1}
        Else {$Script:ControlUpAgent = 0}
        If ($WPFCheckbox_ControlUpConsole.ischecked -eq $true) {$Script:ControlUpConsole = 1}
        Else {$Script:ControlUpConsole = 0}
        If ($WPFCheckbox_MSSQLServerManagementStudio.ischecked -eq $true) {$Script:MSSQLServerManagementStudio = 1}
        Else {$Script:MSSQLServerManagementStudio = 0}
        If ($WPFCheckbox_MSAVDRemoteDesktop.ischecked -eq $true) {$Script:MSAVDRemoteDesktop = 1}
        Else {$Script:MSAVDRemoteDesktop = 0}
        If ($WPFCheckbox_MSPowerBIDesktop.ischecked -eq $true) {$Script:MSPowerBIDesktop = 1}
        Else {$Script:MSPowerBIDesktop = 0}
        If ($WPFCheckbox_RDAnalyzer.ischecked -eq $true) {$Script:RDAnalyzer = 1}
        Else {$Script:RDAnalyzer = 0}
        If ($WPFCheckbox_SumatraPDF.ischecked -eq $true) {$Script:SumatraPDF = 1}
        Else {$Script:SumatraPDF = 0}
        If ($WPFCheckbox_CiscoWebexTeams.ischecked -eq $true) {$Script:CiscoWebexTeams = 1}
        Else {$Script:CiscoWebexTeams = 0}
        If ($WPFCheckbox_CitrixFiles.ischecked -eq $true) {$Script:CitrixFiles = 1}
        Else {$Script:CitrixFiles = 0}
        If ($WPFCheckbox_FoxitPDFEditor.ischecked -eq $true) {$Script:FoxitPDFEditor = 1}
        Else {$Script:FoxitPDFEditor = 0}
        If ($WPFCheckbox_GitForWindows.ischecked -eq $true) {$Script:GitForWindows = 1}
        Else {$Script:GitForWindows = 0}
        If ($WPFCheckbox_LogMeInGoToMeeting.ischecked -eq $true) {$Script:LogMeInGoToMeeting = 1}
        Else {$Script:LogMeInGoToMeeting = 0}
        If ($WPFCheckbox_MSAzureCLI.ischecked -eq $true) {$Script:MSAzureCLI = 1}
        Else {$Script:MSAzureCLI = 0}
        If ($WPFCheckbox_MSPowerBIReportBuilder.ischecked -eq $true) {$Script:MSPowerBIReportBuilder = 1}
        Else {$Script:MSPowerBIReportBuilder = 0}
        If ($WPFCheckbox_MSSysinternals.ischecked -eq $true) {$Script:MSSysinternals = 1}
        Else {$Script:MSSysinternals = 0}
        If ($WPFCheckbox_Nmap.ischecked -eq $true) {$Script:Nmap = 1}
        Else {$Script:Nmap = 0}
        If ($WPFCheckbox_PeaZip.ischecked -eq $true) {$Script:PeaZip = 1}
        Else {$Script:PeaZip = 0}
        If ($WPFCheckbox_TechSmithCamtasia.ischecked -eq $true) {$Script:TechSmithCamtasia = 1}
        Else {$Script:TechSmithCamtasia = 0}
        If ($WPFCheckbox_TechSmithSnagIt.ischecked -eq $true) {$Script:TechSmithSnagIt = 1}
        Else {$Script:TechSmithSnagIt = 0}
        If ($WPFCheckbox_WinMerge.ischecked -eq $true) {$Script:WinMerge = 1}
        Else {$Script:WinMerge = 0}
        If ($WPFCheckbox_WhatIf.ischecked -eq $true) {$Script:WhatIf = 1}
        Else {$Script:WhatIf = 0}
        If ($WPFCheckbox_CleanUp.ischecked -eq $true) {$Script:CleanUp = 1}
        Else {$Script:CleanUp = 0}
        If ($WPFCheckbox_MS365Apps_Visio_Detail.ischecked -eq $true) {$Script:MS365Apps_Visio = 1}
        Else {$Script:MS365Apps_Visio = 0}
        If ($WPFCheckbox_MS365Apps_Project_Detail.ischecked -eq $true) {$Script:MS365Apps_Project = 1}
        Else {$Script:MS365Apps_Project = 0}
        If ($WPFCheckbox_AutodeskDWGTrueView.ischecked -eq $true) {$Script:AutodeskDWGTrueView = 1}
        Else {$Script:AutodeskDWGTrueView = 0}
        If ($WPFCheckbox_MindView7.ischecked -eq $true) {$Script:MindView7 = 1}
        Else {$Script:MindView7 = 0}
        If ($WPFCheckbox_PDFsam.ischecked -eq $true) {$Script:PDFsam = 1}
        Else {$Script:PDFsam = 0}
        If ($WPFCheckbox_OpenShellMenu.ischecked -eq $true) {$Script:OpenShellMenu = 1}
        Else {$Script:OpenShellMenu = 0}
        If ($WPFCheckbox_PDFForgeCreator.ischecked -eq $true) {$Script:PDFForgeCreator = 1}
        Else {$Script:PDFForgeCreator = 0}
        If ($WPFCheckbox_TotalCommander.ischecked -eq $true) {$Script:TotalCommander = 1}
        Else {$Script:TotalCommander = 0}
        If ($WPFCheckbox_Repository.ischecked -eq $true) {$Script:Repository = 1}
        Else {$Script:Repository = 0}
        If ($WPFCheckbox_CleanUpStartMenu.ischecked -eq $true) {$Script:CleanUpStartMenu = 1}
        Else {$Script:CleanUpStartMenu = 0}
        If ($WPFCheckbox_MSVisualCPlusPlusRuntime.ischecked -eq $true) {$Script:MSVisualCPlusPlusRuntime = 1}
        Else {$Script:MSVisualCPlusPlusRuntime = 0}
        If ($WPFCheckbox_MSOffice_Visio_Detail.ischecked -eq $true) {$Script:MSOffice_Visio = 1}
        Else {$Script:MSOffice_Visio = 0}
        If ($WPFCheckbox_MSOffice_Project_Detail.ischecked -eq $true) {$Script:MSOffice_Project = 1}
        Else {$Script:MSOffice_Project = 0}
        If ($WPFCheckbox_MozillaThunderbird.ischecked -eq $true) {$Script:MozillaThunderbird = 1}
        Else {$Script:MozillaThunderbird = 0}
        If ($WPFCheckbox_PDF24Creator.ischecked -eq $true) {$Script:PDF24Creator = 1}
        Else {$Script:PDF24Creator = 0}
        If ($WPFCheckbox_WinRAR.ischecked -eq $true) {$Script:WinRAR = 1}
        Else {$Script:WinRAR = 0}
        If ($WPFCheckbox_Ditto.ischecked -eq $true) {$Script:Ditto = 1}
        Else {$Script:Ditto = 0}
        If ($WPFCheckbox_OperaBrowser.ischecked -eq $true) {$Script:OperaBrowser = 1}
        Else {$Script:OperaBrowser = 0}
        If ($WPFCheckbox_XCA.ischecked -eq $true) {$Script:XCA = 1}
        Else {$Script:XCA = 0}
        If ($WPFCheckbox_IISCrypto.ischecked -eq $true) {$Script:IISCrypto = 1}
        Else {$Script:IISCrypto = 0}
        If ($WPFCheckbox_Screenpresso.ischecked -eq $true) {$Script:Screenpresso = 1}
        Else {$Script:Screenpresso = 0}
        If ($WPFCheckbox_ControlUpRemoteDX.ischecked -eq $true) {$Script:ControlUpRemoteDX = 1}
        Else {$Script:ControlUpRemoteDX = 0}
        If ($WPFCheckbox_Report.ischecked -eq $true) {$Script:Report = 1}
        Else {$Script:Report = 0}
        If ($WPFCheckbox_NoDesktopIcon.ischecked -eq $true) {$Script:NoDesktopIcon = 1}
        Else {$Script:NoDesktopIcon = 0}
        If ($WPFCheckbox_MSTeamsAVD.ischecked -eq $true) {$Script:MSTeamsAVD = 1}
        Else {$Script:MSTeamsAVD = 0}
        If ($WPFCheckbox_AdoptOpenJDK.ischecked -eq $true) {$Script:AdoptOpenJDK = 1}
        Else {$Script:AdoptOpenJDK = 0}
        If ($WPFCheckbox_Bloomberg.ischecked -eq $true) {$Script:Bloomberg = 1}
        Else {$Script:Bloomberg = 0}
        If ($WPFCheckbox_GoogleDrive.ischecked -eq $true) {$Script:GoogleDrive = 1}
        Else {$Script:GoogleDrive = 0}
        If ($WPFCheckbox_JabraDirect.ischecked -eq $true) {$Script:JabraDirect = 1}
        Else {$Script:JabraDirect = 0}
        If ($WPFCheckbox_AdoptOpenJDKIcedTeaWeb.ischecked -eq $true) {$Script:AdoptOpenJDKIcedTeaWeb = 1}
        Else {$Script:AdoptOpenJDKIcedTeaWeb = 0}
        If ($WPFCheckbox_OpenWebStart.ischecked -eq $true) {$Script:OpenWebStart = 1}
        Else {$Script:OpenWebStart = 0}
        If ($WPFCheckbox_WindowsUpdate.ischecked -eq $true) {$Script:WindowsUpdate = 1}
        Else {$Script:WindowsUpdate = 0}
        If ($WPFCheckbox_MSTeamsNew.ischecked -eq $true) {$Script:MSTeamsNew = 1}
        Else {$Script:MSTeamsNew = 0}
        If ($WPFCheckbox_MSTeamsAVDNew.ischecked -eq $true) {$Script:MSTeamsAVDNew = 1}
        Else {$Script:MSTeamsAVDNew = 0}
        If ($WPFCheckbox_MobaXterm.ischecked -eq $true) {$Script:MobaXterm = 1}
        Else {$Script:MobaXterm = 0}
        $Script:Language = $WPFBox_Language.SelectedIndex
        $Script:Architecture = $WPFBox_Architecture.SelectedIndex
        $Script:Installer = $WPFBox_Installer.SelectedIndex
        $Script:FirefoxChannel = $WPFBox_Firefox.SelectedIndex
        $Script:CitrixWorkspaceAppRelease = $WPFBox_CitrixWorkspaceApp.SelectedIndex
        $Script:MS365AppsChannel = $WPFBox_MS365Apps.SelectedIndex
        $Script:MSOneDriveRing = $WPFBox_MSOneDrive.SelectedIndex
        $Script:MSTeamsRing = $WPFBox_MSTeams.SelectedIndex
        $Script:TreeSizeType = $WPFBox_TreeSize.SelectedIndex
        $Script:MSDotNetFrameworkChannel = $WPFBox_MSDotNetFramework.SelectedIndex
        $Script:MSPowerShellRelease = $WPFBox_MSPowerShell.SelectedIndex
        $Script:RemoteDesktopManagerType = $WPFBox_RemoteDesktopManager.SelectedIndex
        $Script:ZoomCitrixClient = $WPFBox_Zoom.SelectedIndex
        $Script:deviceTRUSTPackage = $WPFBox_deviceTRUST.SelectedIndex
        $Script:MSEdgeChannel = $WPFBox_MSEdge.SelectedIndex
        $Script:MSVisualStudioCodeChannel = $WPFBox_MSVisualStudioCode.SelectedIndex
        $Script:MSVisualStudioEdition = $WPFBox_MSVisualStudio.SelectedIndex
        $Script:PuttyChannel = $WPFBox_Putty.SelectedIndex
        $Script:MSAzureDataStudioChannel = $WPFBox_MSAzureDataStudio.SelectedIndex
        $Script:MSFSLogixChannel = $WPFBox_MSFSLogix.SelectedIndex
        $Script:OperaBrowserChannel = $WPFBox_OperaBrowser.SelectedIndex
        $Script:MSAVDRemoteDesktopChannel = $WPFBox_MSAVDRemoteDesktop.SelectedIndex
        $Script:7Zip_Architecture = $WPFBox_7Zip_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Architecture = $WPFBox_AdobeReaderDC_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Language = $WPFBox_AdobeReaderDC_Language.SelectedIndex
        $Script:CiscoWebexTeams_Architecture = $WPFBox_CiscoWebexTeams_Architecture.SelectedIndex
        $Script:CitrixHypervisorTools_Architecture = $WPFBox_CitrixHypervisorTools_Architecture.SelectedIndex
        $Script:ControlUpAgent_Architecture = $WPFBox_ControlUpAgent_Architecture.SelectedIndex
        $Script:deviceTRUST_Architecture = $WPFBox_deviceTRUST_Architecture.SelectedIndex
        $Script:FoxitPDFEditor_Language = $WPFBox_FoxitPDFEditor_Language.SelectedIndex
        $Script:FoxitReader_Language = $WPFBox_FoxitReader_Language.SelectedIndex
        $Script:GitForWindows_Architecture = $WPFBox_GitForWindows_Architecture.SelectedIndex
        $Script:GoogleChrome_Architecture = $WPFBox_GoogleChrome_Architecture.SelectedIndex
        $Script:ImageGlass_Architecture = $WPFBox_ImageGlass_Architecture.SelectedIndex
        $Script:IrfanView_Architecture = $WPFBox_IrfanView_Architecture.SelectedIndex
        $Script:Keepass_Language = $WPFBox_KeePass_Language.SelectedIndex
        $Script:MSDotNetFramework_Architecture = $WPFBox_MSDotNetFramework_Architecture.SelectedIndex
        $Script:MS365Apps_Architecture = $WPFBox_MS365Apps_Architecture.SelectedIndex
        $Script:MS365Apps_Language = $WPFBox_MS365Apps_Language.SelectedIndex
        $Script:MS365Apps_Visio_Language = $WPFBox_MS365Apps_Visio_Language.SelectedIndex
        $Script:MS365Apps_Project_Language = $WPFBox_MS365Apps_Project_Language.SelectedIndex
        $Script:MSAVDRemoteDesktop_Architecture = $WPFBox_MSAVDRemoteDesktop_Architecture.SelectedIndex
        $Script:MSEdge_Architecture = $WPFBox_MSEdge_Architecture.SelectedIndex
        $Script:MSFSLogix_Architecture = $WPFBox_MSFSLogix_Architecture.SelectedIndex
        $Script:MSOffice_Architecture = $WPFBox_MSOffice_Architecture.SelectedIndex
        $Script:MSOneDrive_Architecture = $WPFBox_MSOneDrive_Architecture.SelectedIndex
        $Script:MSPowerBIDesktop_Architecture = $WPFBox_MSPowerBIDesktop_Architecture.SelectedIndex
        $Script:MSPowerShell_Architecture = $WPFBox_MSPowerShell_Architecture.SelectedIndex
        $Script:MSSQLServerManagementStudio_Language = $WPFBox_MSSQLServerManagementStudio_Language.SelectedIndex
        $Script:MSTeams_Architecture = $WPFBox_MSTeams_Architecture.SelectedIndex
        $Script:MSVisualStudioCode_Architecture = $WPFBox_MSVisualStudioCode_Architecture.SelectedIndex
        $Script:Firefox_Architecture = $WPFBox_Firefox_Architecture.SelectedIndex
        $Script:Firefox_Language = $WPFBox_Firefox_Language.SelectedIndex
        $Script:NotePadPlusPlus_Architecture = $WPFBox_NotepadPlusPlus_Architecture.SelectedIndex
        $Script:OpenJDK_Architecture = $WPFBox_OpenJDK_Architecture.SelectedIndex
        $Script:OracleJava8_Architecture = $WPFBox_OracleJava8_Architecture.SelectedIndex
        $Script:PeaZip_Architecture = $WPFBox_PeaZip_Architecture.SelectedIndex
        $Script:Putty_Architecture = $WPFBox_Putty_Architecture.SelectedIndex
        $Script:Slack_Architecture = $WPFBox_Slack_Architecture.SelectedIndex
        $Script:SumatraPDF_Architecture = $WPFBox_SumatraPDF_Architecture.SelectedIndex
        $Script:TechSmithSnagIt_Architecture = $WPFBox_TechSmithSnagIT_Architecture.SelectedIndex
        $Script:VLCPlayer_Architecture = $WPFBox_VLCPlayer_Architecture.SelectedIndex
        $Script:VMwareTools_Architecture = $WPFBox_VMwareTools_Architecture.SelectedIndex
        $Script:WinMerge_Architecture = $WPFBox_WinMerge_Architecture.SelectedIndex
        $Script:Wireshark_Architecture = $WPFBox_Wireshark_Architecture.SelectedIndex
        $Script:IrfanView_Language = $WPFBox_IrfanView_Language.SelectedIndex
        $Script:MSOffice_Language = $WPFBox_MSOffice_Language.SelectedIndex
        $Script:MS365Apps_Path = $WPFTextBox_Filename.Text
        $Script:MSEdgeWebView2_Architecture = $WPFBox_MSEdgeWebView2_Architecture.SelectedIndex
        $Script:MindView7_Language = $WPFBox_MindView7_Language.SelectedIndex
        $Script:MSOfficeVersion = $WPFBox_MSOffice.SelectedIndex
        $Script:LogMeInGoToMeeting_Installer = $WPFBox_LogMeInGoToMeeting_Installer.SelectedIndex
        $Script:MSAzureDataStudio_Installer = $WPFBox_MSAzureDataStudio_Installer.SelectedIndex
        $Script:MSVisualStudioCode_Installer = $WPFBox_MSVisualStudioCode_Installer.SelectedIndex
        $Script:MS365Apps_Installer = $WPFBox_MS365Apps_Installer.SelectedIndex
        $Script:MSTeams_Installer = $WPFBox_MSTeams_Installer.SelectedIndex
        $Script:Zoom_Installer = $WPFBox_Zoom_Installer.SelectedIndex
        $Script:MSOneDrive_Installer = $WPFBox_MSOneDrive_Installer.SelectedIndex
        $Script:Slack_Installer = $WPFBox_Slack_Installer.SelectedIndex
        $Script:pdfforgePDFCreatorChannel = $WPFBox_pdfforgePDFCreator.SelectedIndex
        $Script:TotalCommander_Architecture = $WPFBox_TotalCommander_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntime_Architecture = $WPFBox_MSVisualCPlusPlusRuntime_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntimeRelease = $WPFBox_MSVisualCPlusPlusRuntime.SelectedIndex
        $Script:MSOffice_Visio_Language = $WPFBox_MSOffice_Visio_Language.SelectedIndex
        $Script:MSOffice_Project_Language = $WPFBox_MSOffice_Project_Language.SelectedIndex
        $Script:Zoom_Architecture = $WPFBox_Zoom_Architecture.SelectedIndex
        $Script:CiscoWebexTeamsClient = $WPFBox_CiscoWebexTeams.SelectedIndex
        $Script:AdobeProDC_Architecture = $WPFBox_AdobeProDC_Architecture.SelectedIndex
        $Script:GoogleChromeChannel = $WPFBox_GoogleChrome.SelectedIndex
        $Script:OpenJDKPackage = $WPFBox_OpenJDK.SelectedIndex
        $Script:PaintDotNet_Architecture = $WPFBox_PaintDotNet_Architecture.SelectedIndex
        $Script:WinRAR_Architecture = $WPFBox_WinRAR_Architecture.SelectedIndex
        $Script:WinRAR_Language = $WPFBox_WinRAR_Language.SelectedIndex
        $Script:WinRARChannel = $WPFBox_WinRAR.SelectedIndex
        $Script:MozillaThunderbird_Architecture = $WPFBox_MozillaThunderbird_Architecture.SelectedIndex
        $Script:MozillaThunderbird_Language = $WPFBox_MozillaThunderbird_Language.SelectedIndex
        $Script:MSAzureDataStudio_Architecture = $WPFBox_MSAzureDataStudio_Architecture.SelectedIndex
        $Script:TeamViewer_Architecture = $WPFBox_TeamViewer_Architecture.SelectedIndex
        $Script:Ditto_Architecture = $WPFBox_Ditto_Architecture.SelectedIndex
        $Script:Ditto_Channel = $WPFBox_Ditto.SelectedIndex
        $Script:OperaBrowser_Architecture = $WPFBox_OperaBrowser_Architecture.SelectedIndex
        $Script:ControlUpEdgeDX_Installer = $WPFBox_ControlUpEdgeDX_Installer.SelectedIndex
        $Script:BISF_Tools = $WPFBox_BISF_Tools.SelectedIndex
        $Script:ControlUpRemoteDXEUC = $WPFBox_ControlUpRemoteDX.SelectedIndex
        $Script:ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        $Script:ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $Script:ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        $Script:AdoptOpenJDKVersion = $WPFBox_AdoptOpenJDK.SelectedIndex
        $Script:AdoptOpenJDK_Architecture = $WPFBox_AdoptOpenJDK_Architecture.SelectedIndex
        $Script:OpenWebStart_Architecture = $WPFBox_OpenWebStart_Architecture.SelectedIndex
        $Script:MSTeamsNew_Architecture = $WPFBox_MSTeamsNew_Architecture.SelectedIndex

        # Write LastSetting.txt or -GUIFile Parameter file to get the settings of the last session. (AddScript)
        $Language,$Architecture,$CitrixWorkspaceAppRelease,$MS365AppsChannel,$MSOneDriveRing,$MSTeamsRing,$FirefoxChannel,$TreeSizeType,$7ZIP,$AdobeProDC,$AdobeReaderDC,$BISF,$Citrix_Hypervisor_Tools,$Citrix_WorkspaceApp,$Filezilla,$Firefox,$Foxit_Reader,$MSFSLogix,$GoogleChrome,$Greenshot,$KeePass,$mRemoteNG,$MS365Apps,$MSEdge,$MSOffice,$MSOneDrive,$MSTeams,$NotePadPlusPlus,$OpenJDK,$OracleJava8,$TreeSize,$VLCPlayer,$VMwareTools,$WinSCP,$Download,$Install,$IrfanView,$MSTeamsNoAutoStart,$deviceTRUST,$MSDotNetFramework,$MSDotNetFrameworkChannel,$MSPowerShell,$MSPowerShellRelease,$RemoteDesktopManager,$RemoteDesktopManagerType,$Slack,$Wireshark,$ShareX,$Zoom,$ZoomCitrixClient,$deviceTRUSTPackage,$MSEdgeChannel,$GIMP,$MSPowerToys,$MSVisualStudio,$MSVisualStudioCode,$MSVisualStudioCodeChannel,$PaintDotNet,$Putty,$TeamViewer,$Installer,$MSVisualStudioEdition,$PuttyChannel,$MSAzureDataStudio,$MSAzureDataStudioChannel,$ImageGlass,$MSFSLogixChannel,$ControlUpEdgeDX,$1Password,$SumatraPDF,$ControlUpAgent,$OperaBrowserChannel,$ControlUpConsole,$MSSQLServerManagementStudio,$MSAVDRemoteDesktop,$MSAVDRemoteDesktopChannel,$MSPowerBIDesktop,$RDAnalyzer,$CiscoWebexTeams,$CitrixFiles,$FoxitPDFEditor,$GitForWindows,$LogMeInGoToMeeting,$MSAzureCLI,$MSPowerBIReportBuilder,$MSSysinternals,$NMap,$PeaZip,$TechSmithCamtasia,$TechSmithSnagit,$WinMerge,$WhatIf,$CleanUp,$7Zip_Architecture,$AdobeReaderDC_Architecture,$AdobeReaderDC_Language,$CiscoWebexTeams_Architecture,$CitrixHypervisorTools_Architecture,$ControlUpAgent_Architecture,$deviceTRUST_Architecture,$FoxitPDFEditor_Language,$FoxitReader_Language,$GitForWindows_Architecture,$GoogleChrome_Architecture,$ImageGlass_Architecture,$IrfanView_Architecture,$Keepass_Language,$MSDotNetFramework_Architecture,$MS365Apps_Architecture,$MS365Apps_Language,$MS365Apps_Visio,$MS365Apps_Visio_Language,$MS365Apps_Project,$MS365Apps_Project_Language,$MSAVDRemoteDesktop_Architecture,$MSEdge_Architecture,$MSFSLogix_Architecture,$MSOffice_Architecture,$MSOneDrive_Architecture,$MSPowerBIDesktop_Architecture,$MSPowerShell_Architecture,$MSSQLServerManagementStudio_Language,$MSTeams_Architecture,$MSVisualStudioCode_Architecture,$Firefox_Architecture,$Firefox_Language,$NotePadPlusPlus_Architecture,$OpenJDK_Architecture,$OracleJava8_Architecture,$PeaZip_Architecture,$Putty_Architecture,$Slack_Architecture,$SumatraPDF_Architecture,$TechSmithSnagIt_Architecture,$VLCPlayer_Architecture,$VMwareTools_Architecture,$WinMerge_Architecture,$Wireshark_Architecture,$IrfanView_Language,$MSOffice_Language,$MSEdgeWebView2,$MSEdgeWebView2_Architecture,$AutodeskDWGTrueView,$MindView7,$MindView7_Language,$PDFsam,$MSOfficeVersion,$OpenShellMenu,$PDFForgeCreator,$TotalCommander,$LogMeInGoToMeeting_Installer,$MSAzureDataStudio_Installer,$MSVisualStudioCode_Installer,$MS365Apps_Installer,$Zoom_Architecture,$MSTeams_Installer,$Zoom_Installer,$MSOneDrive_Installer,$Slack_Installer,$pdfforgePDFCreatorChannel,$TotalCommander_Architecture,$Repository,$CleanUpStartMenu,$MSVisualCPlusPlusRuntime,$MSVisualCPlusPlusRuntimeRelease,$MSVisualCPlusPlusRuntime_Architecture,$MSOffice_Visio,$MSOffice_Visio_Language,$MSOffice_Project,$MSOffice_Project_Language,$CiscoWebexTeamsClient,$BISF_Tools,$MozillaThunderbird,$PDF24Creator,$WinRAR,$AdobeProDC_Architecture,$GoogleChromeChannel,$OpenJDKPackage,$PaintDotNet_Architecture,$WinRAR_Architecture,$WinRAR_Language,$WinRARChannel,$MozillaThunderbird_Architecture,$MozillaThunderbird_Language,$MSAzureDataStudio_Architecture,$TeamViewer_Architecture,$OperaBrowser,$OperaBrowser_Architecture,$Ditto,$Ditto_Architecture,$Ditto_Channel,$XCA,$ControlUpEdgeDX_Installer,$ControlUpRemoteDX,$IISCrypto,$Screenpresso,$Report,$NoDesktopIcon,$ControlUpRemoteDXEUC,$MSTeamsAVD,$AdoptOpenJDK,$AdoptOpenJDKVersion,$Bloomberg,$GoogleDrive,$JabraDirect,$AdoptOpenJDKIcedTeaWeb,$OpenWebStart,$AdoptOpenJDK_Architecture,$OpenWebStart_Architecture,$WindowsUpdate,$MSTeamsNew,$MSTeamsAVDNew,$MobaXterm,$MSTeamsNew_Architecture | out-file -filepath "$PSScriptRoot\$GUIfile"

        # Write ControlUp data in the files.
        $ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Agent")) {New-Item -Path "$PSScriptRoot\ControlUp Agent" -ItemType Directory | Out-Null}
        $ControlUpAgentAuthKey | out-file -filepath "$PSScriptRoot\ControlUp Agent\AuthKey.txt"
        $ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager")) {New-Item -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager" -ItemType Directory | Out-Null}
        $ControlUpEdgeDXDevRegCode | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt"
        $ControlUpEdgeDXTenantName | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt"

        If ($MS365Apps_Path -ne "") {
            If ($WhatIf -eq '0') {
                If ($MS365Apps -eq 1) {
                    Switch ($MS365AppsChannel) {
                        0 { $MS365AppsChannelClear = 'Beta Channel'}
                        1 { $MS365AppsChannelClear = 'Current Channel (Preview)'}
                        2 { $MS365AppsChannelClear = 'Current Channel'}
                        3 { $MS365AppsChannelClear = 'Semi-Annual Channel (Preview)'}
                        4 { $MS365AppsChannelClear = 'Monthly Enterprise Channel'}
                        5 { $MS365AppsChannelClear = 'Semi-Annual Channel'}
                    }
                    If (!(Test-Path -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear")) {New-Item -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear\install.xml" -Force
                    Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft 365 Apps $MS365AppsChannelClear folder."
                    Write-Output ""
                }
                If ($MSOffice -eq 1) {
                    Switch ($MSOfficeVersion) {
                        0 { $MSOfficeChannelClear = '2019'}
                        1 { $MSOfficeChannelClear = '2021 LTSC'}
                    }
                    $OfficePath = "Microsoft Office " + $MSOfficeChannelClear
                    If (!(Test-Path -Path "$PSScriptRoot\$OfficePath")) {New-Item -Path "$PSScriptRoot\$OfficePath" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\$OfficePath\install.xml" -Force
                }
                Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft Office $MSOfficeChannelClear folder."
                Write-Output ""
            }
        }
        # Shortcut Creation
        $Desktop = [Environment]::GetFolderPath([Environment+SpecialFolder]::Desktop)
        If ($NoDesktopIcon -eq "0"){
            If ((Test-Path -Path "$Desktop\Evergreen Script.lnk")) {
                Remove-Item "$Desktop\Evergreen Script.lnk"
            }
            If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                $sh = New-Object -ComObject WScript.Shell
                $target = $sh.CreateShortcut("$Desktop\NeverRed.lnk").TargetPath
                If ($target -ne "$env:ProgramFiles\PowerShell\7") {
                    Remove-Item "$Desktop\NeverRed.lnk"
                } 
            }
            If (!(Test-Path -Path "$Desktop\NeverRed.lnk")) {
                $WScriptShell = New-Object -ComObject 'WScript.Shell'
                $ShortcutFile = "$Desktop\NeverRed.lnk"
                $Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
                If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                    $Shortcut.TargetPath = '"C:\Program Files\PowerShell\7\pwsh.exe"'
                    $Shortcut.WorkingDirectory = '"C:\Program Files\PowerShell\7\"' 
                } else {
                    $Shortcut.TargetPath = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
                    $Shortcut.WorkingDirectory = "C:\Windows\System32\WindowsPowerShell\v1.0"
                }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut")) { New-Item -Path "$PSScriptRoot\shortcut" -ItemType Directory | Out-Null }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut\NeverRed.ico")) {Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/shortcut/NeverRed.ico -OutFile ("$PSScriptRoot\shortcut\" + "NeverRed.ico")}
                $shortcut.IconLocation="$PSScriptRoot\shortcut\NeverRed.ico"
                $Shortcut.Arguments = '-noexit -ExecutionPolicy Bypass -file "' + "$PSScriptRoot" + '\NeverRed.ps1"'
                $Shortcut.Save()
                $Admin = [System.IO.File]::ReadAllBytes("$ShortcutFile")
                $Admin[0x15] = $Admin[0x15] -bor 0x20
                [System.IO.File]::WriteAllBytes("$ShortcutFile", $Admin)
            }
        }
        Write-Host "GUI Mode"
        $Form.Close()
    })

    # Button Start Detail (AddScript)
    $WPFButton_Start_Detail.Add_Click({
        If ($WPFCheckbox_Download.IsChecked -eq $True) {$Script:Download = 1}
        Else {$Script:Download = 0}
        If ($WPFCheckbox_Install.IsChecked -eq $True) {$Script:Install = 1}
        Else {$Script:Install = 0}
        If ($WPFCheckbox_7Zip.IsChecked -eq $true) {$Script:7ZIP = 1}
        Else {$Script:7ZIP = 0}
        If ($WPFCheckbox_AdobeProDC.IsChecked -eq $true) {$Script:AdobeProDC = 1}
        Else {$Script:AdobeProDC = 0}
        If ($WPFCheckbox_AdobeReaderDC.IsChecked -eq $true) {$Script:AdobeReaderDC = 1}
        Else {$Script:AdobeReaderDC = 0}
        If ($WPFCheckbox_BISF.IsChecked -eq $true) {$Script:BISF = 1}
        Else {$Script:BISF = 0}
        If ($WPFCheckbox_CitrixHypervisorTools.IsChecked -eq $true) {$Script:Citrix_Hypervisor_Tools = 1}
        Else {$Script:Citrix_Hypervisor_Tools = 0}
        If ($WPFCheckbox_CitrixWorkspaceApp.IsChecked -eq $true) {$Script:Citrix_WorkspaceApp = 1}
        Else {$Script:Citrix_WorkspaceApp = 0}
        If ($WPFCheckbox_Filezilla.IsChecked -eq $true) {$Script:Filezilla = 1}
        Else {$Script:Filezilla = 0}
        If ($WPFCheckbox_Firefox.IsChecked -eq $true) {$Script:Firefox = 1}
        Else {$Script:Firefox = 0}
        If ($WPFCheckbox_MSFSLogix.IsChecked -eq $true) {$Script:MSFSLogix = 1}
        Else {$Script:MSFSLogix = 0}
        If ($WPFCheckbox_FoxitReader.Ischecked -eq $true) {$Script:Foxit_Reader = 1}
        Else {$Script:Foxit_Reader = 0}
        If ($WPFCheckbox_GoogleChrome.ischecked -eq $true) {$Script:GoogleChrome = 1}
        Else {$Script:GoogleChrome = 0}
        If ($WPFCheckbox_Greenshot.ischecked -eq $true) {$Script:Greenshot = 1}
        Else {$Script:Greenshot = 0}
        If ($WPFCheckbox_IrfanView.ischecked -eq $true) {$Script:IrfanView = 1}
        Else {$Script:IrfanView = 0}
        If ($WPFCheckbox_KeePass.ischecked -eq $true) {$Script:KeePass = 1}
        Else {$Script:KeePass = 0}
        If ($WPFCheckbox_mRemoteNG.ischecked -eq $true) {$Script:mRemoteNG = 1}
        Else {$Script:mRemoteNG = 0}
        If ($WPFCheckbox_MS365Apps.ischecked -eq $true) {$Script:MS365Apps = 1}
        Else {$Script:MS365Apps = 0}
        If ($WPFCheckbox_MSEdge.ischecked -eq $true) {$Script:MSEdge = 1}
        Else {$Script:MSEdge = 0}
        If ($WPFCheckbox_MSEdgeWebView2.ischecked -eq $true) {$Script:MSEdgeWebView2 = 1}
        Else {$Script:MSEdgeWebView2 = 0}
        If ($WPFCheckbox_MSOffice.ischecked -eq $true) {$Script:MSOffice = 1}
        Else {$Script:MSOffice = 0}
        If ($WPFCheckbox_MSOneDrive.ischecked -eq $true) {$Script:MSOneDrive = 1}
        Else {$Script:MSOneDrive = 0}
        If ($WPFCheckbox_MSTeams.ischecked -eq $true) {$Script:MSTeams = 1}
        Else {$Script:MSTeams = 0}
        If ($WPFCheckbox_NotePadPlusPlus.ischecked -eq $true) {$Script:NotePadPlusPlus = 1}
        Else {$Script:NotePadPlusPlus = 0}
        If ($WPFCheckbox_OpenJDK.ischecked -eq $true) {$Script:OpenJDK = 1}
        Else {$Script:OpenJDK = 0}
        If ($WPFCheckbox_OracleJava8.ischecked -eq $true) {$Script:OracleJava8 = 1}
        Else {$Script:OracleJava8 = 0}
        If ($WPFCheckbox_TreeSize.ischecked -eq $true) {$Script:TreeSize = 1}
        Else {$Script:TreeSize = 0}
        If ($WPFCheckbox_VLCPlayer.ischecked -eq $true) {$Script:VLCPlayer = 1}
        Else {$Script:VLCPlayer = 0}
        If ($WPFCheckbox_VMwareTools.ischecked -eq $true) {$Script:VMwareTools = 1}
        Else {$Script:VMwareTools = 0}
        If ($WPFCheckbox_WinSCP.ischecked -eq $true) {$Script:WinSCP = 1}
        Else {$Script:WinSCP = 0}        
        If ($WPFCheckbox_MSTeams_No_AutoStart.ischecked -eq $true) {$Script:MSTeamsNoAutoStart = 1}
        Else {$Script:MSTeamsNoAutoStart = 0}
        If ($WPFCheckbox_deviceTRUST.ischecked -eq $true) {$Script:deviceTRUST = 1}
        Else {$Script:deviceTRUST = 0}
        If ($WPFCheckbox_MSDotNetFramework.ischecked -eq $true) {$Script:MSDotNetFramework = 1}
        Else {$Script:MSDotNetFramework = 0}
        If ($WPFCheckbox_MSPowerShell.ischecked -eq $true) {$Script:MSPowerShell = 1}
        Else {$Script:MSPowerShell = 0}
        If ($WPFCheckbox_RemoteDesktopManager.ischecked -eq $true) {$Script:RemoteDesktopManager = 1}
        Else {$Script:RemoteDesktopManager = 0}
        If ($WPFCheckbox_Slack.ischecked -eq $true) {$Script:Slack = 1}
        Else {$Script:Slack = 0}
        If ($WPFCheckbox_ShareX.ischecked -eq $true) {$Script:ShareX = 1}
        Else {$Script:ShareX = 0}
        If ($WPFCheckbox_Zoom.ischecked -eq $true) {$Script:Zoom = 1}
        Else {$Script:Zoom = 0}
        If ($WPFCheckbox_GIMP.ischecked -eq $true) {$Script:GIMP = 1}
        Else {$Script:GIMP = 0}
        If ($WPFCheckbox_MSPowerToys.ischecked -eq $true) {$Script:MSPowerToys = 1}
        Else {$Script:MSPowerToys = 0}
        If ($WPFCheckbox_MSVisualStudio.ischecked -eq $true) {$Script:MSVisualStudio = 1}
        Else {$Script:MSVisualStudio = 0}
        If ($WPFCheckbox_MSVisualStudioCode.ischecked -eq $true) {$Script:MSVisualStudioCode = 1}
        Else {$Script:MSVisualStudioCode = 0}
        If ($WPFCheckbox_PaintDotNet.ischecked -eq $true) {$Script:PaintDotNet = 1}
        Else {$Script:PaintDotNet = 0}
        If ($WPFCheckbox_Putty.ischecked -eq $true) {$Script:Putty = 1}
        Else {$Script:Putty = 0}
        If ($WPFCheckbox_TeamViewer.ischecked -eq $true) {$Script:TeamViewer = 1}
        Else {$Script:TeamViewer = 0}
        If ($WPFCheckbox_Wireshark.ischecked -eq $true) {$Script:Wireshark = 1}
        Else {$Script:Wireshark = 0}
        If ($WPFCheckbox_MSAzureDataStudio.ischecked -eq $true) {$Script:MSAzureDataStudio = 1}
        Else {$Script:MSAzureDataStudio = 0}
        If ($WPFCheckbox_ImageGlass.ischecked -eq $true) {$Script:ImageGlass = 1}
        Else {$Script:ImageGlass = 0}
        If ($WPFCheckbox_ControlUpEdgeDX.ischecked -eq $true) {$Script:ControlUpEdgeDX = 1}
        Else {$Script:ControlUpEdgeDX = 0}
        If ($WPFCheckbox_1Password.ischecked -eq $true) {$Script:1Password = 1}
        Else {$Script:1Password = 0}
        If ($WPFCheckbox_ControlUpAgent.ischecked -eq $true) {$Script:ControlUpAgent = 1}
        Else {$Script:ControlUpAgent = 0}
        If ($WPFCheckbox_ControlUpConsole.ischecked -eq $true) {$Script:ControlUpConsole = 1}
        Else {$Script:ControlUpConsole = 0}
        If ($WPFCheckbox_MSSQLServerManagementStudio.ischecked -eq $true) {$Script:MSSQLServerManagementStudio = 1}
        Else {$Script:MSSQLServerManagementStudio = 0}
        If ($WPFCheckbox_MSAVDRemoteDesktop.ischecked -eq $true) {$Script:MSAVDRemoteDesktop = 1}
        Else {$Script:MSAVDRemoteDesktop = 0}
        If ($WPFCheckbox_MSPowerBIDesktop.ischecked -eq $true) {$Script:MSPowerBIDesktop = 1}
        Else {$Script:MSPowerBIDesktop = 0}
        If ($WPFCheckbox_RDAnalyzer.ischecked -eq $true) {$Script:RDAnalyzer = 1}
        Else {$Script:RDAnalyzer = 0}
        If ($WPFCheckbox_SumatraPDF.ischecked -eq $true) {$Script:SumatraPDF = 1}
        Else {$Script:SumatraPDF = 0}
        If ($WPFCheckbox_CiscoWebexTeams.ischecked -eq $true) {$Script:CiscoWebexTeams = 1}
        Else {$Script:CiscoWebexTeams = 0}
        If ($WPFCheckbox_CitrixFiles.ischecked -eq $true) {$Script:CitrixFiles = 1}
        Else {$Script:CitrixFiles = 0}
        If ($WPFCheckbox_FoxitPDFEditor.ischecked -eq $true) {$Script:FoxitPDFEditor = 1}
        Else {$Script:FoxitPDFEditor = 0}
        If ($WPFCheckbox_GitForWindows.ischecked -eq $true) {$Script:GitForWindows = 1}
        Else {$Script:GitForWindows = 0}
        If ($WPFCheckbox_LogMeInGoToMeeting.ischecked -eq $true) {$Script:LogMeInGoToMeeting = 1}
        Else {$Script:LogMeInGoToMeeting = 0}
        If ($WPFCheckbox_MSAzureCLI.ischecked -eq $true) {$Script:MSAzureCLI = 1}
        Else {$Script:MSAzureCLI = 0}
        If ($WPFCheckbox_MSPowerBIReportBuilder.ischecked -eq $true) {$Script:MSPowerBIReportBuilder = 1}
        Else {$Script:MSPowerBIReportBuilder = 0}
        If ($WPFCheckbox_MSSysinternals.ischecked -eq $true) {$Script:MSSysinternals = 1}
        Else {$Script:MSSysinternals = 0}
        If ($WPFCheckbox_Nmap.ischecked -eq $true) {$Script:Nmap = 1}
        Else {$Script:Nmap = 0}
        If ($WPFCheckbox_PeaZip.ischecked -eq $true) {$Script:PeaZip = 1}
        Else {$Script:PeaZip = 0}
        If ($WPFCheckbox_TechSmithCamtasia.ischecked -eq $true) {$Script:TechSmithCamtasia = 1}
        Else {$Script:TechSmithCamtasia = 0}
        If ($WPFCheckbox_TechSmithSnagIt.ischecked -eq $true) {$Script:TechSmithSnagIt = 1}
        Else {$Script:TechSmithSnagIt = 0}
        If ($WPFCheckbox_WinMerge.ischecked -eq $true) {$Script:WinMerge = 1}
        Else {$Script:WinMerge = 0}
        If ($WPFCheckbox_WhatIf.ischecked -eq $true) {$Script:WhatIf = 1}
        Else {$Script:WhatIf = 0}
        If ($WPFCheckbox_CleanUp.ischecked -eq $true) {$Script:CleanUp = 1}
        Else {$Script:CleanUp = 0}
        If ($WPFCheckbox_Repository.ischecked -eq $true) {$Script:Repository = 1}
        Else {$Script:Repository = 0}
        If ($WPFCheckbox_CleanUpStartMenu.ischecked -eq $true) {$Script:CleanUpStartMenu = 1}
        Else {$Script:CleanUpStartMenu = 0}
        If ($WPFCheckbox_MS365Apps_Visio_Detail.ischecked -eq $true) {$Script:MS365Apps_Visio = 1}
        Else {$Script:MS365Apps_Visio = 0}
        If ($WPFCheckbox_MS365Apps_Project_Detail.ischecked -eq $true) {$Script:MS365Apps_Project = 1}
        Else {$Script:MS365Apps_Project = 0}
        If ($WPFCheckbox_AutodeskDWGTrueView.ischecked -eq $true) {$Script:AutodeskDWGTrueView = 1}
        Else {$Script:AutodeskDWGTrueView = 0}
        If ($WPFCheckbox_MindView7.ischecked -eq $true) {$Script:MindView7 = 1}
        Else {$Script:MindView7 = 0}
        If ($WPFCheckbox_PDFsam.ischecked -eq $true) {$Script:PDFsam = 1}
        Else {$Script:PDFsam = 0}
        If ($WPFCheckbox_OpenShellMenu.ischecked -eq $true) {$Script:OpenShellMenu = 1}
        Else {$Script:OpenShellMenu = 0}
        If ($WPFCheckbox_PDFForgeCreator.ischecked -eq $true) {$Script:PDFForgeCreator = 1}
        Else {$Script:PDFForgeCreator = 0}
        If ($WPFCheckbox_TotalCommander.ischecked -eq $true) {$Script:TotalCommander = 1}
        Else {$Script:TotalCommander = 0}
        If ($WPFCheckbox_MSVisualCPlusPlusRuntime.ischecked -eq $true) {$Script:MSVisualCPlusPlusRuntime = 1}
        Else {$Script:MSVisualCPlusPlusRuntime = 0}
        If ($WPFCheckbox_MSOffice_Visio_Detail.ischecked -eq $true) {$Script:MSOffice_Visio = 1}
        Else {$Script:MSOffice_Visio = 0}
        If ($WPFCheckbox_MSOffice_Project_Detail.ischecked -eq $true) {$Script:MSOffice_Project = 1}
        Else {$Script:MSOffice_Project = 0}
        If ($WPFCheckbox_MozillaThunderbird.ischecked -eq $true) {$Script:MozillaThunderbird = 1}
        Else {$Script:MozillaThunderbird = 0}
        If ($WPFCheckbox_PDF24Creator.ischecked -eq $true) {$Script:PDF24Creator = 1}
        Else {$Script:PDF24Creator = 0}
        If ($WPFCheckbox_WinRAR.ischecked -eq $true) {$Script:WinRAR = 1}
        Else {$Script:WinRAR = 0}
        If ($WPFCheckbox_Ditto.ischecked -eq $true) {$Script:Ditto = 1}
        Else {$Script:Ditto = 0}
        If ($WPFCheckbox_OperaBrowser.ischecked -eq $true) {$Script:OperaBrowser = 1}
        Else {$Script:OperaBrowser = 0}
        If ($WPFCheckbox_XCA.ischecked -eq $true) {$Script:XCA = 1}
        Else {$Script:XCA = 0}
        If ($WPFCheckbox_IISCrypto.ischecked -eq $true) {$Script:IISCrypto = 1}
        Else {$Script:IISCrypto = 0}
        If ($WPFCheckbox_Screenpresso.ischecked -eq $true) {$Script:Screenpresso = 1}
        Else {$Script:Screenpresso = 0}
        If ($WPFCheckbox_ControlUpRemoteDX.ischecked -eq $true) {$Script:ControlUpRemoteDX = 1}
        Else {$Script:ControlUpRemoteDX = 0}
        If ($WPFCheckbox_Report.ischecked -eq $true) {$Script:Report = 1}
        Else {$Script:Report = 0}
        If ($WPFCheckbox_NoDesktopIcon.ischecked -eq $true) {$Script:NoDesktopIcon = 1}
        Else {$Script:NoDesktopIcon = 0}
        If ($WPFCheckbox_MSTeamsAVD.ischecked -eq $true) {$Script:MSTeamsAVD = 1}
        Else {$Script:MSTeamsAVD = 0}
        If ($WPFCheckbox_AdoptOpenJDK.ischecked -eq $true) {$Script:AdoptOpenJDK = 1}
        Else {$Script:AdoptOpenJDK = 0}
        If ($WPFCheckbox_Bloomberg.ischecked -eq $true) {$Script:Bloomberg = 1}
        Else {$Script:Bloomberg = 0}
        If ($WPFCheckbox_GoogleDrive.ischecked -eq $true) {$Script:GoogleDrive = 1}
        Else {$Script:GoogleDrive = 0}
        If ($WPFCheckbox_JabraDirect.ischecked -eq $true) {$Script:JabraDirect = 1}
        Else {$Script:JabraDirect = 0}
        If ($WPFCheckbox_AdoptOpenJDKIcedTeaWeb.ischecked -eq $true) {$Script:AdoptOpenJDKIcedTeaWeb = 1}
        Else {$Script:AdoptOpenJDKIcedTeaWeb = 0}
        If ($WPFCheckbox_OpenWebStart.ischecked -eq $true) {$Script:OpenWebStart = 1}
        Else {$Script:OpenWebStart = 0}
        If ($WPFCheckbox_WindowsUpdate.ischecked -eq $true) {$Script:WindowsUpdate = 1}
        Else {$Script:WindowsUpdate = 0}
        If ($WPFCheckbox_MSTeamsNew.ischecked -eq $true) {$Script:MSTeamsNew = 1}
        Else {$Script:MSTeamsNew = 0}
        If ($WPFCheckbox_MSTeamsAVDNew.ischecked -eq $true) {$Script:MSTeamsAVDNew = 1}
        Else {$Script:MSTeamsAVDNew = 0}
        If ($WPFCheckbox_MobaXterm.ischecked -eq $true) {$Script:MobaXterm = 1}
        Else {$Script:MobaXterm = 0}
        $Script:Language = $WPFBox_Language.SelectedIndex
        $Script:Architecture = $WPFBox_Architecture.SelectedIndex
        $Script:Installer = $WPFBox_Installer.SelectedIndex
        $Script:FirefoxChannel = $WPFBox_Firefox.SelectedIndex
        $Script:CitrixWorkspaceAppRelease = $WPFBox_CitrixWorkspaceApp.SelectedIndex
        $Script:MS365AppsChannel = $WPFBox_MS365Apps.SelectedIndex
        $Script:MSOneDriveRing = $WPFBox_MSOneDrive.SelectedIndex
        $Script:MSTeamsRing = $WPFBox_MSTeams.SelectedIndex
        $Script:TreeSizeType = $WPFBox_TreeSize.SelectedIndex
        $Script:MSDotNetFrameworkChannel = $WPFBox_MSDotNetFramework.SelectedIndex
        $Script:MSPowerShellRelease = $WPFBox_MSPowerShell.SelectedIndex
        $Script:RemoteDesktopManagerType = $WPFBox_RemoteDesktopManager.SelectedIndex
        $Script:ZoomCitrixClient = $WPFBox_Zoom.SelectedIndex
        $Script:deviceTRUSTPackage = $WPFBox_deviceTRUST.SelectedIndex
        $Script:MSEdgeChannel = $WPFBox_MSEdge.SelectedIndex
        $Script:MSVisualStudioCodeChannel = $WPFBox_MSVisualStudioCode.SelectedIndex
        $Script:MSVisualStudioEdition = $WPFBox_MSVisualStudio.SelectedIndex
        $Script:PuttyChannel = $WPFBox_Putty.SelectedIndex
        $Script:MSAzureDataStudioChannel = $WPFBox_MSAzureDataStudio.SelectedIndex
        $Script:MSFSLogixChannel = $WPFBox_MSFSLogix.SelectedIndex
        $Script:OperaBrowserChannel = $WPFBox_OperaBrowser.SelectedIndex
        $Script:MSAVDRemoteDesktopChannel = $WPFBox_MSAVDRemoteDesktop.SelectedIndex
        $Script:7Zip_Architecture = $WPFBox_7Zip_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Architecture = $WPFBox_AdobeReaderDC_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Language = $WPFBox_AdobeReaderDC_Language.SelectedIndex
        $Script:CiscoWebexTeams_Architecture = $WPFBox_CiscoWebexTeams_Architecture.SelectedIndex
        $Script:CitrixHypervisorTools_Architecture = $WPFBox_CitrixHypervisorTools_Architecture.SelectedIndex
        $Script:ControlUpAgent_Architecture = $WPFBox_ControlUpAgent_Architecture.SelectedIndex
        $Script:deviceTRUST_Architecture = $WPFBox_deviceTRUST_Architecture.SelectedIndex
        $Script:FoxitPDFEditor_Language = $WPFBox_FoxitPDFEditor_Language.SelectedIndex
        $Script:FoxitReader_Language = $WPFBox_FoxitReader_Language.SelectedIndex
        $Script:GitForWindows_Architecture = $WPFBox_GitForWindows_Architecture.SelectedIndex
        $Script:GoogleChrome_Architecture = $WPFBox_GoogleChrome_Architecture.SelectedIndex
        $Script:ImageGlass_Architecture = $WPFBox_ImageGlass_Architecture.SelectedIndex
        $Script:IrfanView_Architecture = $WPFBox_IrfanView_Architecture.SelectedIndex
        $Script:Keepass_Language = $WPFBox_KeePass_Language.SelectedIndex
        $Script:MSDotNetFramework_Architecture = $WPFBox_MSDotNetFramework_Architecture.SelectedIndex
        $Script:MS365Apps_Architecture = $WPFBox_MS365Apps_Architecture.SelectedIndex
        $Script:MS365Apps_Language = $WPFBox_MS365Apps_Language.SelectedIndex
        $Script:MS365Apps_Visio_Language = $WPFBox_MS365Apps_Visio_Language.SelectedIndex
        $Script:MS365Apps_Project_Language = $WPFBox_MS365Apps_Project_Language.SelectedIndex
        $Script:MSAVDRemoteDesktop_Architecture = $WPFBox_MSAVDRemoteDesktop_Architecture.SelectedIndex
        $Script:MSEdge_Architecture = $WPFBox_MSEdge_Architecture.SelectedIndex
        $Script:MSFSLogix_Architecture = $WPFBox_MSFSLogix_Architecture.SelectedIndex
        $Script:MSOffice_Architecture = $WPFBox_MSOffice_Architecture.SelectedIndex
        $Script:MSOneDrive_Architecture = $WPFBox_MSOneDrive_Architecture.SelectedIndex
        $Script:MSPowerBIDesktop_Architecture = $WPFBox_MSPowerBIDesktop_Architecture.SelectedIndex
        $Script:MSPowerShell_Architecture = $WPFBox_MSPowerShell_Architecture.SelectedIndex
        $Script:MSSQLServerManagementStudio_Language = $WPFBox_MSSQLServerManagementStudio_Language.SelectedIndex
        $Script:MSTeams_Architecture = $WPFBox_MSTeams_Architecture.SelectedIndex
        $Script:MSVisualStudioCode_Architecture = $WPFBox_MSVisualStudioCode_Architecture.SelectedIndex
        $Script:Firefox_Architecture = $WPFBox_Firefox_Architecture.SelectedIndex
        $Script:Firefox_Language = $WPFBox_Firefox_Language.SelectedIndex
        $Script:NotePadPlusPlus_Architecture = $WPFBox_NotepadPlusPlus_Architecture.SelectedIndex
        $Script:OpenJDK_Architecture = $WPFBox_OpenJDK_Architecture.SelectedIndex
        $Script:OracleJava8_Architecture = $WPFBox_OracleJava8_Architecture.SelectedIndex
        $Script:PeaZip_Architecture = $WPFBox_PeaZip_Architecture.SelectedIndex
        $Script:Putty_Architecture = $WPFBox_Putty_Architecture.SelectedIndex
        $Script:Slack_Architecture = $WPFBox_Slack_Architecture.SelectedIndex
        $Script:SumatraPDF_Architecture = $WPFBox_SumatraPDF_Architecture.SelectedIndex
        $Script:TechSmithSnagIt_Architecture = $WPFBox_TechSmithSnagIT_Architecture.SelectedIndex
        $Script:VLCPlayer_Architecture = $WPFBox_VLCPlayer_Architecture.SelectedIndex
        $Script:VMwareTools_Architecture = $WPFBox_VMwareTools_Architecture.SelectedIndex
        $Script:WinMerge_Architecture = $WPFBox_WinMerge_Architecture.SelectedIndex
        $Script:Wireshark_Architecture = $WPFBox_Wireshark_Architecture.SelectedIndex
        $Script:IrfanView_Language = $WPFBox_IrfanView_Language.SelectedIndex
        $Script:MSOffice_Language = $WPFBox_MSOffice_Language.SelectedIndex
        $Script:MS365Apps_Path = $WPFTextBox_Filename.Text
        $Script:MSEdgeWebView2_Architecture = $WPFBox_MSEdgeWebView2_Architecture.SelectedIndex
        $Script:MindView7_Language = $WPFBox_MindView7_Language.SelectedIndex
        $Script:MSOfficeVersion = $WPFBox_MSOffice.SelectedIndex
        $Script:LogMeInGoToMeeting_Installer = $WPFBox_LogMeInGoToMeeting_Installer.SelectedIndex
        $Script:MSAzureDataStudio_Installer = $WPFBox_MSAzureDataStudio_Installer.SelectedIndex
        $Script:MSVisualStudioCode_Installer = $WPFBox_MSVisualStudioCode_Installer.SelectedIndex
        $Script:MS365Apps_Installer = $WPFBox_MS365Apps_Installer.SelectedIndex
        $Script:MSTeams_Installer = $WPFBox_MSTeams_Installer.SelectedIndex
        $Script:Zoom_Installer = $WPFBox_Zoom_Installer.SelectedIndex
        $Script:MSOneDrive_Installer = $WPFBox_MSOneDrive_Installer.SelectedIndex
        $Script:Slack_Installer = $WPFBox_Slack_Installer.SelectedIndex
        $Script:pdfforgePDFCreatorChannel = $WPFBox_pdfforgePDFCreator.SelectedIndex
        $Script:TotalCommander_Architecture = $WPFBox_TotalCommander_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntime_Architecture = $WPFBox_MSVisualCPlusPlusRuntime_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntimeRelease = $WPFBox_MSVisualCPlusPlusRuntime.SelectedIndex
        $Script:MSOffice_Visio_Language = $WPFBox_MSOffice_Visio_Language.SelectedIndex
        $Script:MSOffice_Project_Language = $WPFBox_MSOffice_Project_Language.SelectedIndex
        $Script:Zoom_Architecture = $WPFBox_Zoom_Architecture.SelectedIndex
        $Script:CiscoWebexTeamsClient = $WPFBox_CiscoWebexTeams.SelectedIndex
        $Script:AdobeProDC_Architecture = $WPFBox_AdobeProDC_Architecture.SelectedIndex
        $Script:GoogleChromeChannel = $WPFBox_GoogleChrome.SelectedIndex
        $Script:OpenJDKPackage = $WPFBox_OpenJDK.SelectedIndex
        $Script:PaintDotNet_Architecture = $WPFBox_PaintDotNet_Architecture.SelectedIndex
        $Script:WinRAR_Architecture = $WPFBox_WinRAR_Architecture.SelectedIndex
        $Script:WinRAR_Language = $WPFBox_WinRAR_Language.SelectedIndex
        $Script:WinRARChannel = $WPFBox_WinRAR.SelectedIndex
        $Script:MozillaThunderbird_Architecture = $WPFBox_MozillaThunderbird_Architecture.SelectedIndex
        $Script:MozillaThunderbird_Language = $WPFBox_MozillaThunderbird_Language.SelectedIndex
        $Script:MSAzureDataStudio_Architecture = $WPFBox_MSAzureDataStudio_Architecture.SelectedIndex
        $Script:TeamViewer_Architecture = $WPFBox_TeamViewer_Architecture.SelectedIndex
        $Script:Ditto_Architecture = $WPFBox_Ditto_Architecture.SelectedIndex
        $Script:Ditto_Channel = $WPFBox_Ditto.SelectedIndex
        $Script:OperaBrowser_Architecture = $WPFBox_OperaBrowser_Architecture.SelectedIndex
        $Script:ControlUpEdgeDX_Installer = $WPFBox_ControlUpEdgeDX_Installer.SelectedIndex
        $Script:BISF_Tools = $WPFBox_BISF_Tools.SelectedIndex
        $Script:ControlUpRemoteDXEUC = $WPFBox_ControlUpRemoteDX.SelectedIndex
        $Script:ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        $Script:ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $Script:ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        $Script:AdoptOpenJDKVersion = $WPFBox_AdoptOpenJDK.SelectedIndex
        $Script:AdoptOpenJDK_Architecture = $WPFBox_AdoptOpenJDK_Architecture.SelectedIndex
        $Script:OpenWebStart_Architecture = $WPFBox_OpenWebStart_Architecture.SelectedIndex
        $Script:MSTeamsNew_Architecture = $WPFBox_MSTeamsNew_Architecture.SelectedIndex
        
        # Write LastSetting.txt or -GUIFile Parameter file to get the settings of the last session. (AddScript)
        $Language,$Architecture,$CitrixWorkspaceAppRelease,$MS365AppsChannel,$MSOneDriveRing,$MSTeamsRing,$FirefoxChannel,$TreeSizeType,$7ZIP,$AdobeProDC,$AdobeReaderDC,$BISF,$Citrix_Hypervisor_Tools,$Citrix_WorkspaceApp,$Filezilla,$Firefox,$Foxit_Reader,$MSFSLogix,$GoogleChrome,$Greenshot,$KeePass,$mRemoteNG,$MS365Apps,$MSEdge,$MSOffice,$MSOneDrive,$MSTeams,$NotePadPlusPlus,$OpenJDK,$OracleJava8,$TreeSize,$VLCPlayer,$VMwareTools,$WinSCP,$Download,$Install,$IrfanView,$MSTeamsNoAutoStart,$deviceTRUST,$MSDotNetFramework,$MSDotNetFrameworkChannel,$MSPowerShell,$MSPowerShellRelease,$RemoteDesktopManager,$RemoteDesktopManagerType,$Slack,$Wireshark,$ShareX,$Zoom,$ZoomCitrixClient,$deviceTRUSTPackage,$MSEdgeChannel,$GIMP,$MSPowerToys,$MSVisualStudio,$MSVisualStudioCode,$MSVisualStudioCodeChannel,$PaintDotNet,$Putty,$TeamViewer,$Installer,$MSVisualStudioEdition,$PuttyChannel,$MSAzureDataStudio,$MSAzureDataStudioChannel,$ImageGlass,$MSFSLogixChannel,$ControlUpEdgeDX,$1Password,$SumatraPDF,$ControlUpAgent,$OperaBrowserChannel,$ControlUpConsole,$MSSQLServerManagementStudio,$MSAVDRemoteDesktop,$MSAVDRemoteDesktopChannel,$MSPowerBIDesktop,$RDAnalyzer,$CiscoWebexTeams,$CitrixFiles,$FoxitPDFEditor,$GitForWindows,$LogMeInGoToMeeting,$MSAzureCLI,$MSPowerBIReportBuilder,$MSSysinternals,$NMap,$PeaZip,$TechSmithCamtasia,$TechSmithSnagit,$WinMerge,$WhatIf,$CleanUp,$7Zip_Architecture,$AdobeReaderDC_Architecture,$AdobeReaderDC_Language,$CiscoWebexTeams_Architecture,$CitrixHypervisorTools_Architecture,$ControlUpAgent_Architecture,$deviceTRUST_Architecture,$FoxitPDFEditor_Language,$FoxitReader_Language,$GitForWindows_Architecture,$GoogleChrome_Architecture,$ImageGlass_Architecture,$IrfanView_Architecture,$Keepass_Language,$MSDotNetFramework_Architecture,$MS365Apps_Architecture,$MS365Apps_Language,$MS365Apps_Visio,$MS365Apps_Visio_Language,$MS365Apps_Project,$MS365Apps_Project_Language,$MSAVDRemoteDesktop_Architecture,$MSEdge_Architecture,$MSFSLogix_Architecture,$MSOffice_Architecture,$MSOneDrive_Architecture,$MSPowerBIDesktop_Architecture,$MSPowerShell_Architecture,$MSSQLServerManagementStudio_Language,$MSTeams_Architecture,$MSVisualStudioCode_Architecture,$Firefox_Architecture,$Firefox_Language,$NotePadPlusPlus_Architecture,$OpenJDK_Architecture,$OracleJava8_Architecture,$PeaZip_Architecture,$Putty_Architecture,$Slack_Architecture,$SumatraPDF_Architecture,$TechSmithSnagIt_Architecture,$VLCPlayer_Architecture,$VMwareTools_Architecture,$WinMerge_Architecture,$Wireshark_Architecture,$IrfanView_Language,$MSOffice_Language,$MSEdgeWebView2,$MSEdgeWebView2_Architecture,$AutodeskDWGTrueView,$MindView7,$MindView7_Language,$PDFsam,$MSOfficeVersion,$OpenShellMenu,$PDFForgeCreator,$TotalCommander,$LogMeInGoToMeeting_Installer,$MSAzureDataStudio_Installer,$MSVisualStudioCode_Installer,$MS365Apps_Installer,$Zoom_Architecture,$MSTeams_Installer,$Zoom_Installer,$MSOneDrive_Installer,$Slack_Installer,$pdfforgePDFCreatorChannel,$TotalCommander_Architecture,$Repository,$CleanUpStartMenu,$MSVisualCPlusPlusRuntime,$MSVisualCPlusPlusRuntimeRelease,$MSVisualCPlusPlusRuntime_Architecture,$MSOffice_Visio,$MSOffice_Visio_Language,$MSOffice_Project,$MSOffice_Project_Language,$CiscoWebexTeamsClient,$BISF_Tools,$MozillaThunderbird,$PDF24Creator,$WinRAR,$AdobeProDC_Architecture,$GoogleChromeChannel,$OpenJDKPackage,$PaintDotNet_Architecture,$WinRAR_Architecture,$WinRAR_Language,$WinRARChannel,$MozillaThunderbird_Architecture,$MozillaThunderbird_Language,$MSAzureDataStudio_Architecture,$TeamViewer_Architecture,$OperaBrowser,$OperaBrowser_Architecture,$Ditto,$Ditto_Architecture,$Ditto_Channel,$XCA,$ControlUpEdgeDX_Installer,$ControlUpRemoteDX,$IISCrypto,$Screenpresso,$Report,$NoDesktopIcon,$ControlUpRemoteDXEUC,$MSTeamsAVD,$AdoptOpenJDK,$AdoptOpenJDKVersion,$Bloomberg,$GoogleDrive,$JabraDirect,$AdoptOpenJDKIcedTeaWeb,$OpenWebStart,$AdoptOpenJDK_Architecture,$OpenWebStart_Architecture,$WindowsUpdate,$MSTeamsNew,$MSTeamsAVDNew,$MobaXterm,$MSTeamsNew_Architecture | out-file -filepath "$PSScriptRoot\$GUIfile"
        
        # Write ControlUp data in the files.
        $ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Agent")) {New-Item -Path "$PSScriptRoot\ControlUp Agent" -ItemType Directory | Out-Null}
        $ControlUpAgentAuthKey | out-file -filepath "$PSScriptRoot\ControlUp Agent\AuthKey.txt"
        $ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager")) {New-Item -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager" -ItemType Directory | Out-Null}
        $ControlUpEdgeDXDevRegCode | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt"
        $ControlUpEdgeDXTenantName | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt"
        
        If ($MS365Apps_Path -ne "") {
            If ($WhatIf -eq '0') {
                If ($MS365Apps -eq 1) {
                    Switch ($MS365AppsChannel) {
                        0 { $MS365AppsChannelClear = 'Beta Channel'}
                        1 { $MS365AppsChannelClear = 'Current Channel (Preview)'}
                        2 { $MS365AppsChannelClear = 'Current Channel'}
                        3 { $MS365AppsChannelClear = 'Semi-Annual Channel (Preview)'}
                        4 { $MS365AppsChannelClear = 'Monthly Enterprise Channel'}
                        5 { $MS365AppsChannelClear = 'Semi-Annual Channel'}
                    }
                    If (!(Test-Path -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear")) {New-Item -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear\install.xml" -Force
                    Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft 365 Apps $MS365AppsChannelClear folder."
                    Write-Output ""
                }
                If ($MSOffice -eq 1) {
                    Switch ($MSOfficeVersion) {
                        0 { $MSOfficeChannelClear = '2019'}
                        1 { $MSOfficeChannelClear = '2021 LTSC'}
                    }
                    $OfficePath = "Microsoft Office " + $MSOfficeChannelClear
                    If (!(Test-Path -Path "$PSScriptRoot\$OfficePath")) {New-Item -Path "$PSScriptRoot\$OfficePath" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\$OfficePath\install.xml" -Force
                }
                Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft Office $MSOfficeChannelClear folder."
                Write-Output ""
            }
        }
        # Shortcut Creation
        $Desktop = [Environment]::GetFolderPath([Environment+SpecialFolder]::Desktop)
        If ($NoDesktopIcon -eq "0"){
            If ((Test-Path -Path "$Desktop\Evergreen Script.lnk")) {
                Remove-Item "$Desktop\Evergreen Script.lnk"
            }
            If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                $sh = New-Object -ComObject WScript.Shell
                $target = $sh.CreateShortcut("$Desktop\NeverRed.lnk").TargetPath
                If ($target -ne "$env:ProgramFiles\PowerShell\7") {
                    Remove-Item "$Desktop\NeverRed.lnk"
                } 
            }
            If (!(Test-Path -Path "$Desktop\NeverRed.lnk")) {
                $WScriptShell = New-Object -ComObject 'WScript.Shell'
                $ShortcutFile = "$Desktop\NeverRed.lnk"
                $Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
                If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                    $Shortcut.TargetPath = '"C:\Program Files\PowerShell\7\pwsh.exe"'
                    $Shortcut.WorkingDirectory = '"C:\Program Files\PowerShell\7\"' 
                } else {
                    $Shortcut.TargetPath = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
                    $Shortcut.WorkingDirectory = "C:\Windows\System32\WindowsPowerShell\v1.0"
                }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut")) { New-Item -Path "$PSScriptRoot\shortcut" -ItemType Directory | Out-Null }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut\NeverRed.ico")) {Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/shortcut/NeverRed.ico -OutFile ("$PSScriptRoot\shortcut\" + "NeverRed.ico")}
                $shortcut.IconLocation="$PSScriptRoot\shortcut\NeverRed.ico"
                $Shortcut.Arguments = '-noexit -ExecutionPolicy Bypass -file "' + "$PSScriptRoot" + '\NeverRed.ps1"'
                $Shortcut.Save()
                $Admin = [System.IO.File]::ReadAllBytes("$ShortcutFile")
                $Admin[0x15] = $Admin[0x15] -bor 0x20
                [System.IO.File]::WriteAllBytes("$ShortcutFile", $Admin)
            }
        }
        Write-Host "GUI Mode"
        $Form.Close()
    })

    # Button Cancel
    $WPFButton_Cancel.Add_Click({
        Write-Host -Foregroundcolor Red "GUI Mode Canceled - Nothing happens"
        $Form.Close()
        Break
    })

    # Button Cancel Detail
    $WPFButton_Cancel_Detail.Add_Click({
        Write-Host -Foregroundcolor Red "GUI Mode Canceled - Nothing happens"
        $Form.Close()
        Break
    })

    # Button Save (AddScript)
    $WPFButton_Save.Add_Click({
        If ($WPFCheckbox_Download.IsChecked -eq $True) {$Script:Download = 1}
        Else {$Script:Download = 0}
        If ($WPFCheckbox_Install.IsChecked -eq $True) {$Script:Install = 1}
        Else {$Script:Install = 0}
        If ($WPFCheckbox_7Zip.IsChecked -eq $true) {$Script:7ZIP = 1}
        Else {$Script:7ZIP = 0}
        If ($WPFCheckbox_AdobeProDC.IsChecked -eq $true) {$Script:AdobeProDC = 1}
        Else {$Script:AdobeProDC = 0}
        If ($WPFCheckbox_AdobeReaderDC.IsChecked -eq $true) {$Script:AdobeReaderDC = 1}
        Else {$Script:AdobeReaderDC = 0}
        If ($WPFCheckbox_BISF.IsChecked -eq $true) {$Script:BISF = 1}
        Else {$Script:BISF = 0}
        If ($WPFCheckbox_CitrixHypervisorTools.IsChecked -eq $true) {$Script:Citrix_Hypervisor_Tools = 1}
        Else {$Script:Citrix_Hypervisor_Tools = 0}
        If ($WPFCheckbox_CitrixWorkspaceApp.IsChecked -eq $true) {$Script:Citrix_WorkspaceApp = 1}
        Else {$Script:Citrix_WorkspaceApp = 0}
        If ($WPFCheckbox_Filezilla.IsChecked -eq $true) {$Script:Filezilla = 1}
        Else {$Script:Filezilla = 0}
        If ($WPFCheckbox_Firefox.IsChecked -eq $true) {$Script:Firefox = 1}
        Else {$Script:Firefox = 0}
        If ($WPFCheckbox_MSFSLogix.IsChecked -eq $true) {$Script:MSFSLogix = 1}
        Else {$Script:MSFSLogix = 0}
        If ($WPFCheckbox_FoxitReader.Ischecked -eq $true) {$Script:Foxit_Reader = 1}
        Else {$Script:Foxit_Reader = 0}
        If ($WPFCheckbox_GoogleChrome.ischecked -eq $true) {$Script:GoogleChrome = 1}
        Else {$Script:GoogleChrome = 0}
        If ($WPFCheckbox_Greenshot.ischecked -eq $true) {$Script:Greenshot = 1}
        Else {$Script:Greenshot = 0}
        If ($WPFCheckbox_IrfanView.ischecked -eq $true) {$Script:IrfanView = 1}
        Else {$Script:IrfanView = 0}
        If ($WPFCheckbox_KeePass.ischecked -eq $true) {$Script:KeePass = 1}
        Else {$Script:KeePass = 0}
        If ($WPFCheckbox_mRemoteNG.ischecked -eq $true) {$Script:mRemoteNG = 1}
        Else {$Script:mRemoteNG = 0}
        If ($WPFCheckbox_MS365Apps.ischecked -eq $true) {$Script:MS365Apps = 1}
        Else {$Script:MS365Apps = 0}
        If ($WPFCheckbox_MSEdge.ischecked -eq $true) {$Script:MSEdge = 1}
        Else {$Script:MSEdge = 0}
        If ($WPFCheckbox_MSEdgeWebView2.ischecked -eq $true) {$Script:MSEdgeWebView2 = 1}
        Else {$Script:MSEdgeWebView2 = 0}
        If ($WPFCheckbox_MSOffice.ischecked -eq $true) {$Script:MSOffice = 1}
        Else {$Script:MSOffice = 0}
        If ($WPFCheckbox_MSOneDrive.ischecked -eq $true) {$Script:MSOneDrive = 1}
        Else {$Script:MSOneDrive = 0}
        If ($WPFCheckbox_MSTeams.ischecked -eq $true) {$Script:MSTeams = 1}
        Else {$Script:MSTeams = 0}
        If ($WPFCheckbox_NotePadPlusPlus.ischecked -eq $true) {$Script:NotePadPlusPlus = 1}
        Else {$Script:NotePadPlusPlus = 0}
        If ($WPFCheckbox_OpenJDK.ischecked -eq $true) {$Script:OpenJDK = 1}
        Else {$Script:OpenJDK = 0}
        If ($WPFCheckbox_OracleJava8.ischecked -eq $true) {$Script:OracleJava8 = 1}
        Else {$Script:OracleJava8 = 0}
        If ($WPFCheckbox_TreeSize.ischecked -eq $true) {$Script:TreeSize = 1}
        Else {$Script:TreeSize = 0}
        If ($WPFCheckbox_VLCPlayer.ischecked -eq $true) {$Script:VLCPlayer = 1}
        Else {$Script:VLCPlayer = 0}
        If ($WPFCheckbox_VMwareTools.ischecked -eq $true) {$Script:VMwareTools = 1}
        Else {$Script:VMwareTools = 0}
        If ($WPFCheckbox_WinSCP.ischecked -eq $true) {$Script:WinSCP = 1}
        Else {$Script:WinSCP = 0}        
        If ($WPFCheckbox_MSTeams_No_AutoStart.ischecked -eq $true) {$Script:MSTeamsNoAutoStart = 1}
        Else {$Script:MSTeamsNoAutoStart = 0}
        If ($WPFCheckbox_deviceTRUST.ischecked -eq $true) {$Script:deviceTRUST = 1}
        Else {$Script:deviceTRUST = 0}
        If ($WPFCheckbox_MSDotNetFramework.ischecked -eq $true) {$Script:MSDotNetFramework = 1}
        Else {$Script:MSDotNetFramework = 0}
        If ($WPFCheckbox_MSPowerShell.ischecked -eq $true) {$Script:MSPowerShell = 1}
        Else {$Script:MSPowerShell = 0}
        If ($WPFCheckbox_RemoteDesktopManager.ischecked -eq $true) {$Script:RemoteDesktopManager = 1}
        Else {$Script:RemoteDesktopManager = 0}
        If ($WPFCheckbox_Slack.ischecked -eq $true) {$Script:Slack = 1}
        Else {$Script:Slack = 0}
        If ($WPFCheckbox_ShareX.ischecked -eq $true) {$Script:ShareX = 1}
        Else {$Script:ShareX = 0}
        If ($WPFCheckbox_Zoom.ischecked -eq $true) {$Script:Zoom = 1}
        Else {$Script:Zoom = 0}
        If ($WPFCheckbox_GIMP.ischecked -eq $true) {$Script:GIMP = 1}
        Else {$Script:GIMP = 0}
        If ($WPFCheckbox_MSPowerToys.ischecked -eq $true) {$Script:MSPowerToys = 1}
        Else {$Script:MSPowerToys = 0}
        If ($WPFCheckbox_MSVisualStudio.ischecked -eq $true) {$Script:MSVisualStudio = 1}
        Else {$Script:MSVisualStudio = 0}
        If ($WPFCheckbox_MSVisualStudioCode.ischecked -eq $true) {$Script:MSVisualStudioCode = 1}
        Else {$Script:MSVisualStudioCode = 0}
        If ($WPFCheckbox_PaintDotNet.ischecked -eq $true) {$Script:PaintDotNet = 1}
        Else {$Script:PaintDotNet = 0}
        If ($WPFCheckbox_Putty.ischecked -eq $true) {$Script:Putty = 1}
        Else {$Script:Putty = 0}
        If ($WPFCheckbox_TeamViewer.ischecked -eq $true) {$Script:TeamViewer = 1}
        Else {$Script:TeamViewer = 0}
        If ($WPFCheckbox_Wireshark.ischecked -eq $true) {$Script:Wireshark = 1}
        Else {$Script:Wireshark = 0}
        If ($WPFCheckbox_MSAzureDataStudio.ischecked -eq $true) {$Script:MSAzureDataStudio = 1}
        Else {$Script:MSAzureDataStudio = 0}
        If ($WPFCheckbox_ImageGlass.ischecked -eq $true) {$Script:ImageGlass = 1}
        Else {$Script:ImageGlass = 0}
        If ($WPFCheckbox_ControlUpEdgeDX.ischecked -eq $true) {$Script:ControlUpEdgeDX = 1}
        Else {$Script:ControlUpEdgeDX = 0}
        If ($WPFCheckbox_1Password.ischecked -eq $true) {$Script:1Password = 1}
        Else {$Script:1Password = 0}
        If ($WPFCheckbox_ControlUpAgent.ischecked -eq $true) {$Script:ControlUpAgent = 1}
        Else {$Script:ControlUpAgent = 0}
        If ($WPFCheckbox_ControlUpConsole.ischecked -eq $true) {$Script:ControlUpConsole = 1}
        Else {$Script:ControlUpConsole = 0}
        If ($WPFCheckbox_MSSQLServerManagementStudio.ischecked -eq $true) {$Script:MSSQLServerManagementStudio = 1}
        Else {$Script:MSSQLServerManagementStudio = 0}
        If ($WPFCheckbox_MSAVDRemoteDesktop.ischecked -eq $true) {$Script:MSAVDRemoteDesktop = 1}
        Else {$Script:MSAVDRemoteDesktop = 0}
        If ($WPFCheckbox_MSPowerBIDesktop.ischecked -eq $true) {$Script:MSPowerBIDesktop = 1}
        Else {$Script:MSPowerBIDesktop = 0}
        If ($WPFCheckbox_RDAnalyzer.ischecked -eq $true) {$Script:RDAnalyzer = 1}
        Else {$Script:RDAnalyzer = 0}
        If ($WPFCheckbox_SumatraPDF.ischecked -eq $true) {$Script:SumatraPDF = 1}
        Else {$Script:SumatraPDF = 0}
        If ($WPFCheckbox_CiscoWebexTeams.ischecked -eq $true) {$Script:CiscoWebexTeams = 1}
        Else {$Script:CiscoWebexTeams = 0}
        If ($WPFCheckbox_CitrixFiles.ischecked -eq $true) {$Script:CitrixFiles = 1}
        Else {$Script:CitrixFiles = 0}
        If ($WPFCheckbox_FoxitPDFEditor.ischecked -eq $true) {$Script:FoxitPDFEditor = 1}
        Else {$Script:FoxitPDFEditor = 0}
        If ($WPFCheckbox_GitForWindows.ischecked -eq $true) {$Script:GitForWindows = 1}
        Else {$Script:GitForWindows = 0}
        If ($WPFCheckbox_LogMeInGoToMeeting.ischecked -eq $true) {$Script:LogMeInGoToMeeting = 1}
        Else {$Script:LogMeInGoToMeeting = 0}
        If ($WPFCheckbox_MSAzureCLI.ischecked -eq $true) {$Script:MSAzureCLI = 1}
        Else {$Script:MSAzureCLI = 0}
        If ($WPFCheckbox_MSPowerBIReportBuilder.ischecked -eq $true) {$Script:MSPowerBIReportBuilder = 1}
        Else {$Script:MSPowerBIReportBuilder = 0}
        If ($WPFCheckbox_MSSysinternals.ischecked -eq $true) {$Script:MSSysinternals = 1}
        Else {$Script:MSSysinternals = 0}
        If ($WPFCheckbox_Nmap.ischecked -eq $true) {$Script:Nmap = 1}
        Else {$Script:Nmap = 0}
        If ($WPFCheckbox_PeaZip.ischecked -eq $true) {$Script:PeaZip = 1}
        Else {$Script:PeaZip = 0}
        If ($WPFCheckbox_TechSmithCamtasia.ischecked -eq $true) {$Script:TechSmithCamtasia = 1}
        Else {$Script:TechSmithCamtasia = 0}
        If ($WPFCheckbox_TechSmithSnagIt.ischecked -eq $true) {$Script:TechSmithSnagIt = 1}
        Else {$Script:TechSmithSnagIt = 0}
        If ($WPFCheckbox_WinMerge.ischecked -eq $true) {$Script:WinMerge = 1}
        Else {$Script:WinMerge = 0}
        If ($WPFCheckbox_WhatIf.ischecked -eq $true) {$Script:WhatIf = 1}
        Else {$Script:WhatIf = 0}
        If ($WPFCheckbox_CleanUp.ischecked -eq $true) {$Script:CleanUp = 1}
        Else {$Script:CleanUp = 0}
        If ($WPFCheckbox_MS365Apps_Visio_Detail.ischecked -eq $true) {$Script:MS365Apps_Visio = 1}
        Else {$Script:MS365Apps_Visio = 0}
        If ($WPFCheckbox_MS365Apps_Project_Detail.ischecked -eq $true) {$Script:MS365Apps_Project = 1}
        Else {$Script:MS365Apps_Project = 0}
        If ($WPFCheckbox_AutodeskDWGTrueView.ischecked -eq $true) {$Script:AutodeskDWGTrueView = 1}
        Else {$Script:AutodeskDWGTrueView = 0}
        If ($WPFCheckbox_MindView7.ischecked -eq $true) {$Script:MindView7 = 1}
        Else {$Script:MindView7 = 0}
        If ($WPFCheckbox_PDFsam.ischecked -eq $true) {$Script:PDFsam = 1}
        Else {$Script:PDFsam = 0}
        If ($WPFCheckbox_OpenShellMenu.ischecked -eq $true) {$Script:OpenShellMenu = 1}
        Else {$Script:OpenShellMenu = 0}
        If ($WPFCheckbox_PDFForgeCreator.ischecked -eq $true) {$Script:PDFForgeCreator = 1}
        Else {$Script:PDFForgeCreator = 0}
        If ($WPFCheckbox_TotalCommander.ischecked -eq $true) {$Script:TotalCommander = 1}
        Else {$Script:TotalCommander = 0}
        If ($WPFCheckbox_Repository.ischecked -eq $true) {$Script:Repository = 1}
        Else {$Script:Repository = 0}
        If ($WPFCheckbox_CleanUpStartMenu.ischecked -eq $true) {$Script:CleanUpStartMenu = 1}
        Else {$Script:CleanUpStartMenu = 0}
        If ($WPFCheckbox_MSVisualCPlusPlusRuntime.ischecked -eq $true) {$Script:MSVisualCPlusPlusRuntime = 1}
        Else {$Script:MSVisualCPlusPlusRuntime = 0}
        If ($WPFCheckbox_MSOffice_Visio_Detail.ischecked -eq $true) {$Script:MSOffice_Visio = 1}
        Else {$Script:MSOffice_Visio = 0}
        If ($WPFCheckbox_MSOffice_Project_Detail.ischecked -eq $true) {$Script:MSOffice_Project = 1}
        Else {$Script:MSOffice_Project = 0}
        If ($WPFCheckbox_MozillaThunderbird.ischecked -eq $true) {$Script:MozillaThunderbird = 1}
        Else {$Script:MozillaThunderbird = 0}
        If ($WPFCheckbox_PDF24Creator.ischecked -eq $true) {$Script:PDF24Creator = 1}
        Else {$Script:PDF24Creator = 0}
        If ($WPFCheckbox_WinRAR.ischecked -eq $true) {$Script:WinRAR = 1}
        Else {$Script:WinRAR = 0}
        If ($WPFCheckbox_Ditto.ischecked -eq $true) {$Script:Ditto = 1}
        Else {$Script:Ditto = 0}
        If ($WPFCheckbox_OperaBrowser.ischecked -eq $true) {$Script:OperaBrowser = 1}
        Else {$Script:OperaBrowser = 0}
        If ($WPFCheckbox_XCA.ischecked -eq $true) {$Script:XCA = 1}
        Else {$Script:XCA = 0}
        If ($WPFCheckbox_IISCrypto.ischecked -eq $true) {$Script:IISCrypto = 1}
        Else {$Script:IISCrypto = 0}
        If ($WPFCheckbox_Screenpresso.ischecked -eq $true) {$Script:Screenpresso = 1}
        Else {$Script:Screenpresso = 0}
        If ($WPFCheckbox_ControlUpRemoteDX.ischecked -eq $true) {$Script:ControlUpRemoteDX = 1}
        Else {$Script:ControlUpRemoteDX = 0}
        If ($WPFCheckbox_Report.ischecked -eq $true) {$Script:Report = 1}
        Else {$Script:Report = 0}
        If ($WPFCheckbox_NoDesktopIcon.ischecked -eq $true) {$Script:NoDesktopIcon = 1}
        Else {$Script:NoDesktopIcon = 0}
        If ($WPFCheckbox_MSTeamsAVD.ischecked -eq $true) {$Script:MSTeamsAVD = 1}
        Else {$Script:MSTeamsAVD = 0}
        If ($WPFCheckbox_AdoptOpenJDK.ischecked -eq $true) {$Script:AdoptOpenJDK = 1}
        Else {$Script:AdoptOpenJDK = 0}
        If ($WPFCheckbox_Bloomberg.ischecked -eq $true) {$Script:Bloomberg = 1}
        Else {$Script:Bloomberg = 0}
        If ($WPFCheckbox_GoogleDrive.ischecked -eq $true) {$Script:GoogleDrive = 1}
        Else {$Script:GoogleDrive = 0}
        If ($WPFCheckbox_JabraDirect.ischecked -eq $true) {$Script:JabraDirect = 1}
        Else {$Script:JabraDirect = 0}
        If ($WPFCheckbox_AdoptOpenJDKIcedTeaWeb.ischecked -eq $true) {$Script:AdoptOpenJDKIcedTeaWeb = 1}
        Else {$Script:AdoptOpenJDKIcedTeaWeb = 0}
        If ($WPFCheckbox_OpenWebStart.ischecked -eq $true) {$Script:OpenWebStart = 1}
        Else {$Script:OpenWebStart = 0}
        If ($WPFCheckbox_WindowsUpdate.ischecked -eq $true) {$Script:WindowsUpdate = 1}
        Else {$Script:WindowsUpdate = 0}
        If ($WPFCheckbox_MSTeamsNew.ischecked -eq $true) {$Script:MSTeamsNew = 1}
        Else {$Script:MSTeamsNew = 0}
        If ($WPFCheckbox_MSTeamsAVDNew.ischecked -eq $true) {$Script:MSTeamsAVDNew = 1}
        Else {$Script:MSTeamsAVDNew = 0}
        If ($WPFCheckbox_MobaXterm.ischecked -eq $true) {$Script:MobaXterm = 1}
        Else {$Script:MobaXterm = 0}
        $Script:Language = $WPFBox_Language.SelectedIndex
        $Script:Architecture = $WPFBox_Architecture.SelectedIndex
        $Script:Installer = $WPFBox_Installer.SelectedIndex
        $Script:FirefoxChannel = $WPFBox_Firefox.SelectedIndex
        $Script:CitrixWorkspaceAppRelease = $WPFBox_CitrixWorkspaceApp.SelectedIndex
        $Script:MS365AppsChannel = $WPFBox_MS365Apps.SelectedIndex
        $Script:MSOneDriveRing = $WPFBox_MSOneDrive.SelectedIndex
        $Script:MSTeamsRing = $WPFBox_MSTeams.SelectedIndex
        $Script:TreeSizeType = $WPFBox_TreeSize.SelectedIndex
        $Script:MSDotNetFrameworkChannel = $WPFBox_MSDotNetFramework.SelectedIndex
        $Script:MSPowerShellRelease = $WPFBox_MSPowerShell.SelectedIndex
        $Script:RemoteDesktopManagerType = $WPFBox_RemoteDesktopManager.SelectedIndex
        $Script:ZoomCitrixClient = $WPFBox_Zoom.SelectedIndex
        $Script:deviceTRUSTPackage = $WPFBox_deviceTRUST.SelectedIndex
        $Script:MSEdgeChannel = $WPFBox_MSEdge.SelectedIndex
        $Script:MSVisualStudioCodeChannel = $WPFBox_MSVisualStudioCode.SelectedIndex
        $Script:MSVisualStudioEdition = $WPFBox_MSVisualStudio.SelectedIndex
        $Script:PuttyChannel = $WPFBox_Putty.SelectedIndex
        $Script:MSAzureDataStudioChannel = $WPFBox_MSAzureDataStudio.SelectedIndex
        $Script:MSFSLogixChannel = $WPFBox_MSFSLogix.SelectedIndex
        $Script:OperaBrowserChannel = $WPFBox_OperaBrowser.SelectedIndex
        $Script:MSAVDRemoteDesktopChannel = $WPFBox_MSAVDRemoteDesktop.SelectedIndex
        $Script:7Zip_Architecture = $WPFBox_7Zip_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Architecture = $WPFBox_AdobeReaderDC_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Language = $WPFBox_AdobeReaderDC_Language.SelectedIndex
        $Script:CiscoWebexTeams_Architecture = $WPFBox_CiscoWebexTeams_Architecture.SelectedIndex
        $Script:CitrixHypervisorTools_Architecture = $WPFBox_CitrixHypervisorTools_Architecture.SelectedIndex
        $Script:ControlUpAgent_Architecture = $WPFBox_ControlUpAgent_Architecture.SelectedIndex
        $Script:deviceTRUST_Architecture = $WPFBox_deviceTRUST_Architecture.SelectedIndex
        $Script:FoxitPDFEditor_Language = $WPFBox_FoxitPDFEditor_Language.SelectedIndex
        $Script:FoxitReader_Language = $WPFBox_FoxitReader_Language.SelectedIndex
        $Script:GitForWindows_Architecture = $WPFBox_GitForWindows_Architecture.SelectedIndex
        $Script:GoogleChrome_Architecture = $WPFBox_GoogleChrome_Architecture.SelectedIndex
        $Script:ImageGlass_Architecture = $WPFBox_ImageGlass_Architecture.SelectedIndex
        $Script:IrfanView_Architecture = $WPFBox_IrfanView_Architecture.SelectedIndex
        $Script:Keepass_Language = $WPFBox_KeePass_Language.SelectedIndex
        $Script:MSDotNetFramework_Architecture = $WPFBox_MSDotNetFramework_Architecture.SelectedIndex
        $Script:MS365Apps_Architecture = $WPFBox_MS365Apps_Architecture.SelectedIndex
        $Script:MS365Apps_Language = $WPFBox_MS365Apps_Language.SelectedIndex
        $Script:MS365Apps_Visio_Language = $WPFBox_MS365Apps_Visio_Language.SelectedIndex
        $Script:MS365Apps_Project_Language = $WPFBox_MS365Apps_Project_Language.SelectedIndex
        $Script:MSAVDRemoteDesktop_Architecture = $WPFBox_MSAVDRemoteDesktop_Architecture.SelectedIndex
        $Script:MSEdge_Architecture = $WPFBox_MSEdge_Architecture.SelectedIndex
        $Script:MSFSLogix_Architecture = $WPFBox_MSFSLogix_Architecture.SelectedIndex
        $Script:MSOffice_Architecture = $WPFBox_MSOffice_Architecture.SelectedIndex
        $Script:MSOneDrive_Architecture = $WPFBox_MSOneDrive_Architecture.SelectedIndex
        $Script:MSPowerBIDesktop_Architecture = $WPFBox_MSPowerBIDesktop_Architecture.SelectedIndex
        $Script:MSPowerShell_Architecture = $WPFBox_MSPowerShell_Architecture.SelectedIndex
        $Script:MSSQLServerManagementStudio_Language = $WPFBox_MSSQLServerManagementStudio_Language.SelectedIndex
        $Script:MSTeams_Architecture = $WPFBox_MSTeams_Architecture.SelectedIndex
        $Script:MSVisualStudioCode_Architecture = $WPFBox_MSVisualStudioCode_Architecture.SelectedIndex
        $Script:Firefox_Architecture = $WPFBox_Firefox_Architecture.SelectedIndex
        $Script:Firefox_Language = $WPFBox_Firefox_Language.SelectedIndex
        $Script:NotePadPlusPlus_Architecture = $WPFBox_NotepadPlusPlus_Architecture.SelectedIndex
        $Script:OpenJDK_Architecture = $WPFBox_OpenJDK_Architecture.SelectedIndex
        $Script:OracleJava8_Architecture = $WPFBox_OracleJava8_Architecture.SelectedIndex
        $Script:PeaZip_Architecture = $WPFBox_PeaZip_Architecture.SelectedIndex
        $Script:Putty_Architecture = $WPFBox_Putty_Architecture.SelectedIndex
        $Script:Slack_Architecture = $WPFBox_Slack_Architecture.SelectedIndex
        $Script:SumatraPDF_Architecture = $WPFBox_SumatraPDF_Architecture.SelectedIndex
        $Script:TechSmithSnagIt_Architecture = $WPFBox_TechSmithSnagIT_Architecture.SelectedIndex
        $Script:VLCPlayer_Architecture = $WPFBox_VLCPlayer_Architecture.SelectedIndex
        $Script:VMwareTools_Architecture = $WPFBox_VMwareTools_Architecture.SelectedIndex
        $Script:WinMerge_Architecture = $WPFBox_WinMerge_Architecture.SelectedIndex
        $Script:Wireshark_Architecture = $WPFBox_Wireshark_Architecture.SelectedIndex
        $Script:IrfanView_Language = $WPFBox_IrfanView_Language.SelectedIndex
        $Script:MSOffice_Language = $WPFBox_MSOffice_Language.SelectedIndex
        $Script:MS365Apps_Path = $WPFTextBox_Filename.Text
        $Script:MSEdgeWebView2_Architecture = $WPFBox_MSEdgeWebView2_Architecture.SelectedIndex
        $Script:MindView7_Language = $WPFBox_MindView7_Language.SelectedIndex
        $Script:MSOfficeVersion = $WPFBox_MSOffice.SelectedIndex
        $Script:LogMeInGoToMeeting_Installer = $WPFBox_LogMeInGoToMeeting_Installer.SelectedIndex
        $Script:MSAzureDataStudio_Installer = $WPFBox_MSAzureDataStudio_Installer.SelectedIndex
        $Script:MSVisualStudioCode_Installer = $WPFBox_MSVisualStudioCode_Installer.SelectedIndex
        $Script:MS365Apps_Installer = $WPFBox_MS365Apps_Installer.SelectedIndex
        $Script:MSTeams_Installer = $WPFBox_MSTeams_Installer.SelectedIndex
        $Script:Zoom_Installer = $WPFBox_Zoom_Installer.SelectedIndex
        $Script:MSOneDrive_Installer = $WPFBox_MSOneDrive_Installer.SelectedIndex
        $Script:Slack_Installer = $WPFBox_Slack_Installer.SelectedIndex
        $Script:pdfforgePDFCreatorChannel = $WPFBox_pdfforgePDFCreator.SelectedIndex
        $Script:TotalCommander_Architecture = $WPFBox_TotalCommander_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntime_Architecture = $WPFBox_MSVisualCPlusPlusRuntime_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntimeRelease = $WPFBox_MSVisualCPlusPlusRuntime.SelectedIndex
        $Script:MSOffice_Visio_Language = $WPFBox_MSOffice_Visio_Language.SelectedIndex
        $Script:MSOffice_Project_Language = $WPFBox_MSOffice_Project_Language.SelectedIndex
        $Script:Zoom_Architecture = $WPFBox_Zoom_Architecture.SelectedIndex
        $Script:CiscoWebexTeamsClient = $WPFBox_CiscoWebexTeams.SelectedIndex
        $Script:AdobeProDC_Architecture = $WPFBox_AdobeProDC_Architecture.SelectedIndex
        $Script:GoogleChromeChannel = $WPFBox_GoogleChrome.SelectedIndex
        $Script:OpenJDKPackage = $WPFBox_OpenJDK.SelectedIndex
        $Script:PaintDotNet_Architecture = $WPFBox_PaintDotNet_Architecture.SelectedIndex
        $Script:WinRAR_Architecture = $WPFBox_WinRAR_Architecture.SelectedIndex
        $Script:WinRAR_Language = $WPFBox_WinRAR_Language.SelectedIndex
        $Script:WinRARChannel = $WPFBox_WinRAR.SelectedIndex
        $Script:MozillaThunderbird_Architecture = $WPFBox_MozillaThunderbird_Architecture.SelectedIndex
        $Script:MozillaThunderbird_Language = $WPFBox_MozillaThunderbird_Language.SelectedIndex
        $Script:MSAzureDataStudio_Architecture = $WPFBox_MSAzureDataStudio_Architecture.SelectedIndex
        $Script:TeamViewer_Architecture = $WPFBox_TeamViewer_Architecture.SelectedIndex
        $Script:Ditto_Architecture = $WPFBox_Ditto_Architecture.SelectedIndex
        $Script:Ditto_Channel = $WPFBox_Ditto.SelectedIndex
        $Script:OperaBrowser_Architecture = $WPFBox_OperaBrowser_Architecture.SelectedIndex
        $Script:ControlUpEdgeDX_Installer = $WPFBox_ControlUpEdgeDX_Installer.SelectedIndex
        $Script:BISF_Tools = $WPFBox_BISF_Tools.SelectedIndex
        $Script:ControlUpRemoteDXEUC = $WPFBox_ControlUpRemoteDX.SelectedIndex
        $Script:ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        $Script:ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $Script:ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        $Script:AdoptOpenJDKVersion = $WPFBox_AdoptOpenJDK.SelectedIndex
        $Script:AdoptOpenJDK_Architecture = $WPFBox_AdoptOpenJDK_Architecture.SelectedIndex
        $Script:OpenWebStart_Architecture = $WPFBox_OpenWebStart_Architecture.SelectedIndex
        $Script:MSTeamsNew_Architecture = $WPFBox_MSTeamsNew_Architecture.SelectedIndex

        # Write LastSetting.txt or -GUIFile Parameter file to get the settings of the last session. (AddScript)
        $Language,$Architecture,$CitrixWorkspaceAppRelease,$MS365AppsChannel,$MSOneDriveRing,$MSTeamsRing,$FirefoxChannel,$TreeSizeType,$7ZIP,$AdobeProDC,$AdobeReaderDC,$BISF,$Citrix_Hypervisor_Tools,$Citrix_WorkspaceApp,$Filezilla,$Firefox,$Foxit_Reader,$MSFSLogix,$GoogleChrome,$Greenshot,$KeePass,$mRemoteNG,$MS365Apps,$MSEdge,$MSOffice,$MSOneDrive,$MSTeams,$NotePadPlusPlus,$OpenJDK,$OracleJava8,$TreeSize,$VLCPlayer,$VMwareTools,$WinSCP,$Download,$Install,$IrfanView,$MSTeamsNoAutoStart,$deviceTRUST,$MSDotNetFramework,$MSDotNetFrameworkChannel,$MSPowerShell,$MSPowerShellRelease,$RemoteDesktopManager,$RemoteDesktopManagerType,$Slack,$Wireshark,$ShareX,$Zoom,$ZoomCitrixClient,$deviceTRUSTPackage,$MSEdgeChannel,$GIMP,$MSPowerToys,$MSVisualStudio,$MSVisualStudioCode,$MSVisualStudioCodeChannel,$PaintDotNet,$Putty,$TeamViewer,$Installer,$MSVisualStudioEdition,$PuttyChannel,$MSAzureDataStudio,$MSAzureDataStudioChannel,$ImageGlass,$MSFSLogixChannel,$ControlUpEdgeDX,$1Password,$SumatraPDF,$ControlUpAgent,$OperaBrowserChannel,$ControlUpConsole,$MSSQLServerManagementStudio,$MSAVDRemoteDesktop,$MSAVDRemoteDesktopChannel,$MSPowerBIDesktop,$RDAnalyzer,$CiscoWebexTeams,$CitrixFiles,$FoxitPDFEditor,$GitForWindows,$LogMeInGoToMeeting,$MSAzureCLI,$MSPowerBIReportBuilder,$MSSysinternals,$NMap,$PeaZip,$TechSmithCamtasia,$TechSmithSnagit,$WinMerge,$WhatIf,$CleanUp,$7Zip_Architecture,$AdobeReaderDC_Architecture,$AdobeReaderDC_Language,$CiscoWebexTeams_Architecture,$CitrixHypervisorTools_Architecture,$ControlUpAgent_Architecture,$deviceTRUST_Architecture,$FoxitPDFEditor_Language,$FoxitReader_Language,$GitForWindows_Architecture,$GoogleChrome_Architecture,$ImageGlass_Architecture,$IrfanView_Architecture,$Keepass_Language,$MSDotNetFramework_Architecture,$MS365Apps_Architecture,$MS365Apps_Language,$MS365Apps_Visio,$MS365Apps_Visio_Language,$MS365Apps_Project,$MS365Apps_Project_Language,$MSAVDRemoteDesktop_Architecture,$MSEdge_Architecture,$MSFSLogix_Architecture,$MSOffice_Architecture,$MSOneDrive_Architecture,$MSPowerBIDesktop_Architecture,$MSPowerShell_Architecture,$MSSQLServerManagementStudio_Language,$MSTeams_Architecture,$MSVisualStudioCode_Architecture,$Firefox_Architecture,$Firefox_Language,$NotePadPlusPlus_Architecture,$OpenJDK_Architecture,$OracleJava8_Architecture,$PeaZip_Architecture,$Putty_Architecture,$Slack_Architecture,$SumatraPDF_Architecture,$TechSmithSnagIt_Architecture,$VLCPlayer_Architecture,$VMwareTools_Architecture,$WinMerge_Architecture,$Wireshark_Architecture,$IrfanView_Language,$MSOffice_Language,$MSEdgeWebView2,$MSEdgeWebView2_Architecture,$AutodeskDWGTrueView,$MindView7,$MindView7_Language,$PDFsam,$MSOfficeVersion,$OpenShellMenu,$PDFForgeCreator,$TotalCommander,$LogMeInGoToMeeting_Installer,$MSAzureDataStudio_Installer,$MSVisualStudioCode_Installer,$MS365Apps_Installer,$Zoom_Architecture,$MSTeams_Installer,$Zoom_Installer,$MSOneDrive_Installer,$Slack_Installer,$pdfforgePDFCreatorChannel,$TotalCommander_Architecture,$Repository,$CleanUpStartMenu,$MSVisualCPlusPlusRuntime,$MSVisualCPlusPlusRuntimeRelease,$MSVisualCPlusPlusRuntime_Architecture,$MSOffice_Visio,$MSOffice_Visio_Language,$MSOffice_Project,$MSOffice_Project_Language,$CiscoWebexTeamsClient,$BISF_Tools,$MozillaThunderbird,$PDF24Creator,$WinRAR,$AdobeProDC_Architecture,$GoogleChromeChannel,$OpenJDKPackage,$PaintDotNet_Architecture,$WinRAR_Architecture,$WinRAR_Language,$WinRARChannel,$MozillaThunderbird_Architecture,$MozillaThunderbird_Language,$MSAzureDataStudio_Architecture,$TeamViewer_Architecture,$OperaBrowser,$OperaBrowser_Architecture,$Ditto,$Ditto_Architecture,$Ditto_Channel,$XCA,$ControlUpEdgeDX_Installer,$ControlUpRemoteDX,$IISCrypto,$Screenpresso,$Report,$NoDesktopIcon,$ControlUpRemoteDXEUC,$MSTeamsAVD,$AdoptOpenJDK,$AdoptOpenJDKVersion,$Bloomberg,$GoogleDrive,$JabraDirect,$AdoptOpenJDKIcedTeaWeb,$OpenWebStart,$AdoptOpenJDK_Architecture,$OpenWebStart_Architecture,$WindowsUpdate,$MSTeamsNew,$MSTeamsAVDNew,$MobaXterm,$MSTeamsNew_Architecture | out-file -filepath "$PSScriptRoot\$GUIfile"

        # Write ControlUp data in the files.
        $ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Agent")) {New-Item -Path "$PSScriptRoot\ControlUp Agent" -ItemType Directory | Out-Null}
        $ControlUpAgentAuthKey | out-file -filepath "$PSScriptRoot\ControlUp Agent\AuthKey.txt"
        $ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager")) {New-Item -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager" -ItemType Directory | Out-Null}
        $ControlUpEdgeDXDevRegCode | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt"
        $ControlUpEdgeDXTenantName | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt"

        If ($MS365Apps_Path -ne "") {
            If ($WhatIf -eq '0') {
                If ($MS365Apps -eq 1) {
                    Switch ($MS365AppsChannel) {
                        0 { $MS365AppsChannelClear = 'Beta Channel'}
                        1 { $MS365AppsChannelClear = 'Current Channel (Preview)'}
                        2 { $MS365AppsChannelClear = 'Current Channel'}
                        3 { $MS365AppsChannelClear = 'Semi-Annual Channel (Preview)'}
                        4 { $MS365AppsChannelClear = 'Monthly Enterprise Channel'}
                        5 { $MS365AppsChannelClear = 'Semi-Annual Channel'}
                    }
                    If (!(Test-Path -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear")) {New-Item -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear\install.xml" -Force
                    Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft 365 Apps $MS365AppsChannelClear folder."
                    Write-Output ""
                }
                If ($MSOffice -eq 1) {
                    Switch ($MSOfficeVersion) {
                        0 { $MSOfficeChannelClear = '2019'}
                        1 { $MSOfficeChannelClear = '2021 LTSC'}
                    }
                    $OfficePath = "Microsoft Office " + $MSOfficeChannelClear
                    If (!(Test-Path -Path "$PSScriptRoot\$OfficePath")) {New-Item -Path "$PSScriptRoot\$OfficePath" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\$OfficePath\install.xml" -Force
                }
                Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft Office $MSOfficeChannelClear folder."
                Write-Output ""
            }
        }
        # Shortcut Creation
        $Desktop = [Environment]::GetFolderPath([Environment+SpecialFolder]::Desktop)
        If ($NoDesktopIcon -eq "0"){
            If ((Test-Path -Path "$Desktop\Evergreen Script.lnk")) {
                Remove-Item "$Desktop\Evergreen Script.lnk"
            }
            If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                $sh = New-Object -ComObject WScript.Shell
                $target = $sh.CreateShortcut("$Desktop\NeverRed.lnk").TargetPath
                If ($target -ne "$env:ProgramFiles\PowerShell\7") {
                    Remove-Item "$Desktop\NeverRed.lnk"
                } 
            }
            If (!(Test-Path -Path "$Desktop\NeverRed.lnk")) {
                $WScriptShell = New-Object -ComObject 'WScript.Shell'
                $ShortcutFile = "$Desktop\NeverRed.lnk"
                $Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
                If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                    $Shortcut.TargetPath = '"C:\Program Files\PowerShell\7\pwsh.exe"'
                    $Shortcut.WorkingDirectory = '"C:\Program Files\PowerShell\7\"' 
                } else {
                    $Shortcut.TargetPath = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
                    $Shortcut.WorkingDirectory = "C:\Windows\System32\WindowsPowerShell\v1.0"
                }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut")) { New-Item -Path "$PSScriptRoot\shortcut" -ItemType Directory | Out-Null }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut\NeverRed.ico")) {Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/shortcut/NeverRed.ico -OutFile ("$PSScriptRoot\shortcut\" + "NeverRed.ico")}
                $shortcut.IconLocation="$PSScriptRoot\shortcut\NeverRed.ico"
                $Shortcut.Arguments = '-noexit -ExecutionPolicy Bypass -file "' + "$PSScriptRoot" + '\NeverRed.ps1"'
                $Shortcut.Save()
                $Admin = [System.IO.File]::ReadAllBytes("$ShortcutFile")
                $Admin[0x15] = $Admin[0x15] -bor 0x20
                [System.IO.File]::WriteAllBytes("$ShortcutFile", $Admin)
            }
        }
        Write-Host "Save Settings"
    })

    # Button Save Detail (AddScript)
    $WPFButton_Save_Detail.Add_Click({
        If ($WPFCheckbox_Download.IsChecked -eq $True) {$Script:Download = 1}
        Else {$Script:Download = 0}
        If ($WPFCheckbox_Install.IsChecked -eq $True) {$Script:Install = 1}
        Else {$Script:Install = 0}
        If ($WPFCheckbox_7Zip.IsChecked -eq $true) {$Script:7ZIP = 1}
        Else {$Script:7ZIP = 0}
        If ($WPFCheckbox_AdobeProDC.IsChecked -eq $true) {$Script:AdobeProDC = 1}
        Else {$Script:AdobeProDC = 0}
        If ($WPFCheckbox_AdobeReaderDC.IsChecked -eq $true) {$Script:AdobeReaderDC = 1}
        Else {$Script:AdobeReaderDC = 0}
        If ($WPFCheckbox_BISF.IsChecked -eq $true) {$Script:BISF = 1}
        Else {$Script:BISF = 0}
        If ($WPFCheckbox_CitrixHypervisorTools.IsChecked -eq $true) {$Script:Citrix_Hypervisor_Tools = 1}
        Else {$Script:Citrix_Hypervisor_Tools = 0}
        If ($WPFCheckbox_CitrixWorkspaceApp.IsChecked -eq $true) {$Script:Citrix_WorkspaceApp = 1}
        Else {$Script:Citrix_WorkspaceApp = 0}
        If ($WPFCheckbox_Filezilla.IsChecked -eq $true) {$Script:Filezilla = 1}
        Else {$Script:Filezilla = 0}
        If ($WPFCheckbox_Firefox.IsChecked -eq $true) {$Script:Firefox = 1}
        Else {$Script:Firefox = 0}
        If ($WPFCheckbox_MSFSLogix.IsChecked -eq $true) {$Script:MSFSLogix = 1}
        Else {$Script:MSFSLogix = 0}
        If ($WPFCheckbox_FoxitReader.Ischecked -eq $true) {$Script:Foxit_Reader = 1}
        Else {$Script:Foxit_Reader = 0}
        If ($WPFCheckbox_GoogleChrome.ischecked -eq $true) {$Script:GoogleChrome = 1}
        Else {$Script:GoogleChrome = 0}
        If ($WPFCheckbox_Greenshot.ischecked -eq $true) {$Script:Greenshot = 1}
        Else {$Script:Greenshot = 0}
        If ($WPFCheckbox_IrfanView.ischecked -eq $true) {$Script:IrfanView = 1}
        Else {$Script:IrfanView = 0}
        If ($WPFCheckbox_KeePass.ischecked -eq $true) {$Script:KeePass = 1}
        Else {$Script:KeePass = 0}
        If ($WPFCheckbox_mRemoteNG.ischecked -eq $true) {$Script:mRemoteNG = 1}
        Else {$Script:mRemoteNG = 0}
        If ($WPFCheckbox_MS365Apps.ischecked -eq $true) {$Script:MS365Apps = 1}
        Else {$Script:MS365Apps = 0}
        If ($WPFCheckbox_MSEdge.ischecked -eq $true) {$Script:MSEdge = 1}
        Else {$Script:MSEdge = 0}
        If ($WPFCheckbox_MSEdgeWebView2.ischecked -eq $true) {$Script:MSEdgeWebView2 = 1}
        Else {$Script:MSEdgeWebView2 = 0}
        If ($WPFCheckbox_MSOffice.ischecked -eq $true) {$Script:MSOffice = 1}
        Else {$Script:MSOffice = 0}
        If ($WPFCheckbox_MSOneDrive.ischecked -eq $true) {$Script:MSOneDrive = 1}
        Else {$Script:MSOneDrive = 0}
        If ($WPFCheckbox_MSTeams.ischecked -eq $true) {$Script:MSTeams = 1}
        Else {$Script:MSTeams = 0}
        If ($WPFCheckbox_NotePadPlusPlus.ischecked -eq $true) {$Script:NotePadPlusPlus = 1}
        Else {$Script:NotePadPlusPlus = 0}
        If ($WPFCheckbox_OpenJDK.ischecked -eq $true) {$Script:OpenJDK = 1}
        Else {$Script:OpenJDK = 0}
        If ($WPFCheckbox_OracleJava8.ischecked -eq $true) {$Script:OracleJava8 = 1}
        Else {$Script:OracleJava8 = 0}
        If ($WPFCheckbox_TreeSize.ischecked -eq $true) {$Script:TreeSize = 1}
        Else {$Script:TreeSize = 0}
        If ($WPFCheckbox_VLCPlayer.ischecked -eq $true) {$Script:VLCPlayer = 1}
        Else {$Script:VLCPlayer = 0}
        If ($WPFCheckbox_VMwareTools.ischecked -eq $true) {$Script:VMwareTools = 1}
        Else {$Script:VMwareTools = 0}
        If ($WPFCheckbox_WinSCP.ischecked -eq $true) {$Script:WinSCP = 1}
        Else {$Script:WinSCP = 0}        
        If ($WPFCheckbox_MSTeams_No_AutoStart.ischecked -eq $true) {$Script:MSTeamsNoAutoStart = 1}
        Else {$Script:MSTeamsNoAutoStart = 0}
        If ($WPFCheckbox_deviceTRUST.ischecked -eq $true) {$Script:deviceTRUST = 1}
        Else {$Script:deviceTRUST = 0}
        If ($WPFCheckbox_MSDotNetFramework.ischecked -eq $true) {$Script:MSDotNetFramework = 1}
        Else {$Script:MSDotNetFramework = 0}
        If ($WPFCheckbox_MSPowerShell.ischecked -eq $true) {$Script:MSPowerShell = 1}
        Else {$Script:MSPowerShell = 0}
        If ($WPFCheckbox_RemoteDesktopManager.ischecked -eq $true) {$Script:RemoteDesktopManager = 1}
        Else {$Script:RemoteDesktopManager = 0}
        If ($WPFCheckbox_Slack.ischecked -eq $true) {$Script:Slack = 1}
        Else {$Script:Slack = 0}
        If ($WPFCheckbox_ShareX.ischecked -eq $true) {$Script:ShareX = 1}
        Else {$Script:ShareX = 0}
        If ($WPFCheckbox_Zoom.ischecked -eq $true) {$Script:Zoom = 1}
        Else {$Script:Zoom = 0}
        If ($WPFCheckbox_GIMP.ischecked -eq $true) {$Script:GIMP = 1}
        Else {$Script:GIMP = 0}
        If ($WPFCheckbox_MSPowerToys.ischecked -eq $true) {$Script:MSPowerToys = 1}
        Else {$Script:MSPowerToys = 0}
        If ($WPFCheckbox_MSVisualStudio.ischecked -eq $true) {$Script:MSVisualStudio = 1}
        Else {$Script:MSVisualStudio = 0}
        If ($WPFCheckbox_MSVisualStudioCode.ischecked -eq $true) {$Script:MSVisualStudioCode = 1}
        Else {$Script:MSVisualStudioCode = 0}
        If ($WPFCheckbox_PaintDotNet.ischecked -eq $true) {$Script:PaintDotNet = 1}
        Else {$Script:PaintDotNet = 0}
        If ($WPFCheckbox_Putty.ischecked -eq $true) {$Script:Putty = 1}
        Else {$Script:Putty = 0}
        If ($WPFCheckbox_TeamViewer.ischecked -eq $true) {$Script:TeamViewer = 1}
        Else {$Script:TeamViewer = 0}
        If ($WPFCheckbox_Wireshark.ischecked -eq $true) {$Script:Wireshark = 1}
        Else {$Script:Wireshark = 0}
        If ($WPFCheckbox_MSAzureDataStudio.ischecked -eq $true) {$Script:MSAzureDataStudio = 1}
        Else {$Script:MSAzureDataStudio = 0}
        If ($WPFCheckbox_ImageGlass.ischecked -eq $true) {$Script:ImageGlass = 1}
        Else {$Script:ImageGlass = 0}
        If ($WPFCheckbox_ControlUpEdgeDX.ischecked -eq $true) {$Script:ControlUpEdgeDX = 1}
        Else {$Script:ControlUpEdgeDX = 0}
        If ($WPFCheckbox_1Password.ischecked -eq $true) {$Script:1Password = 1}
        Else {$Script:1Password = 0}
        If ($WPFCheckbox_ControlUpAgent.ischecked -eq $true) {$Script:ControlUpAgent = 1}
        Else {$Script:ControlUpAgent = 0}
        If ($WPFCheckbox_ControlUpConsole.ischecked -eq $true) {$Script:ControlUpConsole = 1}
        Else {$Script:ControlUpConsole = 0}
        If ($WPFCheckbox_MSSQLServerManagementStudio.ischecked -eq $true) {$Script:MSSQLServerManagementStudio = 1}
        Else {$Script:MSSQLServerManagementStudio = 0}
        If ($WPFCheckbox_MSAVDRemoteDesktop.ischecked -eq $true) {$Script:MSAVDRemoteDesktop = 1}
        Else {$Script:MSAVDRemoteDesktop = 0}
        If ($WPFCheckbox_MSPowerBIDesktop.ischecked -eq $true) {$Script:MSPowerBIDesktop = 1}
        Else {$Script:MSPowerBIDesktop = 0}
        If ($WPFCheckbox_RDAnalyzer.ischecked -eq $true) {$Script:RDAnalyzer = 1}
        Else {$Script:RDAnalyzer = 0}
        If ($WPFCheckbox_SumatraPDF.ischecked -eq $true) {$Script:SumatraPDF = 1}
        Else {$Script:SumatraPDF = 0}
        If ($WPFCheckbox_CiscoWebexTeams.ischecked -eq $true) {$Script:CiscoWebexTeams = 1}
        Else {$Script:CiscoWebexTeams = 0}
        If ($WPFCheckbox_CitrixFiles.ischecked -eq $true) {$Script:CitrixFiles = 1}
        Else {$Script:CitrixFiles = 0}
        If ($WPFCheckbox_FoxitPDFEditor.ischecked -eq $true) {$Script:FoxitPDFEditor = 1}
        Else {$Script:FoxitPDFEditor = 0}
        If ($WPFCheckbox_GitForWindows.ischecked -eq $true) {$Script:GitForWindows = 1}
        Else {$Script:GitForWindows = 0}
        If ($WPFCheckbox_LogMeInGoToMeeting.ischecked -eq $true) {$Script:LogMeInGoToMeeting = 1}
        Else {$Script:LogMeInGoToMeeting = 0}
        If ($WPFCheckbox_MSAzureCLI.ischecked -eq $true) {$Script:MSAzureCLI = 1}
        Else {$Script:MSAzureCLI = 0}
        If ($WPFCheckbox_MSPowerBIReportBuilder.ischecked -eq $true) {$Script:MSPowerBIReportBuilder = 1}
        Else {$Script:MSPowerBIReportBuilder = 0}
        If ($WPFCheckbox_MSSysinternals.ischecked -eq $true) {$Script:MSSysinternals = 1}
        Else {$Script:MSSysinternals = 0}
        If ($WPFCheckbox_Nmap.ischecked -eq $true) {$Script:Nmap = 1}
        Else {$Script:Nmap = 0}
        If ($WPFCheckbox_PeaZip.ischecked -eq $true) {$Script:PeaZip = 1}
        Else {$Script:PeaZip = 0}
        If ($WPFCheckbox_TechSmithCamtasia.ischecked -eq $true) {$Script:TechSmithCamtasia = 1}
        Else {$Script:TechSmithCamtasia = 0}
        If ($WPFCheckbox_TechSmithSnagIt.ischecked -eq $true) {$Script:TechSmithSnagIt = 1}
        Else {$Script:TechSmithSnagIt = 0}
        If ($WPFCheckbox_WinMerge.ischecked -eq $true) {$Script:WinMerge = 1}
        Else {$Script:WinMerge = 0}
        If ($WPFCheckbox_WhatIf.ischecked -eq $true) {$Script:WhatIf = 1}
        Else {$Script:WhatIf = 0}
        If ($WPFCheckbox_CleanUp.ischecked -eq $true) {$Script:CleanUp = 1}
        Else {$Script:CleanUp = 0}
        If ($WPFCheckbox_MS365Apps_Visio_Detail.ischecked -eq $true) {$Script:MS365Apps_Visio = 1}
        Else {$Script:MS365Apps_Visio = 0}
        If ($WPFCheckbox_MS365Apps_Project_Detail.ischecked -eq $true) {$Script:MS365Apps_Project = 1}
        Else {$Script:MS365Apps_Project = 0}
        If ($WPFCheckbox_AutodeskDWGTrueView.ischecked -eq $true) {$Script:AutodeskDWGTrueView = 1}
        Else {$Script:AutodeskDWGTrueView = 0}
        If ($WPFCheckbox_MindView7.ischecked -eq $true) {$Script:MindView7 = 1}
        Else {$Script:MindView7 = 0}
        If ($WPFCheckbox_PDFsam.ischecked -eq $true) {$Script:PDFsam = 1}
        Else {$Script:PDFsam = 0}
        If ($WPFCheckbox_OpenShellMenu.ischecked -eq $true) {$Script:OpenShellMenu = 1}
        Else {$Script:OpenShellMenu = 0}
        If ($WPFCheckbox_PDFForgeCreator.ischecked -eq $true) {$Script:PDFForgeCreator = 1}
        Else {$Script:PDFForgeCreator = 0}
        If ($WPFCheckbox_TotalCommander.ischecked -eq $true) {$Script:TotalCommander = 1}
        Else {$Script:TotalCommander = 0}
        If ($WPFCheckbox_Repository.ischecked -eq $true) {$Script:Repository = 1}
        Else {$Script:Repository = 0}
        If ($WPFCheckbox_CleanUpStartMenu.ischecked -eq $true) {$Script:CleanUpStartMenu = 1}
        Else {$Script:CleanUpStartMenu = 0}
        If ($WPFCheckbox_MSVisualCPlusPlusRuntime.ischecked -eq $true) {$Script:MSVisualCPlusPlusRuntime = 1}
        Else {$Script:MSVisualCPlusPlusRuntime = 0}
        If ($WPFCheckbox_MSOffice_Visio_Detail.ischecked -eq $true) {$Script:MSOffice_Visio = 1}
        Else {$Script:MSOffice_Visio = 0}
        If ($WPFCheckbox_MSOffice_Project_Detail.ischecked -eq $true) {$Script:MSOffice_Project = 1}
        Else {$Script:MSOffice_Project = 0}
        If ($WPFCheckbox_MozillaThunderbird.ischecked -eq $true) {$Script:MozillaThunderbird = 1}
        Else {$Script:MozillaThunderbird = 0}
        If ($WPFCheckbox_PDF24Creator.ischecked -eq $true) {$Script:PDF24Creator = 1}
        Else {$Script:PDF24Creator = 0}
        If ($WPFCheckbox_WinRAR.ischecked -eq $true) {$Script:WinRAR = 1}
        Else {$Script:WinRAR = 0}
        If ($WPFCheckbox_Ditto.ischecked -eq $true) {$Script:Ditto = 1}
        Else {$Script:Ditto = 0}
        If ($WPFCheckbox_OperaBrowser.ischecked -eq $true) {$Script:OperaBrowser = 1}
        Else {$Script:OperaBrowser = 0}
        If ($WPFCheckbox_XCA.ischecked -eq $true) {$Script:XCA = 1}
        Else {$Script:XCA = 0}
        If ($WPFCheckbox_IISCrypto.ischecked -eq $true) {$Script:IISCrypto = 1}
        Else {$Script:IISCrypto = 0}
        If ($WPFCheckbox_Screenpresso.ischecked -eq $true) {$Script:Screenpresso = 1}
        Else {$Script:Screenpresso = 0}
        If ($WPFCheckbox_ControlUpRemoteDX.ischecked -eq $true) {$Script:ControlUpRemoteDX = 1}
        Else {$Script:ControlUpRemoteDX = 0}
        If ($WPFCheckbox_Report.ischecked -eq $true) {$Script:Report = 1}
        Else {$Script:Report = 0}
        If ($WPFCheckbox_NoDesktopIcon.ischecked -eq $true) {$Script:NoDesktopIcon = 1}
        Else {$Script:NoDesktopIcon = 0}
        If ($WPFCheckbox_MSTeamsAVD.ischecked -eq $true) {$Script:MSTeamsAVD = 1}
        Else {$Script:MSTeamsAVD = 0}
        If ($WPFCheckbox_AdoptOpenJDK.ischecked -eq $true) {$Script:AdoptOpenJDK = 1}
        Else {$Script:AdoptOpenJDK = 0}
        If ($WPFCheckbox_Bloomberg.ischecked -eq $true) {$Script:Bloomberg = 1}
        Else {$Script:Bloomberg = 0}
        If ($WPFCheckbox_GoogleDrive.ischecked -eq $true) {$Script:GoogleDrive = 1}
        Else {$Script:GoogleDrive = 0}
        If ($WPFCheckbox_JabraDirect.ischecked -eq $true) {$Script:JabraDirect = 1}
        Else {$Script:JabraDirect = 0}
        If ($WPFCheckbox_AdoptOpenJDKIcedTeaWeb.ischecked -eq $true) {$Script:AdoptOpenJDKIcedTeaWeb = 1}
        Else {$Script:AdoptOpenJDKIcedTeaWeb = 0}
        If ($WPFCheckbox_OpenWebStart.ischecked -eq $true) {$Script:OpenWebStart = 1}
        Else {$Script:OpenWebStart = 0}
        If ($WPFCheckbox_WindowsUpdate.ischecked -eq $true) {$Script:WindowsUpdate = 1}
        Else {$Script:WindowsUpdate = 0}
        If ($WPFCheckbox_MSTeamsNew.ischecked -eq $true) {$Script:MSTeamsNew = 1}
        Else {$Script:MSTeamsNew = 0}
        If ($WPFCheckbox_MSTeamsAVDNew.ischecked -eq $true) {$Script:MSTeamsAVDNew = 1}
        Else {$Script:MSTeamsAVDNew = 0}
        If ($WPFCheckbox_MobaXterm.ischecked -eq $true) {$Script:MobaXterm = 1}
        Else {$Script:MobaXterm = 0}
        $Script:Language = $WPFBox_Language.SelectedIndex
        $Script:Architecture = $WPFBox_Architecture.SelectedIndex
        $Script:Installer = $WPFBox_Installer.SelectedIndex
        $Script:FirefoxChannel = $WPFBox_Firefox.SelectedIndex
        $Script:CitrixWorkspaceAppRelease = $WPFBox_CitrixWorkspaceApp.SelectedIndex
        $Script:MS365AppsChannel = $WPFBox_MS365Apps.SelectedIndex
        $Script:MSOneDriveRing = $WPFBox_MSOneDrive.SelectedIndex
        $Script:MSTeamsRing = $WPFBox_MSTeams.SelectedIndex
        $Script:TreeSizeType = $WPFBox_TreeSize.SelectedIndex
        $Script:MSDotNetFrameworkChannel = $WPFBox_MSDotNetFramework.SelectedIndex
        $Script:MSPowerShellRelease = $WPFBox_MSPowerShell.SelectedIndex
        $Script:RemoteDesktopManagerType = $WPFBox_RemoteDesktopManager.SelectedIndex
        $Script:ZoomCitrixClient = $WPFBox_Zoom.SelectedIndex
        $Script:deviceTRUSTPackage = $WPFBox_deviceTRUST.SelectedIndex
        $Script:MSEdgeChannel = $WPFBox_MSEdge.SelectedIndex
        $Script:MSVisualStudioCodeChannel = $WPFBox_MSVisualStudioCode.SelectedIndex
        $Script:MSVisualStudioEdition = $WPFBox_MSVisualStudio.SelectedIndex
        $Script:PuttyChannel = $WPFBox_Putty.SelectedIndex
        $Script:MSAzureDataStudioChannel = $WPFBox_MSAzureDataStudio.SelectedIndex
        $Script:MSFSLogixChannel = $WPFBox_MSFSLogix.SelectedIndex
        $Script:OperaBrowserChannel = $WPFBox_OperaBrowser.SelectedIndex
        $Script:MSAVDRemoteDesktopChannel = $WPFBox_MSAVDRemoteDesktop.SelectedIndex
        $Script:7Zip_Architecture = $WPFBox_7Zip_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Architecture = $WPFBox_AdobeReaderDC_Architecture.SelectedIndex
        $Script:AdobeReaderDC_Language = $WPFBox_AdobeReaderDC_Language.SelectedIndex
        $Script:CiscoWebexTeams_Architecture = $WPFBox_CiscoWebexTeams_Architecture.SelectedIndex
        $Script:CitrixHypervisorTools_Architecture = $WPFBox_CitrixHypervisorTools_Architecture.SelectedIndex
        $Script:ControlUpAgent_Architecture = $WPFBox_ControlUpAgent_Architecture.SelectedIndex
        $Script:deviceTRUST_Architecture = $WPFBox_deviceTRUST_Architecture.SelectedIndex
        $Script:FoxitPDFEditor_Language = $WPFBox_FoxitPDFEditor_Language.SelectedIndex
        $Script:FoxitReader_Language = $WPFBox_FoxitReader_Language.SelectedIndex
        $Script:GitForWindows_Architecture = $WPFBox_GitForWindows_Architecture.SelectedIndex
        $Script:GoogleChrome_Architecture = $WPFBox_GoogleChrome_Architecture.SelectedIndex
        $Script:ImageGlass_Architecture = $WPFBox_ImageGlass_Architecture.SelectedIndex
        $Script:IrfanView_Architecture = $WPFBox_IrfanView_Architecture.SelectedIndex
        $Script:Keepass_Language = $WPFBox_KeePass_Language.SelectedIndex
        $Script:MSDotNetFramework_Architecture = $WPFBox_MSDotNetFramework_Architecture.SelectedIndex
        $Script:MS365Apps_Architecture = $WPFBox_MS365Apps_Architecture.SelectedIndex
        $Script:MS365Apps_Language = $WPFBox_MS365Apps_Language.SelectedIndex
        $Script:MS365Apps_Visio_Language = $WPFBox_MS365Apps_Visio_Language.SelectedIndex
        $Script:MS365Apps_Project_Language = $WPFBox_MS365Apps_Project_Language.SelectedIndex
        $Script:MSAVDRemoteDesktop_Architecture = $WPFBox_MSAVDRemoteDesktop_Architecture.SelectedIndex
        $Script:MSEdge_Architecture = $WPFBox_MSEdge_Architecture.SelectedIndex
        $Script:MSFSLogix_Architecture = $WPFBox_MSFSLogix_Architecture.SelectedIndex
        $Script:MSOffice_Architecture = $WPFBox_MSOffice_Architecture.SelectedIndex
        $Script:MSOneDrive_Architecture = $WPFBox_MSOneDrive_Architecture.SelectedIndex
        $Script:MSPowerBIDesktop_Architecture = $WPFBox_MSPowerBIDesktop_Architecture.SelectedIndex
        $Script:MSPowerShell_Architecture = $WPFBox_MSPowerShell_Architecture.SelectedIndex
        $Script:MSSQLServerManagementStudio_Language = $WPFBox_MSSQLServerManagementStudio_Language.SelectedIndex
        $Script:MSTeams_Architecture = $WPFBox_MSTeams_Architecture.SelectedIndex
        $Script:MSVisualStudioCode_Architecture = $WPFBox_MSVisualStudioCode_Architecture.SelectedIndex
        $Script:Firefox_Architecture = $WPFBox_Firefox_Architecture.SelectedIndex
        $Script:Firefox_Language = $WPFBox_Firefox_Language.SelectedIndex
        $Script:NotePadPlusPlus_Architecture = $WPFBox_NotepadPlusPlus_Architecture.SelectedIndex
        $Script:OpenJDK_Architecture = $WPFBox_OpenJDK_Architecture.SelectedIndex
        $Script:OracleJava8_Architecture = $WPFBox_OracleJava8_Architecture.SelectedIndex
        $Script:PeaZip_Architecture = $WPFBox_PeaZip_Architecture.SelectedIndex
        $Script:Putty_Architecture = $WPFBox_Putty_Architecture.SelectedIndex
        $Script:Slack_Architecture = $WPFBox_Slack_Architecture.SelectedIndex
        $Script:SumatraPDF_Architecture = $WPFBox_SumatraPDF_Architecture.SelectedIndex
        $Script:TechSmithSnagIt_Architecture = $WPFBox_TechSmithSnagIT_Architecture.SelectedIndex
        $Script:VLCPlayer_Architecture = $WPFBox_VLCPlayer_Architecture.SelectedIndex
        $Script:VMwareTools_Architecture = $WPFBox_VMwareTools_Architecture.SelectedIndex
        $Script:WinMerge_Architecture = $WPFBox_WinMerge_Architecture.SelectedIndex
        $Script:Wireshark_Architecture = $WPFBox_Wireshark_Architecture.SelectedIndex
        $Script:IrfanView_Language = $WPFBox_IrfanView_Language.SelectedIndex
        $Script:MSOffice_Language = $WPFBox_MSOffice_Language.SelectedIndex
        $Script:MS365Apps_Path = $WPFTextBox_Filename.Text
        $Script:MSEdgeWebView2_Architecture = $WPFBox_MSEdgeWebView2_Architecture.SelectedIndex
        $Script:MindView7_Language = $WPFBox_MindView7_Language.SelectedIndex
        $Script:MSOfficeVersion = $WPFBox_MSOffice.SelectedIndex
        $Script:LogMeInGoToMeeting_Installer = $WPFBox_LogMeInGoToMeeting_Installer.SelectedIndex
        $Script:MSAzureDataStudio_Installer = $WPFBox_MSAzureDataStudio_Installer.SelectedIndex
        $Script:MSVisualStudioCode_Installer = $WPFBox_MSVisualStudioCode_Installer.SelectedIndex
        $Script:MS365Apps_Installer = $WPFBox_MS365Apps_Installer.SelectedIndex
        $Script:MSTeams_Installer = $WPFBox_MSTeams_Installer.SelectedIndex
        $Script:Zoom_Installer = $WPFBox_Zoom_Installer.SelectedIndex
        $Script:MSOneDrive_Installer = $WPFBox_MSOneDrive_Installer.SelectedIndex
        $Script:Slack_Installer = $WPFBox_Slack_Installer.SelectedIndex
        $Script:pdfforgePDFCreatorChannel = $WPFBox_pdfforgePDFCreator.SelectedIndex
        $Script:TotalCommander_Architecture = $WPFBox_TotalCommander_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntime_Architecture = $WPFBox_MSVisualCPlusPlusRuntime_Architecture.SelectedIndex
        $Script:MSVisualCPlusPlusRuntimeRelease = $WPFBox_MSVisualCPlusPlusRuntime.SelectedIndex
        $Script:MSOffice_Visio_Language = $WPFBox_MSOffice_Visio_Language.SelectedIndex
        $Script:MSOffice_Project_Language = $WPFBox_MSOffice_Project_Language.SelectedIndex
        $Script:Zoom_Architecture = $WPFBox_Zoom_Architecture.SelectedIndex
        $Script:CiscoWebexTeamsClient = $WPFBox_CiscoWebexTeams.SelectedIndex
        $Script:AdobeProDC_Architecture = $WPFBox_AdobeProDC_Architecture.SelectedIndex
        $Script:GoogleChromeChannel = $WPFBox_GoogleChrome.SelectedIndex
        $Script:OpenJDKPackage = $WPFBox_OpenJDK.SelectedIndex
        $Script:PaintDotNet_Architecture = $WPFBox_PaintDotNet_Architecture.SelectedIndex
        $Script:WinRAR_Architecture = $WPFBox_WinRAR_Architecture.SelectedIndex
        $Script:WinRAR_Language = $WPFBox_WinRAR_Language.SelectedIndex
        $Script:WinRARChannel = $WPFBox_WinRAR.SelectedIndex
        $Script:MozillaThunderbird_Architecture = $WPFBox_MozillaThunderbird_Architecture.SelectedIndex
        $Script:MozillaThunderbird_Language = $WPFBox_MozillaThunderbird_Language.SelectedIndex
        $Script:MSAzureDataStudio_Architecture = $WPFBox_MSAzureDataStudio_Architecture.SelectedIndex
        $Script:TeamViewer_Architecture = $WPFBox_TeamViewer_Architecture.SelectedIndex
        $Script:Ditto_Architecture = $WPFBox_Ditto_Architecture.SelectedIndex
        $Script:Ditto_Channel = $WPFBox_Ditto.SelectedIndex
        $Script:OperaBrowser_Architecture = $WPFBox_OperaBrowser_Architecture.SelectedIndex
        $Script:ControlUpEdgeDX_Installer = $WPFBox_ControlUpEdgeDX_Installer.SelectedIndex
        $Script:BISF_Tools = $WPFBox_BISF_Tools.SelectedIndex
        $Script:ControlUpRemoteDXEUC = $WPFBox_ControlUpRemoteDX.SelectedIndex
        $Script:ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        $Script:ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $Script:ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        $Script:AdoptOpenJDKVersion = $WPFBox_AdoptOpenJDK.SelectedIndex
        $Script:AdoptOpenJDK_Architecture = $WPFBox_AdoptOpenJDK_Architecture.SelectedIndex
        $Script:OpenWebStart_Architecture = $WPFBox_OpenWebStart_Architecture.SelectedIndex
        $Script:MSTeamsNew_Architecture = $WPFBox_MSTeamsNew_Architecture.SelectedIndex

        # Write LastSetting.txt or -GUIFile Parameter file to get the settings of the last session. (AddScript)
        $Language,$Architecture,$CitrixWorkspaceAppRelease,$MS365AppsChannel,$MSOneDriveRing,$MSTeamsRing,$FirefoxChannel,$TreeSizeType,$7ZIP,$AdobeProDC,$AdobeReaderDC,$BISF,$Citrix_Hypervisor_Tools,$Citrix_WorkspaceApp,$Filezilla,$Firefox,$Foxit_Reader,$MSFSLogix,$GoogleChrome,$Greenshot,$KeePass,$mRemoteNG,$MS365Apps,$MSEdge,$MSOffice,$MSOneDrive,$MSTeams,$NotePadPlusPlus,$OpenJDK,$OracleJava8,$TreeSize,$VLCPlayer,$VMwareTools,$WinSCP,$Download,$Install,$IrfanView,$MSTeamsNoAutoStart,$deviceTRUST,$MSDotNetFramework,$MSDotNetFrameworkChannel,$MSPowerShell,$MSPowerShellRelease,$RemoteDesktopManager,$RemoteDesktopManagerType,$Slack,$Wireshark,$ShareX,$Zoom,$ZoomCitrixClient,$deviceTRUSTPackage,$MSEdgeChannel,$GIMP,$MSPowerToys,$MSVisualStudio,$MSVisualStudioCode,$MSVisualStudioCodeChannel,$PaintDotNet,$Putty,$TeamViewer,$Installer,$MSVisualStudioEdition,$PuttyChannel,$MSAzureDataStudio,$MSAzureDataStudioChannel,$ImageGlass,$MSFSLogixChannel,$ControlUpEdgeDX,$1Password,$SumatraPDF,$ControlUpAgent,$OperaBrowserChannel,$ControlUpConsole,$MSSQLServerManagementStudio,$MSAVDRemoteDesktop,$MSAVDRemoteDesktopChannel,$MSPowerBIDesktop,$RDAnalyzer,$CiscoWebexTeams,$CitrixFiles,$FoxitPDFEditor,$GitForWindows,$LogMeInGoToMeeting,$MSAzureCLI,$MSPowerBIReportBuilder,$MSSysinternals,$NMap,$PeaZip,$TechSmithCamtasia,$TechSmithSnagit,$WinMerge,$WhatIf,$CleanUp,$7Zip_Architecture,$AdobeReaderDC_Architecture,$AdobeReaderDC_Language,$CiscoWebexTeams_Architecture,$CitrixHypervisorTools_Architecture,$ControlUpAgent_Architecture,$deviceTRUST_Architecture,$FoxitPDFEditor_Language,$FoxitReader_Language,$GitForWindows_Architecture,$GoogleChrome_Architecture,$ImageGlass_Architecture,$IrfanView_Architecture,$Keepass_Language,$MSDotNetFramework_Architecture,$MS365Apps_Architecture,$MS365Apps_Language,$MS365Apps_Visio,$MS365Apps_Visio_Language,$MS365Apps_Project,$MS365Apps_Project_Language,$MSAVDRemoteDesktop_Architecture,$MSEdge_Architecture,$MSFSLogix_Architecture,$MSOffice_Architecture,$MSOneDrive_Architecture,$MSPowerBIDesktop_Architecture,$MSPowerShell_Architecture,$MSSQLServerManagementStudio_Language,$MSTeams_Architecture,$MSVisualStudioCode_Architecture,$Firefox_Architecture,$Firefox_Language,$NotePadPlusPlus_Architecture,$OpenJDK_Architecture,$OracleJava8_Architecture,$PeaZip_Architecture,$Putty_Architecture,$Slack_Architecture,$SumatraPDF_Architecture,$TechSmithSnagIt_Architecture,$VLCPlayer_Architecture,$VMwareTools_Architecture,$WinMerge_Architecture,$Wireshark_Architecture,$IrfanView_Language,$MSOffice_Language,$MSEdgeWebView2,$MSEdgeWebView2_Architecture,$AutodeskDWGTrueView,$MindView7,$MindView7_Language,$PDFsam,$MSOfficeVersion,$OpenShellMenu,$PDFForgeCreator,$TotalCommander,$LogMeInGoToMeeting_Installer,$MSAzureDataStudio_Installer,$MSVisualStudioCode_Installer,$MS365Apps_Installer,$Zoom_Architecture,$MSTeams_Installer,$Zoom_Installer,$MSOneDrive_Installer,$Slack_Installer,$pdfforgePDFCreatorChannel,$TotalCommander_Architecture,$Repository,$CleanUpStartMenu,$MSVisualCPlusPlusRuntime,$MSVisualCPlusPlusRuntimeRelease,$MSVisualCPlusPlusRuntime_Architecture,$MSOffice_Visio,$MSOffice_Visio_Language,$MSOffice_Project,$MSOffice_Project_Language,$CiscoWebexTeamsClient,$BISF_Tools,$MozillaThunderbird,$PDF24Creator,$WinRAR,$AdobeProDC_Architecture,$GoogleChromeChannel,$OpenJDKPackage,$PaintDotNet_Architecture,$WinRAR_Architecture,$WinRAR_Language,$WinRARChannel,$MozillaThunderbird_Architecture,$MozillaThunderbird_Language,$MSAzureDataStudio_Architecture,$TeamViewer_Architecture,$OperaBrowser,$OperaBrowser_Architecture,$Ditto,$Ditto_Architecture,$Ditto_Channel,$XCA,$ControlUpEdgeDX_Installer,$ControlUpRemoteDX,$IISCrypto,$Screenpresso,$Report,$NoDesktopIcon,$ControlUpRemoteDXEUC,$MSTeamsAVD,$AdoptOpenJDK,$AdoptOpenJDKVersion,$Bloomberg,$GoogleDrive,$JabraDirect,$AdoptOpenJDKIcedTeaWeb,$OpenWebStart,$AdoptOpenJDK_Architecture,$OpenWebStart_Architecture,$WindowsUpdate,$MSTeamsNew,$MSTeamsAVDNew,$MobaXterm,$MSTeamsNew_Architecture | out-file -filepath "$PSScriptRoot\$GUIfile"

        # Write ControlUp data in the files.
        $ControlUpAgentAuthKey = $WPFTextBox_ControlUpAgentAuthKey.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Agent")) {New-Item -Path "$PSScriptRoot\ControlUp Agent" -ItemType Directory | Out-Null}
        $ControlUpAgentAuthKey | out-file -filepath "$PSScriptRoot\ControlUp Agent\AuthKey.txt"
        $ControlUpEdgeDXDevRegCode = $WPFTextBox_ControlUpEdgeDXDevRegCode.Text
        $ControlUpEdgeDXTenantName = $WPFTextBox_ControlUpEdgeDXTenantName.Text
        If (!(Test-Path -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager")) {New-Item -Path "$PSScriptRoot\ControlUp Edge DX Agent Manager" -ItemType Directory | Out-Null}
        $ControlUpEdgeDXDevRegCode | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\DevRegCode.txt"
        $ControlUpEdgeDXTenantName | out-file -filepath "$PSScriptRoot\ControlUp Edge DX Agent Manager\TenantName.txt"
        

        If ($MS365Apps_Path -ne "") {
            If ($WhatIf -eq '0') {
                If ($MS365Apps -eq 1) {
                    Switch ($MS365AppsChannel) {
                        0 { $MS365AppsChannelClear = 'Beta Channel'}
                        1 { $MS365AppsChannelClear = 'Current Channel (Preview)'}
                        2 { $MS365AppsChannelClear = 'Current Channel'}
                        3 { $MS365AppsChannelClear = 'Semi-Annual Channel (Preview)'}
                        4 { $MS365AppsChannelClear = 'Monthly Enterprise Channel'}
                        5 { $MS365AppsChannelClear = 'Semi-Annual Channel'}
                    }
                    If (!(Test-Path -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear")) {New-Item -Path "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear" -ItemType Directory | Out-Null}
                    Copy-Item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\Microsoft 365 Apps\$MS365AppsChannelClear\install.xml" -Force
                    Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft 365 Apps $MS365AppsChannelClear folder."
                    Write-Output ""
                }
                If ($MSOffice -eq 1) {
                    Switch ($MSOfficeVersion) {
                        0 { $MSOfficeChannelClear = '2019'}
                        1 { $MSOfficeChannelClear = '2021 LTSC'}
                    }
                    $OfficePath = "Microsoft Office " + $MSOfficeChannelClear
                    If (!(Test-Path -Path "$PSScriptRoot\$OfficePath")) {New-Item -Path "$PSScriptRoot\$OfficePath" -ItemType Directory | Out-Null}
                    copy-item -Path "$MS365Apps_Path" -Destination "$PSScriptRoot\$OfficePath\install.xml" -Force
                }
                Write-Host -ForegroundColor Green "Copy custom XML file as install.xml successfully to the Microsoft Office $MSOfficeChannelClear folder."
                Write-Output ""
            }
        }
        # Shortcut Creation
        $Desktop = [Environment]::GetFolderPath([Environment+SpecialFolder]::Desktop)
        If ($NoDesktopIcon -eq "0"){
            If ((Test-Path -Path "$Desktop\Evergreen Script.lnk")) {
                Remove-Item "$Desktop\Evergreen Script.lnk"
            }
            If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                $sh = New-Object -ComObject WScript.Shell
                $target = $sh.CreateShortcut("$Desktop\NeverRed.lnk").TargetPath
                If ($target -ne "$env:ProgramFiles\PowerShell\7") {
                    Remove-Item "$Desktop\NeverRed.lnk"
                } 
            }
            If (!(Test-Path -Path "$Desktop\NeverRed.lnk")) {
                $WScriptShell = New-Object -ComObject 'WScript.Shell'
                $ShortcutFile = "$Desktop\NeverRed.lnk"
                $Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
                If (Test-Path -Path "$env:ProgramFiles\PowerShell\7") {
                    $Shortcut.TargetPath = '"C:\Program Files\PowerShell\7\pwsh.exe"'
                    $Shortcut.WorkingDirectory = '"C:\Program Files\PowerShell\7\"' 
                } else {
                    $Shortcut.TargetPath = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"
                    $Shortcut.WorkingDirectory = "C:\Windows\System32\WindowsPowerShell\v1.0"
                }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut")) { New-Item -Path "$PSScriptRoot\shortcut" -ItemType Directory | Out-Null }
                If (!(Test-Path -Path "$PSScriptRoot\shortcut\NeverRed.ico")) {Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/NeverRed/master/shortcut/NeverRed.ico -OutFile ("$PSScriptRoot\shortcut\" + "NeverRed.ico")}
                $shortcut.IconLocation="$PSScriptRoot\shortcut\NeverRed.ico"
                $Shortcut.Arguments = '-noexit -ExecutionPolicy Bypass -file "' + "$PSScriptRoot" + '\NeverRed.ps1"'
                $Shortcut.Save()
                $Admin = [System.IO.File]::ReadAllBytes("$ShortcutFile")
                $Admin[0x15] = $Admin[0x15] -bor 0x20
                [System.IO.File]::WriteAllBytes("$ShortcutFile", $Admin)
            }
        }
        Write-Host "Save Settings"
    })

    # Image Logo
    $WPFImage_Logo.Add_MouseLeftButtonUp({
        [system.Diagnostics.Process]::start('https://www.deyda.net')
    })

    $WPFImage_Logo_Detail.Add_MouseLeftButtonUp({
        [system.Diagnostics.Process]::start('https://www.deyda.net')
    })

    # Shows the form
    $Form.ShowDialog() | out-null
}

#===========================================================================

Write-Host -Foregroundcolor DarkGray "Software selection"

#// MARK: Define and reset variables
$Date = $Date = Get-Date -UFormat "%m.%d.%Y"

# Define the variables for the unattended install or download (Parameter -ESfile) (AddScript)
If ($ESfile) {
    # Read ESfile Parameter to get the settings. (AddScript)
    If (Test-Path "$ESfile" -PathType leaf) {
        $FileSetting = Get-Content "$ESfile"
        $Language = $FileSetting[0] -as [int]
        $Architecture = $FileSetting[1] -as [int]
        $CitrixWorkspaceAppRelease = $FileSetting[2] -as [int]
        $MS365AppsChannel = $FileSetting[3] -as [int]
        $MSOneDriveRing = $FileSetting[4] -as [int]
        $MSTeamsRing = $FileSetting[5] -as [int]
        $FirefoxChannel = $FileSetting[6] -as [int]
        $TreeSizeType = $FileSetting[7] -as [int]
        $MSDotNetFrameworkChannel = $FileSetting[40] -as [int]
        $MSPowerShellRelease = $FileSetting[42] -as [int]
        $RemoteDesktopManagerType = $FileSetting[44] -as [int]
        $ZoomCitrixClient = $FileSetting[49] -as [int]
        $deviceTRUSTPackage = $FileSetting[50] -as [int]
        $MSEdgeChannel = $FileSetting[51] -as [int]
        $MSVisualStudioCodeChannel = $FileSetting[56] -as [int]
        $Installer = $FileSetting[60] -as [int]
        $MSVisualStudioEdition= $FileSetting[61] -as [int]
        $PuttyChannel = $FileSetting[62] -as [int]
        $MSAzureDataStudioChannel = $FileSetting[64] -as [int]
        $7ZIP = $FileSetting[8] -as [int]
        $AdobeProDC = $FileSetting[9] -as [int]
        $AdobeReaderDC = $FileSetting[10] -as [int]
        $BISF = $FileSetting[11] -as [int]
        $Citrix_Hypervisor_Tools = $FileSetting[12] -as [int]
        $Citrix_WorkspaceApp = $FileSetting[13] -as [int]
        $Filezilla = $FileSetting[14] -as [int]
        $Firefox = $FileSetting[15] -as [int]
        $Foxit_Reader = $FileSetting[16] -as [int]
        $MSFSLogix = $FileSetting[17] -as [int]
        $GoogleChrome = $FileSetting[18] -as [int]
        $Greenshot = $FileSetting[19] -as [int]
        $KeePass = $FileSetting[20] -as [int]
        $mRemoteNG = $FileSetting[21] -as [int]
        $MS365Apps = $FileSetting[22] -as [int]
        $MSEdge = $FileSetting[23] -as [int]
        $MSOffice = $FileSetting[24] -as [int]
        $MSOneDrive = $FileSetting[25] -as [int]
        $MSTeams = $FileSetting[26] -as [int]
        $NotePadPlusPlus = $FileSetting[27] -as [int]
        $OpenJDK = $FileSetting[28] -as [int]
        $OracleJava8 = $FileSetting[29] -as [int]
        $TreeSize = $FileSetting[30] -as [int]
        $VLCPlayer = $FileSetting[31] -as [int]
        $VMwareTools = $FileSetting[32] -as [int]
        $WinSCP = $FileSetting[33] -as [int]
        $Download = $FileSetting[34] -as [int]
        If ($FileSetting[34] -eq "True") {$Download = "1"}
        $Install = $FileSetting[35] -as [int]
        If ($FileSetting[35] -eq "True") {$Install = "1"}
        $IrfanView = $FileSetting[36] -as [int]
        $MSTeamsNoAutoStart = $FileSetting[37] -as [int]
        $deviceTRUST = $FileSetting[38] -as [int]
        $MSDotNetFramework = $FileSetting[39] -as [int]
        $MSPowerShell = $FileSetting[41] -as [int]
        $RemoteDesktopManager = $FileSetting[43] -as [int]
        $Slack = $FileSetting[45] -as [int]
        $Wireshark = $FileSetting[46] -as [int]
        $ShareX = $FileSetting[47] -as [int]
        $Zoom = $FileSetting[48] -as [int]
        $GIMP = $FileSetting[52] -as [int]
        $MSPowerToys = $FileSetting[53] -as [int]
        $MSVisualStudio = $FileSetting[54] -as [int]
        $MSVisualStudioCode = $FileSetting[55] -as [int]
        $PaintDotNet = $FileSetting[57] -as [int]
        $Putty = $FileSetting[58] -as [int]
        $TeamViewer = $FileSetting[59] -as [int]
        $MSAzureDataStudio = $FileSetting[63] -as [int]
        $ImageGlass = $FileSetting[65] -as [int]
        $MSFSLogixChannel = $FileSetting[66] -as [int]
        $ControlUpEdgeDX = $FileSetting[67] -as [int]
        $1Password = $FileSetting[68] -as [int]
        $SumatraPDF = $FileSetting[69] -as [int]
        $ControlUpAgent = $FileSetting[70] -as [int]
        $OperaBrowserChannel = $FileSetting[71] -as [int]
        $ControlUpConsole = $FileSetting[72] -as [int]
        $MSSQLServerManagementStudio = $FileSetting[73] -as [int]
        $MSAVDRemoteDesktop = $FileSetting[74] -as [int]
        $MSAVDRemoteDesktopChannel = $FileSetting[75] -as [int]
        $MSPowerBIDesktop = $FileSetting[76] -as [int]
        $RDAnalyzer = $FileSetting[77] -as [int]
        $CiscoWebexTeams = $FileSetting[78] -as [int]
        $CitrixFiles = $FileSetting[79] -as [int]
        $FoxitPDFEditor = $FileSetting[80] -as [int]
        $GitForWindows = $FileSetting[81] -as [int]
        $LogMeInGoToMeeting = $FileSetting[82] -as [int]
        $MSAzureCLI = $FileSetting[83] -as [int]
        $MSPowerBIReportBuilder = $FileSetting[84] -as [int]
        $MSSysinternals = $FileSetting[85] -as [int]
        $NMap = $FileSetting[86] -as [int]
        $PeaZip = $FileSetting[87] -as [int]
        $TechSmithCamtasia = $FileSetting[88] -as [int]
        $TechSmithSnagit = $FileSetting[89] -as [int]
        $WinMerge = $FileSetting[90] -as [int]
        $WhatIf = $FileSetting[91] -as [int]
        $CleanUp = $FileSetting[92] -as [int]
        $7Zip_Architecture = $FileSetting[93] -as [int]
        $AdobeReaderDC_Architecture = $FileSetting[94] -as [int]
        $AdobeReaderDC_Language = $FileSetting[95] -as [int]
        $CiscoWebexTeams_Architecture = $FileSetting[96] -as [int]
        $CitrixHypervisorTools_Architecture = $FileSetting[97] -as [int]
        $ControlUpAgent_Architecture = $FileSetting[98] -as [int]
        $deviceTRUST_Architecture = $FileSetting[99] -as [int]
        $FoxitPDFEditor_Language = $FileSetting[100] -as [int]
        $FoxitReader_Language = $FileSetting[101] -as [int]
        $GitForWindows_Architecture = $FileSetting[102] -as [int]
        $GoogleChrome_Architecture = $FileSetting[103] -as [int]
        $ImageGlass_Architecture = $FileSetting[104] -as [int]
        $IrfanView_Architecture = $FileSetting[105] -as [int]
        $KeePass_Language = $FileSetting[106] -as [int]
        $MSDotNetFramework_Architecture = $FileSetting[107] -as [int]
        $MS365Apps_Architecture = $FileSetting[108] -as [int]
        $MS365Apps_Language = $FileSetting[109] -as [int]
        $MS365Apps_Visio = $FileSetting[110] -as [int]
        $MS365Apps_Visio_Language = $FileSetting[111] -as [int]
        $MS365Apps_Project = $FileSetting[112] -as [int]
        $MS365Apps_Project_Language = $FileSetting[113] -as [int]
        $MSAVDRemoteDesktop_Architecture = $FileSetting[114] -as [int]
        $MSEdge_Architecture = $FileSetting[115] -as [int]
        $MSFSLogix_Architecture = $FileSetting[116] -as [int]
        $MSOffice_Architecture = $FileSetting[117] -as [int]
        $MSOneDrive_Architecture = $FileSetting[118] -as [int]
        $MSPowerBIDesktop_Architecture = $FileSetting[119] -as [int]
        $MSPowerShell_Architecture = $FileSetting[120] -as [int]
        $MSSQLServerManagementStudio_Language = $FileSetting[121] -as [int]
        $MSTeams_Architecture = $FileSetting[122] -as [int]
        $MSVisualStudioCode_Architecture = $FileSetting[123] -as [int]
        $Firefox_Architecture = $FileSetting[124] -as [int]
        $Firefox_Language = $FileSetting[125] -as [int]
        $NotepadPlusPlus_Architecture = $FileSetting[126] -as [int]
        $OpenJDK_Architecture = $FileSetting[127] -as [int]
        $OracleJava8_Architecture = $FileSetting[128] -as [int]
        $PeaZip_Architecture = $FileSetting[129] -as [int]
        $Putty_Architecture = $FileSetting[130] -as [int]
        $Slack_Architecture = $FileSetting[131] -as [int]
        $SumatraPDF_Architecture = $FileSetting[132] -as [int]
        $TechSmithSnagIt_Architecture = $FileSetting[133] -as [int]
        $VLCPlayer_Architecture = $FileSetting[134] -as [int]
        $VMwareTools_Architecture = $FileSetting[135] -as [int]
        $WinMerge_Architecture = $FileSetting[136] -as [int]
        $Wireshark_Architecture = $FileSetting[137] -as [int]
        $IrfanView_Language = $FileSetting[138] -as [int]
        $MSOffice_Language = $FileSetting[139] -as [int]
        $MSEdgeWebView2 = $FileSetting[140] -as [int]
        $MSEdgeWebView2_Architecture = $FileSetting[141] -as [int]
        $AutodeskDWGTrueView = $FileSetting[142] -as [int]
        $MindView7 = $FileSetting[143] -as [int]
        $MindView7_Language = $FileSetting[144] -as [int]
        $PDFsam = $FileSetting[145] -as [int]
        $MSOfficeVersion = $FileSetting[146] -as [int]
        $OpenShellMenu = $FileSetting[147] -as [int]
        $PDFForgeCreator = $FileSetting[148] -as [int]
        $TotalCommander = $FileSetting[149] -as [int]
        $LogMeInGoToMeeting_Installer = $FileSetting[150] -as [int]
        $MSAzureDataStudio_Installer = $FileSetting[151] -as [int]
        $MSVisualStudioCode_Installer = $FileSetting[152] -as [int]
        $MS365Apps_Installer = $FileSetting[153] -as [int]
        $Zoom_Architecture = $FileSetting[154] -as [int]
        $MSTeams_Installer = $FileSetting[155] -as [int]
        $Zoom_Installer = $FileSetting[156] -as [int]
        $MSOneDrive_Installer = $FileSetting[157] -as [int]
        $Slack_Installer = $FileSetting[158] -as [int]
        $pdfforgePDFCreatorChannel = $FileSetting[159] -as [int]
        $TotalCommander_Architecture = $FileSetting[160] -as [int]
        $Repository = $FileSetting[161] -as [int]
        $CleanUpStartMenu = $FileSetting[162] -as [int]
        $MSVisualCPlusPlusRuntime = $FileSetting[163] -as [int]
        $MSVisualCPlusPlusRuntimeRelease = $FileSetting[164] -as [int]
        $MSVisualCPlusPlusRuntime_Architecture = $FileSetting[165] -as [int]
        $MSOffice_Visio = $FileSetting[166] -as [int]
        $MSOffice_Visio_Language = $FileSetting[167] -as [int]
        $MSOffice_Project = $FileSetting[168] -as [int]
        $MSOffice_Project_Language = $FileSetting[169] -as [int]
        $CiscoWebexTeamsClient = $FileSetting[170] -as [int]
        $BISF_Tools = $FileSetting[171] -as [int]
        $MozillaThunderbird = $FileSetting[172] -as [int]
        $PDF24Creator = $FileSetting[173] -as [int]
        $WinRAR = $FileSetting[174] -as [int]
        $AdobeProDC_Architecture = $FileSetting[175] -as [int]
        $GoogleChromeChannel = $FileSetting[176] -as [int]
        $OpenJDKPackage = $FileSetting[177] -as [int]
        $PaintDotNet_Architecture = $FileSetting[178] -as [int]
        $WinRAR_Architecture = $FileSetting[179] -as [int]
        $WinRAR_Language = $FileSetting[180] -as [int]
        $WinRARChannel = $FileSetting[181] -as [int]
        $MozillaThunderbird_Architecture = $FileSetting[182] -as [int]
        $MozillaThunderbird_Language = $FileSetting[183] -as [int]
        $MSAzureDataStudio_Architecture = $FileSetting[184] -as [int]
        $TeamViewer_Architecture = $FileSetting[185] -as [int]
        $OperaBrowser = $FileSetting[186] -as [int]
        $OperaBrowser_Architecture = $FileSetting[187] -as [int]
        $Ditto = $FileSetting[188] -as [int]
        $Ditto_Architecture = $FileSetting[189] -as [int]
        $Ditto_Channel = $FileSetting[190] -as [int]
        $XCA = $FileSetting[191] -as [int]
        $ControlUpEdgeDX_Installer = $FileSetting[192] -as [int]
        $ControlUpRemoteDX = $FileSetting[193] -as [int]
        $IISCrypto = $FileSetting[194] -as [int]
        $Screenpresso = $FileSetting[195] -as [int]
        $Report = $FileSetting[196] -as [int]
        $NoDesktopIcon = $FileSetting[197] -as [int]
        $ControlUpRemoteDXEUC = $FileSetting[198] -as [int]
        $MSTeamsAVD = $FileSetting[199] -as [int]
        $AdoptOpenJDK = $FileSetting[200] -as [int]
        $AdoptOpenJDKVersion = $FileSetting[201] -as [int]
        $Bloomberg = $FileSetting[202] -as [int]
        $GoogleDrive = $FileSetting[203] -as [int]
        $JabraDirect = $FileSetting[204] -as [int]
        $AdoptOpenJDKIcedTeaWeb = $FileSetting[205] -as [int]
        $OpenWebStart = $FileSetting[206] -as [int]
        $AdoptOpenJDK_Architecture = $FileSetting[207] -as [int]
        $OpenWebStart_Architecture = $FileSetting[208] -as [int]
        $WindowsUpdate = $FileSetting[209] -as [int]
        $MSTeamsNew = $FileSetting[210] -as [int]
        $MSTeamsAVDNew = $FileSetting[211] -as [int]
        $MobaXterm = $FileSetting[212] -as [int]
        $MSTeamsNew_Architecture = $FileSetting[213] -as [int]
    }
    Write-Host "Unattended Mode."
}
Else {
    # Cleanup of the used variables (AddScript)
    Clear-Variable -name Download,Install,7ZIP,AdobeProDC,AdobeReaderDC,BISF,Citrix_Hypervisor_Tools,Filezilla,Firefox,Foxit_Reader,MSFSLogix,Greenshot,GoogleChrome,KeePass,mRemoteNG,MS365Apps,MSEdge,MSOffice,MSTeams,NotePadPlusPlus,MSOneDrive,OpenJDK,OracleJava8,TreeSize,VLCPlayer,VMwareTools,WinSCP,Citrix_WorkspaceApp,Architecture,FirefoxChannel,CitrixWorkspaceAppRelease,Language,MS365AppsChannel,MSOneDriveRing,MSTeamsRing,TreeSizeType,IrfanView,MSTeamsNoAutoStart,deviceTRUST,MSDotNetFramework,MSDotNetFrameworkChannel,MSPowerShell,MSPowerShellRelease,RemoteDesktopManager,RemoteDesktopManagerType,Slack,ShareX,Zoom,ZoomCitrixClient,deviceTRUSTPackage,deviceTRUSTClient,deviceTRUSTConsole,deviceTRUSTHost,MSEdgeChannel,Installer,MSVisualStudioCodeChannel,MSVisualStudio,MSVisualStudioCode,TeamViewer,Putty,PaintDotNet,MSPowerToys,GIMP,MSVisualStudioEdition,PuttyChannel,Wireshark,MSAzureDataStudio,MSAzureDataStudioChannel,ImageGlass,MSFSLogixChannel,ControlUpEdgeDX,1Password,CiscoWebexClient,ControlUpAgent,OperaBrowserChannel,ControlUpConsole,MSSQLServerManagementStudio,MSAVDRemoteDesktop,MSAVDRemoteDesktopChannel,MSPowerBIDesktop,RDAnalyzer,SumatraPDF,CiscoWebexTeams,CitrixFiles,FoxitPDFEditor,GitForWindows,LogMeInGoToMeeting,MSAzureCLI,MSPowerBIReportBuilder,MSSysinternals,NMap,PeaZip,TechSmithCamtasia,TechSmithSnagit,WinMerge,WhatIf,CleanUp,7Zip_Architecture,AdobeReaderDC_Architecture,AdobeReaderDC_Language,CiscoWebexTeams_Architecture,CitrixHypervisorTools_Architecture,ControlUpAgent_Architecture,deviceTRUST_Architecture,FoxitPDFEditor_Language,FoxitReader_Language,GitForWindows_Architecture,GoogleChrome_Architecture,ImageGlass_Architecture,IrfanView_Architecture,Keepass_Language,MSDotNetFramework_Architecture,MS365Apps_Architecture,MS365Apps_Language,MS365Apps_Visio,MS365Apps_Visio_Language,MS365Apps_Project,MS365Apps_Project_Language,MSAVDRemoteDesktop_Architecture,MSEdge_Architecture,MSFSLogix_Architecture,MSOffice_Architecture,MSOneDrive_Architecture,MSPowerBIDesktop_Architecture,MSPowerShell_Architecture,MSSQLServerManagementStudio_Language,MSTeams_Architecture,MSVisualStudioCode_Architecture,Firefox_Architecture,Firefox_Language,NotePadPlusPlus_Architecture,OpenJDK_Architecture,OracleJava8_Architecture,PeaZip_Architecture,Putty_Architecture,Slack_Architecture,SumatraPDF_Architecture,TechSmithSnagIt_Architecture,VLCPlayer_Architecture,VMwareTools_Architecture,WinMerge_Architecture,Wireshark_Architecture,IrfanView_Language,MSOffice_Language,MSEdgeWebView2,MSEdgeWebView2_Architecture,AutodeskDWGTrueView,MindView7,MindView7_Language,PDFsam,MSOfficeVersion,OpenShellMenu,PDFForgeCreator,TotalCommander,LogMeInGoToMeeting_Installer,MSAzureDataStudio_Installer,MSVisualStudioCode_Installer,MS365Apps_Installer,MSTeams_Installer,Zoom_Installer,MSOneDrive_Installer,Slack_Installer,pdfforgePDFCreatorChannel,TotalCommander_Architecture,Repository,CleanUpStartMenu,MSVisualCPlusPlusRuntime,MSVisualCPlusPlusRuntimeRelease,MSVisualCPlusPlusRuntime_Architecture,MSOffice_Visio,MSOffice_Visio_Language,MSOffice_Project,MSOffice_Project_Language,Zoom_Architecture,CiscoWebexTeamsClient,BISF_Tools,MozillaThunderbird,PDF24Creator,WinRAR,AdobeProDC_Architecture,GoogleChromeChannel,OpenJDKPackage,PaintDotNet_Architecture,WinRAR_Architecture,WinRAR_Language,WinRARChannel,MozillaThunderbird_Architecture,MozillaThunderbird_Language,MSAzureDataStudio_Architecture,TeamViewer_Architecture,OperaBrowser,OperaBrowser_Architecture,Ditto,Ditto_Architecture,Ditto_Channel,XCA,ControlUpEdgeDX_Installer,ControlUpRemoteDX,IISCrypto,Screenpresso,Report,NoDesktopIcon,ControlUpRemoteDXEUC,MSTeamsAVD,AdoptOpenJDK,AdoptOpenJDKVersion,Bloomberg,GoogleDrive,JabraDirect,AdoptOpenJDKIcedTeaWeb,OpenWebStart,AdoptOpenJDK_Architecture,OpenWebStart_Architecture,WindowsUpdate,MSTeamsNew,MSTeamsAVDNew,MobaXterm,MSTeamsNew_Architecture -ErrorAction SilentlyContinue

    If (!(Test-Path -Path "$PSScriptRoot\img\Logo_DEYDA.png")) {
        If (!(Test-Path -Path "$PSScriptRoot\img")) { New-Item -Path "$PSScriptRoot\img" -ItemType Directory | Out-Null }
        Invoke-WebRequest -Uri https://raw.githubusercontent.com/Deyda/Neverred/master/img/Logo_DEYDA.png -OutFile ("$PSScriptRoot\img\" + "Logo_DEYDA.png")
    }
    gui_mode
}

#// MARK: Variable definition (Architecture,Language etc) (AddScript)
Switch ($Architecture) {
    0 { $ArchitectureClear = 'x64'}
    1 { $ArchitectureClear = 'x86'}
}

Switch ($Language) {
    0 { $LanguageClear = 'Arabic'}
    1 { $LanguageClear = 'Chinese'}
    2 { $LanguageClear = 'Croatian'}
    3 { $LanguageClear = 'Czech'}
    4 { $LanguageClear = 'Danish'}
    5 { $LanguageClear = 'Dutch'}
    6 { $LanguageClear = 'English'}
    7 { $LanguageClear = 'Finnish'}
    8 { $LanguageClear = 'French'}
    9 { $LanguageClear = 'German'}
    10 { $LanguageClear = 'Hebrew'}
    11 { $LanguageClear = 'Hungarian'}
    12 { $LanguageClear = 'Italian'}
    13 { $LanguageClear = 'Japanese'}
    14 { $LanguageClear = 'Korean'}
    15 { $LanguageClear = 'Norwegian'}
    16 { $LanguageClear = 'Polish'}
    17 { $LanguageClear = 'Portuguese'}
    18 { $LanguageClear = 'Romanian'}
    19 { $LanguageClear = 'Russian'}
    20 { $LanguageClear = 'Slovak'}
    21 { $LanguageClear = 'Slovenian'}
    22 { $LanguageClear = 'Spanish'}
    23 { $LanguageClear = 'Swedish'}
    24 { $LanguageClear = 'Turkish'}
    25 { $LanguageClear = 'Ukrainian'}
}

Switch ($Installer) {
    0 { $InstallerClear = 'Machine Based'}
    1 { $InstallerClear = 'User Based'}
}

If ($7Zip_Architecture -ne "") {
    Switch ($7Zip_Architecture) {
        1 { $7ZipArchitectureClear = 'x86'}
        2 { $7ZipArchitectureClear = 'x64'}
    }
}
Else {
    $7ZipArchitectureClear = $ArchitectureClear
}

If ($AdobeProDC_Architecture -ne "") {
    Switch ($AdobeProDC_Architecture) {
        1 { $AdobeProArchitectureClear = 'x86'}
        2 { $AdobeProArchitectureClear = 'x64'}
    }
}
Else {
    $AdobeProArchitectureClear = $ArchitectureClear
}

If ($AdobeReaderDC_Architecture -ne "") {
    Switch ($AdobeReaderDC_Architecture) {
        1 { $AdobeArchitectureClear = 'x86'}
        2 { $AdobeArchitectureClear = 'x64'}
    }
}
Else {
    $AdobeArchitectureClear = $ArchitectureClear
}

If ($AdobeReaderDC_Language -ne "") {
    Switch ($AdobeReaderDC_Language) {
        1 { $AdobeLanguageClear = 'Chinese (Simplified)'}
        2 { $AdobeLanguageClear = 'Croatian'}
        3 { $AdobeLanguageClear = 'Czech'}
        4 { $AdobeLanguageClear = 'Danish'}
        5 { $AdobeLanguageClear = 'Dutch'}
        6 { $AdobeLanguageClear = 'English'}
        7 { $AdobeLanguageClear = 'Finnish'}
        8 { $AdobeLanguageClear = 'French'}
        9 { $AdobeLanguageClear = 'German'}
        10 { $AdobeLanguageClear = 'Hungarian'}
        11 { $AdobeLanguageClear = 'Italian'}
        12 { $AdobeLanguageClear = 'Japanese'}
        13 { $AdobeLanguageClear = 'Korean'}
        14 { $AdobeLanguageClear = 'Norwegian'}
        15 { $AdobeLanguageClear = 'Polish'}
        16 { $AdobeLanguageClear = 'Portuguese'}
        17 { $AdobeLanguageClear = 'Romanian'}
        18 { $AdobeLanguageClear = 'Russian'}
        19 { $AdobeLanguageClear = 'Slovak'}
        20 { $AdobeLanguageClear = 'Slovenian'}
        21 { $AdobeLanguageClear = 'Spanish'}
        22 { $AdobeLanguageClear = 'Swedish'}
        23 { $AdobeLanguageClear = 'Turkish'}
        24 { $AdobeLanguageClear = 'Ukrainian'}
        25 { $AdobeLanguageClear = 'MUI'}
    }
}
Else {
    $AdobeLanguageClear = $LanguageClear
    Switch ($LanguageClear) {
        Arabic { $AdobeLanguageClear = 'English'}
        Hebrew { $AdobeLanguageClear = 'English'}
    }
}

If ($AdoptOpenJDK_Architecture -ne "") {
    Switch ($AdoptOpenJDK_Architecture) {
        1 { $AdoptOpenJDKArchitectureClear = 'x86'}
        2 { $AdoptOpenJDKArchitectureClear = 'x64'}
    }
}
Else {
    $AdoptOpenJDKArchitectureClear = $ArchitectureClear
}

Switch ($AdoptOpenJDKVersion) {
    0 { $AdoptOpenJDKVersionClear = '8'}
    1 { $AdoptOpenJDKVersionClear = '11'}
    2 { $AdoptOpenJDKVersionClear = '16'}
}

If ($CiscoWebexTeams_Architecture -ne "") {
    Switch ($CiscoWebexTeams_Architecture) {
        1 { $CiscoWebexTeamsArchitectureClear = 'x86'}
        2 { $CiscoWebexTeamsArchitectureClear = 'x64'}
    }
}
Else {
    $CiscoWebexTeamsArchitectureClear = $ArchitectureClear
}

If ($CitrixHypervisorTools_Architecture -ne "") {
    Switch ($CitrixHypervisorTools_Architecture) {
        1 { $CitrixHypervisorToolsArchitectureClear = 'x86'}
        2 { $CitrixHypervisorToolsArchitectureClear = 'x64'}
    }
}
Else {
    $CitrixHypervisorToolsArchitectureClear = $ArchitectureClear
}

Switch ($CitrixWorkspaceAppRelease) {
    0 { $CitrixWorkspaceAppReleaseClear = 'Current'}
    1 { $CitrixWorkspaceAppReleaseClear = 'LTSR'}
    2 { $CitrixWorkspaceAppReleaseClear = 'Current'}
    3 { $CitrixWorkspaceAppReleaseClear = 'LTSR'}
}

If ($ControlUpAgent_Architecture -ne "") {
    Switch ($ControlUpAgent_Architecture) {
        1 { $ControlUpAgentArchitectureClear = 'x86'}
        2 { $ControlUpAgentArchitectureClear = 'x64'}
    }
}
Else {
    $ControlUpAgentArchitectureClear = $ArchitectureClear
}

If ($ControlUpEdgeDX_Installer -ne "") {
    Switch ($ControlUpEdgeDX_Installer) {
        1 { $ControlUpEdgeDXInstallerClear = 'Machine Based'}
        2 { $ControlUpEdgeDXInstallerClear = 'User Based'}
    }
}
Else {
    $ControlUpEdgeDXInstallerClear = $InstallerClear
}

Switch ($ControlUpRemoteDXEUC) {
    0 { $ControlUpRemoteDXEUCDLClear = 'Citrix'
        $ControlUpRemoteDXEUCClear = 'Citrix CVAD'}
    1 { $ControlUpRemoteDXEUCDLClear = 'Microsoft'
        $ControlUpRemoteDXEUCClear = 'Microsoft AVD & RDP'}
    2 { $ControlUpRemoteDXEUCDLClear = 'VMware'
        $ControlUpRemoteDXEUCClear = 'VMware Horizon'}
}

If ($deviceTRUST_Architecture -ne "") {
    Switch ($deviceTRUST_Architecture) {
        1 { $deviceTRUSTArchitectureClear = 'x86'}
        2 { $deviceTRUSTArchitectureClear = 'x64'}
    }
}
Else {
    $deviceTRUSTArchitectureClear = $ArchitectureClear
}

Switch ($deviceTRUSTPackage) {
    0 { $deviceTRUSTClient = $True}
    1 { $deviceTRUSTHost = $True}
    2 { $deviceTRUSTConsole = $True}
    3 { $deviceTRUSTClient = $True
        $deviceTRUSTHost = $True}
    4 { $deviceTRUSTConsole = $True
        $deviceTRUSTHost = $True}
}

If ($Ditto_Architecture -ne "") {
    Switch ($Ditto_Architecture) {
        1 { $DittoArchitectureClear = 'x86'}
        2 { $DittoArchitectureClear = 'x64'}
    }
}
Else {
    $DittoArchitectureClear = $ArchitectureClear
}

Switch ($Ditto_Channel) {
    0 { $DittoChannelClear = 'Beta'}
    1 { $DittoChannelClear = 'Stable'}
}

If ($FoxitPDFEditor_Language -ne "") {
    Switch ($FoxitPDFEditor_Language) {
        1 { $FoxitPDFEditorLanguageClear = 'Danish'}
        2 { $FoxitPDFEditorLanguageClear = 'Dutch'}
        3 { $FoxitPDFEditorLanguageClear = 'English'}
        4 { $FoxitPDFEditorLanguageClear = 'Finnish'}
        5 { $FoxitPDFEditorLanguageClear = 'French'}
        6 { $FoxitPDFEditorLanguageClear = 'German'}
        7 { $FoxitPDFEditorLanguageClear = 'Italian'}
        8 { $FoxitPDFEditorLanguageClear = 'Norwegian'}
        9 { $FoxitPDFEditorLanguageClear = 'Polish'}
        10 { $FoxitPDFEditorLanguageClear = 'Portuguese'}
        11 { $FoxitPDFEditorLanguageClear = 'Russian'}
        12 { $FoxitPDFEditorLanguageClear = 'Spanish'}
        13 { $FoxitPDFEditorLanguageClear = 'Swedish'}
    }
}
Else {
    $FoxitPDFEditorLanguageClear = $LanguageClear
    Switch ($LanguageClear) {
        Korean { $FoxitPDFEditorLanguageClear = 'English'}
        Japanese { $FoxitPDFEditorLanguageClear = 'English'}
        Arabic { $FoxitPDFEditorLanguageClear = 'English'}
        Chinese { $FoxitPDFEditorLanguageClear = 'English'}
        Croatian { $FoxitPDFEditorLanguageClear = 'English'}
        Czech { $FoxitPDFEditorLanguageClear = 'English'}
        Hebrew { $FoxitPDFEditorLanguageClear = 'English'}
        Hungarian { $FoxitPDFEditorLanguageClear = 'English'}
        Romanian { $FoxitPDFEditorLanguageClear = 'English'}
        Slovak { $FoxitPDFEditorLanguageClear = 'English'}
        Slovenian { $FoxitPDFEditorLanguageClear = 'English'}
        Turkish { $FoxitPDFEditorLanguageClear = 'English'}
        Ukrainian { $FoxitPDFEditorLanguageClear = 'English'}
    }
}

If ($FoxitReader_Language -ne "") {
    Switch ($FoxitReader_Language) {
        1 { $FoxitReaderLanguageClear = 'Danish'}
        2 { $FoxitReaderLanguageClear = 'Dutch'}
        3 { $FoxitReaderLanguageClear = 'English'}
        4 { $FoxitReaderLanguageClear = 'Finnish'}
        5 { $FoxitReaderLanguageClear = 'French'}
        6 { $FoxitReaderLanguageClear = 'German'}
        7 { $FoxitReaderLanguageClear = 'Italian'}
        8 { $FoxitReaderLanguageClear = 'Norwegian'}
        9 { $FoxitReaderLanguageClear = 'Polish'}
        10 { $FoxitReaderLanguageClear = 'Portuguese'}
        11 { $FoxitReaderLanguageClear = 'Russian'}
        12 { $FoxitReaderLanguageClear = 'Spanish'}
        13 { $FoxitReaderLanguageClear = 'Swedish'}
    }
}
Else {
    $FoxitReaderLanguageClear = $LanguageClear
    Switch ($LanguageClear) {
        Japanese { $FoxitReaderLanguageClear = 'English'}
        Korean { $FoxitReaderLanguageClear = 'English'}
        Arabic { $FoxitReaderLanguageClear = 'English'}
        Chinese { $FoxitReaderLanguageClear = 'English'}
        Croatian { $FoxitReaderLanguageClear = 'English'}
        Czech { $FoxitReaderLanguageClear = 'English'}
        Hebrew { $FoxitReaderLanguageClear = 'English'}
        Hungarian { $FoxitReaderLanguageClear = 'English'}
        Romanian { $FoxitReaderLanguageClear = 'English'}
        Slovak { $FoxitReaderLanguageClear = 'English'}
        Slovenian { $FoxitReaderLanguageClear = 'English'}
        Turkish { $FoxitReaderLanguageClear = 'English'}
        Ukrainian { $FoxitReaderLanguageClear = 'English'}
    }
}

If ($GitForWindows_Architecture -ne "") {
    Switch ($GitForWindows_Architecture) {
        1 { $GitForWindowsArchitectureClear = 'x86'}
        2 { $GitForWindowsArchitectureClear = 'x64'}
    }
}
Else {
    $GitForWindowsArchitectureClear = $ArchitectureClear
}

If ($GoogleChrome_Architecture -ne "") {
    Switch ($GoogleChrome_Architecture) {
        1 { $GoogleChromeArchitectureClear = 'x86'}
        2 { $GoogleChromeArchitectureClear = 'x64'}
    }
}
Else {
    $GoogleChromeArchitectureClear = $ArchitectureClear
}

Switch ($GoogleChromeChannel) {
    0 { $GoogleChromeChannelClear = 'Dev'}
    1 { $GoogleChromeChannelClear = 'Beta'}
    2 { $GoogleChromeChannelClear = 'Stable'}
}

If ($ImageGlass_Architecture -ne "") {
    Switch ($ImageGlass_Architecture) {
        1 { $ImageGlassArchitectureClear = 'x86'}
        2 { $ImageGlassArchitectureClear = 'x64'}
    }
}
Else {
    $ImageGlassArchitectureClear = $ArchitectureClear
}

If ($IrfanView_Architecture -ne "") {
    Switch ($IrfanView_Architecture) {
        1 { $IrfanViewArchitectureClear = 'x86'}
        2 { $IrfanViewArchitectureClear = 'x64'}
    }
}
Else {
    $IrfanViewArchitectureClear = $ArchitectureClear
}

If ($IrfanView_Language -ne "") {
    Switch ($IrfanView_Language) {
        1 { $IrfanViewLanguageClear = 'ar'}
        2 { $IrfanViewLanguageClear = 'zh'}
        3 { $IrfanViewLanguageClear = 'cs'}
        4 { $IrfanViewLanguageClear = 'da'}
        5 { $IrfanViewLanguageClear = 'nl-NL'}
        7 { $IrfanViewLanguageClear = 'fi'}
        8 { $IrfanViewLanguageClear = 'fr'}
        9 { $IrfanViewLanguageClear = 'de'}
        10 { $IrfanViewLanguageClear = 'he'}
        11 { $IrfanViewLanguageClear = 'hu'}
        12 { $IrfanViewLanguageClear = 'it'}
        13 { $IrfanViewLanguageClear = 'ja'}
        14 { $IrfanViewLanguageClear = 'ko'}
        15 { $IrfanViewLanguageClear = 'pl'}
        16 { $IrfanViewLanguageClear = 'pt-PT'}
        17 { $IrfanViewLanguageClear = 'ro'}
        18 { $IrfanViewLanguageClear = 'ru'}
        19 { $IrfanViewLanguageClear = 'sk'}
        20 { $IrfanViewLanguageClear = 'sl'}
        21 { $IrfanViewLanguageClear = 'es'}
        22 { $IrfanViewLanguageClear = 'sv'}
        23 { $IrfanViewLanguageClear = 'tr'}
        24 { $IrfanViewLanguageClear = 'uk'}
    }
    Switch ($IrfanView_Language) {
        1 { $IrfanViewLanguageLongClear = 'Arabic'}
        2 { $IrfanViewLanguageLongClear = 'Chinese'}
        3 { $IrfanViewLanguageLongClear = 'Czech'}
        4 { $IrfanViewLanguageLongClear = 'Danish'}
        5 { $IrfanViewLanguageLongClear = 'Dutch'}
        6 { $IrfanViewLanguageLongClear = 'English'}
        7 { $IrfanViewLanguageLongClear = 'Finnish'}
        8 { $IrfanViewLanguageLongClear = 'French'}
        9 { $IrfanViewLanguageLongClear = 'German'}
        10 { $IrfanViewLanguageLongClear = 'Hebrew'}
        11 { $IrfanViewLanguageLongClear = 'Hungarian'}
        12 { $IrfanViewLanguageLongClear = 'Italian'}
        13 { $IrfanViewLanguageLongClear = 'Japanese'}
        14 { $IrfanViewLanguageLongClear = 'Korean'}
        15 { $IrfanViewLanguageLongClear = 'Polish'}
        16 { $IrfanViewLanguageLongClear = 'Portuguese'}
        17 { $IrfanViewLanguageLongClear = 'Romanian'}
        18 { $IrfanViewLanguageLongClear = 'Russian'}
        19 { $IrfanViewLanguageLongClear = 'Slovak'}
        20 { $IrfanViewLanguageLongClear = 'Slovenian'}
        21 { $IrfanViewLanguageLongClear = 'Spanish'}
        22 { $IrfanViewLanguageLongClear = 'Swedish'}
        23 { $IrfanViewLanguageLongClear = 'Turkish'}
        24 { $IrfanViewLanguageLongClear = 'Ukrainian'}
    }
}
Else {
    Switch ($Language) {
        0 { $IrfanViewLanguageClear = 'ar'}
        1 { $IrfanViewLanguageClear = 'zh'}
        3 { $IrfanViewLanguageClear = 'cs'}
        4 { $IrfanViewLanguageClear = 'da'}
        5 { $IrfanViewLanguageClear = 'nl-NL'}
        7 { $IrfanViewLanguageClear = 'fi'}
        8 { $IrfanViewLanguageClear = 'fr'}
        9 { $IrfanViewLanguageClear = 'de'}
        10 { $IrfanViewLanguageClear = 'he'}
        11 { $IrfanViewLanguageClear = 'hu'}
        12 { $IrfanViewLanguageClear = 'it'}
        13 { $IrfanViewLanguageClear = 'ja'}
        14 { $IrfanViewLanguageClear = 'ko'}
        16 { $IrfanViewLanguageClear = 'pl'}
        17 { $IrfanViewLanguageClear = 'pt-PT'}
        18 { $IrfanViewLanguageClear = 'ro'}
        19 { $IrfanViewLanguageClear = 'ru'}
        20 { $IrfanViewLanguageClear = 'sk'}
        21 { $IrfanViewLanguageClear = 'sl'}
        22 { $IrfanViewLanguageClear = 'es'}
        23 { $IrfanViewLanguageClear = 'sv'}
        24 { $IrfanViewLanguageClear = 'tr'}
        25 { $IrfanViewLanguageClear = 'uk'}
        
    }
    Switch ($Language) {
        0 { $IrfanViewLanguageLongClear = 'Arabic'}
        1 { $IrfanViewLanguageLongClear = 'Chinese'}
        2 { $IrfanViewLanguageLongClear = 'English'}
        3 { $IrfanViewLanguageLongClear = 'Czech'}
        4 { $IrfanViewLanguageLongClear = 'Danish'}
        5 { $IrfanViewLanguageLongClear = 'Dutch'}
        6 { $IrfanViewLanguageLongClear = 'English'}
        7 { $IrfanViewLanguageLongClear = 'Finnish'}
        8 { $IrfanViewLanguageLongClear = 'French'}
        9 { $IrfanViewLanguageLongClear = 'German'}
        10 { $IrfanViewLanguageLongClear = 'Hebrew'}
        11 { $IrfanViewLanguageLongClear = 'Hungarian'}
        12 { $IrfanViewLanguageLongClear = 'Italian'}
        13 { $IrfanViewLanguageLongClear = 'Japanese'}
        14 { $IrfanViewLanguageLongClear = 'Korean'}
        15 { $IrfanViewLanguageLongClear = 'English'}
        16 { $IrfanViewLanguageLongClear = 'Polish'}
        17 { $IrfanViewLanguageLongClear = 'Portuguese'}
        18 { $IrfanViewLanguageLongClear = 'Romanian'}
        19 { $IrfanViewLanguageLongClear = 'Russian'}
        20 { $IrfanViewLanguageLongClear = 'Slovak'}
        21 { $IrfanViewLanguageLongClear = 'Slovenian'}
        22 { $IrfanViewLanguageLongClear = 'Spanish'}
        23 { $IrfanViewLanguageLongClear = 'Swedish'}
        24 { $IrfanViewLanguageLongClear = 'Turkish'}
        25 { $IrfanViewLanguageLongClear = 'Ukrainian'}
    }
}

If ($KeePass_Language -ne "") {
    Switch ($KeePass_Language) {
        1 { $KeePassLanguageClear = 'Arabic'}
        2 { $KeePassLanguageClear = 'Chinese'}
        3 { $KeePassLanguageClear = 'Croatian'}
        4 { $KeePassLanguageClear = 'Czech'}
        5 { $KeePassLanguageClear = 'Danish'}
        6 { $KeePassLanguageClear = 'Dutch'}
        7 { $KeePassLanguageClear = 'English'}
        8 { $KeePassLanguageClear = 'Finnish'}
        9 { $KeePassLanguageClear = 'French'}
        10 { $KeePassLanguageClear = 'German'}
        11 { $KeePassLanguageClear = 'Hebrew'}
        12 { $KeePassLanguageClear = 'Hungarian'}
        13 { $KeePassLanguageClear = 'Italian'}
        14 { $KeePassLanguageClear = 'Japanese'}
        15 { $KeePassLanguageClear = 'Korean'}
        16 { $KeePassLanguageClear = 'Norwegian'}
        17 { $KeePassLanguageClear = 'Polish'}
        18 { $KeePassLanguageClear = 'Portuguese'}
        19 { $KeePassLanguageClear = 'Romanian'}
        20 { $KeePassLanguageClear = 'Russian'}
        21 { $KeePassLanguageClear = 'Slovak'}
        22 { $KeePassLanguageClear = 'Slovenian'}
        23 { $KeePassLanguageClear = 'Spanish'}
        24 { $KeePassLanguageClear = 'Swedish'}
        25 { $KeePassLanguageClear = 'Turkish'}
        26 { $KeePassLanguageClear = 'Ukrainian'}
    }
}
Else {
    $KeePassLanguageClear = $LanguageClear
}

If ($LogMeInGoToMeeting_Installer -ne "") {
    Switch ($LogMeInGoToMeeting_Installer) {
        1 { $LogMeInGoToMeetingInstallerClear = 'Machine Based'}
        2 { $LogMeInGoToMeetingInstallerClear = 'User Based'}
    }
}
Else {
    $LogMeInGoToMeetingInstallerClear = $InstallerClear
}

If ($MSDotNetFramework_Architecture -ne "") {
    Switch ($MSDotNetFramework_Architecture) {
        1 { $MSDotNetFrameworkArchitectureClear = 'x86'}
        2 { $MSDotNetFrameworkArchitectureClear = 'x64'}
    }
}
Else {
    $MSDotNetFrameworkArchitectureClear = $ArchitectureClear
}

Switch ($MSDotNetFrameworkChannel) {
    0 { $MSDotNetFrameworkChannelClear = 'STS'}
    1 { $MSDotNetFrameworkChannelClear = 'LTS'}
}

If ($MS365Apps_Architecture -ne "") {
    Switch ($MS365Apps_Architecture) {
        1 { 
            $MS365AppsArchitectureClear = '32'
            $MS365AppsArchitecturePolicyClear = 'x86'
        }
        2 {
            $MS365AppsArchitectureClear = '64'
            $MS365AppsArchitecturePolicyClear = 'x64'
        }
    }
}
Else {
    Switch ($Architecture) {
        0 { 
            $MS365AppsArchitectureClear = '64'
            $MS365AppsArchitecturePolicyClear = 'x64'
        }
        1 { 
            $MS365AppsArchitectureClear = '32'
            $MS365AppsArchitecturePolicyClear = 'x86'
        }
    }
}

If ($MS365Apps_Language -ne "") {
    Switch ($MS365Apps_Language) {
        1 { $MS365AppsLanguageClear = 'ar-SA'}
        2 { $MS365AppsLanguageClear = 'zh-CN'}
        3 { $MS365AppsLanguageClear = 'hr-HR'}
        4 { $MS365AppsLanguageClear = 'cs-CZ'}
        5 { $MS365AppsLanguageClear = 'da-DK'}
        6 { $MS365AppsLanguageClear = 'nl-NL'}
        7 { $MS365AppsLanguageClear = 'en-US'}
        8 { $MS365AppsLanguageClear = 'fi-FI'}
        9 { $MS365AppsLanguageClear = 'fr-FR'}
        10 { $MS365AppsLanguageClear = 'de-DE'}
        11 { $MS365AppsLanguageClear = 'he-IL'}
        12 { $MS365AppsLanguageClear = 'hu-HU'}
        13 { $MS365AppsLanguageClear = 'it-IT'}
        14 { $MS365AppsLanguageClear = 'ja-JP'}
        15 { $MS365AppsLanguageClear = 'ko-KR'}
        16 { $MS365AppsLanguageClear = 'nb-NO'}
        17 { $MS365AppsLanguageClear = 'pl-PL'}
        18 { $MS365AppsLanguageClear = 'pt-PT'}
        19 { $MS365AppsLanguageClear = 'ro-RO'}
        20 { $MS365AppsLanguageClear = 'ru-RU'}
        21 { $MS365AppsLanguageClear = 'sk-SK'}
        22 { $MS365AppsLanguageClear = 'sl-SL'}
        23 { $MS365AppsLanguageClear = 'es-ES'}
        24 { $MS365AppsLanguageClear = 'sv-SE'}
        25 { $MS365AppsLanguageClear = 'tr-TR'}
        26 { $MS365AppsLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MS365AppsLanguageClear = 'ar-SA'}
        1 { $MS365AppsLanguageClear = 'zh-CN'}
        2 { $MS365AppsLanguageClear = 'hr-HR'}
        3 { $MS365AppsLanguageClear = 'cs-CZ'}
        4 { $MS365AppsLanguageClear = 'da-DK'}
        5 { $MS365AppsLanguageClear = 'nl-NL'}
        6 { $MS365AppsLanguageClear = 'en-US'}
        7 { $MS365AppsLanguageClear = 'fi-FI'}
        8 { $MS365AppsLanguageClear = 'fr-FR'}
        9 { $MS365AppsLanguageClear = 'de-DE'}
        10 { $MS365AppsLanguageClear = 'he-IL'}
        11 { $MS365AppsLanguageClear = 'hu-HU'}
        12 { $MS365AppsLanguageClear = 'it-IT'}
        13 { $MS365AppsLanguageClear = 'ja-JP'}
        14 { $MS365AppsLanguageClear = 'ko-KR'}
        15 { $MS365AppsLanguageClear = 'nb-NO'}
        16 { $MS365AppsLanguageClear = 'pl-PL'}
        17 { $MS365AppsLanguageClear = 'pt-PT'}
        18 { $MS365AppsLanguageClear = 'ro-RO'}
        19 { $MS365AppsLanguageClear = 'ru-RU'}
        20 { $MS365AppsLanguageClear = 'sk-SK'}
        21 { $MS365AppsLanguageClear = 'sl-SL'}
        22 { $MS365AppsLanguageClear = 'es-ES'}
        23 { $MS365AppsLanguageClear = 'sv-SE'}
        24 { $MS365AppsLanguageClear = 'tr-TR'}
        25 { $MS365AppsLanguageClear = 'uk-UA'}
    }
}
If ($MS365Apps_Installer -ne "") {
    Switch ($MS365Apps_Installer) {
        1 { $MS365AppsInstallerClear = 'Machine Based'}
        2 { $MS365AppsInstallerClear = 'User Based'}
    }
}
Else {
    $MS365AppsInstallerClear = $InstallerClear
}

Switch ($MS365AppsChannel) {
    0 { $MS365AppsChannelClear = 'Beta Channel'}
    1 { $MS365AppsChannelClear = 'Current Channel (Preview)'}
    2 { $MS365AppsChannelClear = 'Current Channel'}
    3 { $MS365AppsChannelClear = 'Semi-Annual Channel (Preview)'}
    4 { $MS365AppsChannelClear = 'Monthly Enterprise Channel'}
    5 { $MS365AppsChannelClear = 'Semi-Annual Channel'}
}

Switch ($MS365AppsChannel) {
    0 { $MS365AppsChannelClearDL = 'BetaChannel'}
    1 { $MS365AppsChannelClearDL = 'CurrentPreview'}
    2 { $MS365AppsChannelClearDL = 'Current'}
    3 { $MS365AppsChannelClearDL = 'SemiAnnualPreview'}
    4 { $MS365AppsChannelClearDL = 'MonthlyEnterprise'}
    5 { $MS365AppsChannelClearDL = 'SemiAnnual'}
}

If ($MS365Apps_Project_Language -ne "") {
    Switch ($MS365Apps_Project_Language) {
        1 { $MS365AppsProjectLanguageClear = 'ar-SA'}
        2 { $MS365AppsProjectLanguageClear = 'zh-CN'}
        3 { $MS365AppsProjectLanguageClear = 'hr-HR'}
        4 { $MS365AppsProjectLanguageClear = 'cs-CZ'}
        5 { $MS365AppsProjectLanguageClear = 'da-DK'}
        6 { $MS365AppsProjectLanguageClear = 'nl-NL'}
        7 { $MS365AppsProjectLanguageClear = 'en-US'}
        8 { $MS365AppsProjectLanguageClear = 'fi-FI'}
        9 { $MS365AppsProjectLanguageClear = 'fr-FR'}
        10 { $MS365AppsProjectLanguageClear = 'de-DE'}
        11 { $MS365AppsProjectLanguageClear = 'he-IL'}
        12 { $MS365AppsProjectLanguageClear = 'hu-HU'}
        13 { $MS365AppsProjectLanguageClear = 'it-IT'}
        14 { $MS365AppsProjectLanguageClear = 'ja-JP'}
        15 { $MS365AppsProjectLanguageClear = 'ko-KR'}
        16 { $MS365AppsProjectLanguageClear = 'nb-NO'}
        17 { $MS365AppsProjectLanguageClear = 'pl-PL'}
        18 { $MS365AppsProjectLanguageClear = 'pt-PT'}
        19 { $MS365AppsProjectLanguageClear = 'ro-RO'}
        20 { $MS365AppsProjectLanguageClear = 'ru-RU'}
        21 { $MS365AppsProjectLanguageClear = 'sk-SK'}
        22 { $MS365AppsProjectLanguageClear = 'sl-SL'}
        23 { $MS365AppsProjectLanguageClear = 'es-ES'}
        24 { $MS365AppsProjectLanguageClear = 'sv-SE'}
        25 { $MS365AppsProjectLanguageClear = 'tr-TR'}
        26 { $MS365AppsProjectLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MS365AppsProjectLanguageClear = 'ar-SA'}
        1 { $MS365AppsProjectLanguageClear = 'zh-CN'}
        2 { $MS365AppsProjectLanguageClear = 'hr-HR'}
        3 { $MS365AppsProjectLanguageClear = 'cs-CZ'}
        4 { $MS365AppsProjectLanguageClear = 'da-DK'}
        5 { $MS365AppsProjectLanguageClear = 'nl-NL'}
        6 { $MS365AppsProjectLanguageClear = 'en-US'}
        7 { $MS365AppsProjectLanguageClear = 'fi-FI'}
        8 { $MS365AppsProjectLanguageClear = 'fr-FR'}
        9 { $MS365AppsProjectLanguageClear = 'de-DE'}
        10 { $MS365AppsProjectLanguageClear = 'he-IL'}
        11 { $MS365AppsProjectLanguageClear = 'hu-HU'}
        12 { $MS365AppsProjectLanguageClear = 'it-IT'}
        13 { $MS365AppsProjectLanguageClear = 'ja-JP'}
        14 { $MS365AppsProjectLanguageClear = 'ko-KR'}
        15 { $MS365AppsProjectLanguageClear = 'nb-NO'}
        16 { $MS365AppsProjectLanguageClear = 'pl-PL'}
        17 { $MS365AppsProjectLanguageClear = 'pt-PT'}
        18 { $MS365AppsProjectLanguageClear = 'ro-RO'}
        19 { $MS365AppsProjectLanguageClear = 'ru-RU'}
        20 { $MS365AppsProjectLanguageClear = 'sk-SK'}
        21 { $MS365AppsProjectLanguageClear = 'sl-SL'}
        22 { $MS365AppsProjectLanguageClear = 'es-ES'}
        23 { $MS365AppsProjectLanguageClear = 'sv-SE'}
        24 { $MS365AppsProjectLanguageClear = 'tr-TR'}
        25 { $MS365AppsProjectLanguageClear = 'uk-UA'}
    }
}

If ($MS365Apps_Visio_Language -ne "") {
    Switch ($MS365Apps_Visio_Language) {
        1 { $MS365AppsVisioLanguageClear = 'ar-SA'}
        2 { $MS365AppsVisioLanguageClear = 'zh-CN'}
        3 { $MS365AppsVisioLanguageClear = 'hr-HR'}
        4 { $MS365AppsVisioLanguageClear = 'cs-CZ'}
        5 { $MS365AppsVisioLanguageClear = 'da-DK'}
        6 { $MS365AppsVisioLanguageClear = 'nl-NL'}
        7 { $MS365AppsVisioLanguageClear = 'en-US'}
        8 { $MS365AppsVisioLanguageClear = 'fi-FI'}
        9 { $MS365AppsVisioLanguageClear = 'fr-FR'}
        10 { $MS365AppsVisioLanguageClear = 'de-DE'}
        11 { $MS365AppsVisioLanguageClear = 'he-IL'}
        12 { $MS365AppsVisioLanguageClear = 'hu-HU'}
        13 { $MS365AppsVisioLanguageClear = 'it-IT'}
        14 { $MS365AppsVisioLanguageClear = 'ja-JP'}
        15 { $MS365AppsVisioLanguageClear = 'ko-KR'}
        16 { $MS365AppsVisioLanguageClear = 'nb-NO'}
        17 { $MS365AppsVisioLanguageClear = 'pl-PL'}
        18 { $MS365AppsVisioLanguageClear = 'pt-PT'}
        19 { $MS365AppsVisioLanguageClear = 'ro-RO'}
        20 { $MS365AppsVisioLanguageClear = 'ru-RU'}
        21 { $MS365AppsVisioLanguageClear = 'sk-SK'}
        22 { $MS365AppsVisioLanguageClear = 'sl-SL'}
        23 { $MS365AppsVisioLanguageClear = 'es-ES'}
        24 { $MS365AppsVisioLanguageClear = 'sv-SE'}
        25 { $MS365AppsVisioLanguageClear = 'tr-TR'}
        26 { $MS365AppsVisioLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MS365AppsVisioLanguageClear = 'ar-SA'}
        1 { $MS365AppsVisioLanguageClear = 'zh-CN'}
        2 { $MS365AppsVisioLanguageClear = 'hr-HR'}
        3 { $MS365AppsVisioLanguageClear = 'cs-CZ'}
        4 { $MS365AppsVisioLanguageClear = 'da-DK'}
        5 { $MS365AppsVisioLanguageClear = 'nl-NL'}
        6 { $MS365AppsVisioLanguageClear = 'en-US'}
        7 { $MS365AppsVisioLanguageClear = 'fi-FI'}
        8 { $MS365AppsVisioLanguageClear = 'fr-FR'}
        9 { $MS365AppsVisioLanguageClear = 'de-DE'}
        10 { $MS365AppsVisioLanguageClear = 'he-IL'}
        11 { $MS365AppsVisioLanguageClear = 'hu-HU'}
        12 { $MS365AppsVisioLanguageClear = 'it-IT'}
        13 { $MS365AppsVisioLanguageClear = 'ja-JP'}
        14 { $MS365AppsVisioLanguageClear = 'ko-KR'}
        15 { $MS365AppsVisioLanguageClear = 'nb-NO'}
        16 { $MS365AppsVisioLanguageClear = 'pl-PL'}
        17 { $MS365AppsVisioLanguageClear = 'pt-PT'}
        18 { $MS365AppsVisioLanguageClear = 'ro-RO'}
        19 { $MS365AppsVisioLanguageClear = 'ru-RU'}
        20 { $MS365AppsVisioLanguageClear = 'sk-SK'}
        21 { $MS365AppsVisioLanguageClear = 'sl-SL'}
        22 { $MS365AppsVisioLanguageClear = 'es-ES'}
        23 { $MS365AppsVisioLanguageClear = 'sv-SE'}
        24 { $MS365AppsVisioLanguageClear = 'tr-TR'}
        25 { $MS365AppsVisioLanguageClear = 'uk-UA'}
    }
}

Switch ($MSAzureDataStudioChannel) {
    0 { $MSAzureDataStudioChannelClear = 'Insider'}
    1 { $MSAzureDataStudioChannelClear = 'Stable'}
}

If ($MSAzureDataStudio_Installer -ne "") {
    Switch ($MSAzureDataStudio_Installer) {
        1 { $MSAzureDataStudioInstallerClear = 'Machine Based'}
        2 { $MSAzureDataStudioInstallerClear = 'User Based'}
    }
}
Else {
    $MSAzureDataStudioInstallerClear = $InstallerClear
}

If ($MSAzureDataStudioInstallerClear -eq "Machine Based") {
    If ($MSAzureDataStudio_Architecture -ne "") {
        Switch ($MSAzureDataStudio_Architecture) {
            2 {
                $MSAzureDataStudioPlatformClear = 'win32-x64'
                $MSAzureDataStudioArchitectureClear = 'x64'
            }
            1 {
                $MSAzureDataStudioPlatformClear = 'win32'
                $MSAzureDataStudioArchitectureClear = 'x86'
            }
        }
    } Else {
        Switch ($Architecture) {
            0 {
                $MSAzureDataStudioPlatformClear = 'win32-x64'
                $MSAzureDataStudioArchitectureClear = 'x64'
            }
            1 {
                $MSAzureDataStudioPlatformClear = 'win32'
                $MSAzureDataStudioArchitectureClear = 'x86'
            }
        }
    }
    $MSAzureDataStudioModeClear = 'Per Machine'
}

If ($MSAzureDataStudioInstallerClear -eq "User Based") {
    If ($MSAzureDataStudio_Architecture -ne "") {
        Switch ($MSAzureDataStudio_Architecture) {
            2 {
                $MSAzureDataStudioPlatformClear = 'win32-x64-user'
                $MSAzureDataStudioArchitectureClear = 'x64'
            }
            1 {
                $MSAzureDataStudioPlatformClear = 'win32-user'
                $MSAzureDataStudioArchitectureClear = 'x86'
            }
        }
    } Else {
        Switch ($Architecture) {
            0 {
                $MSAzureDataStudioPlatformClear = 'win32-x64-user'
                $MSAzureDataStudioArchitectureClear = 'x64'
            }
            1 {
                $MSAzureDataStudioPlatformClear = 'win32-user'
                $MSAzureDataStudioArchitectureClear = 'x86'
            }
        }
    }
    $MSAzureDataStudioModeClear = 'Per User'
}

If ($MSAVDRemoteDesktop_Architecture -ne "") {
    Switch ($MSAVDRemoteDesktop_Architecture) {
        1 { $MSAVDRemoteDesktopArchitectureClear = 'x86'}
        2 { $MSAVDRemoteDesktopArchitectureClear = 'x64'}
    }
}
Else {
    $MSAVDRemoteDesktopArchitectureClear = $ArchitectureClear
}

Switch ($MSAVDRemoteDesktopChannel) {
    0 { $MSAVDRemoteDesktopChannelClear = 'Insider'}
    1 { $MSAVDRemoteDesktopChannelClear = 'Public'}
}

If ($MSEdge_Architecture -ne "") {
    Switch ($MSEdge_Architecture) {
        1 { $MSEdgeArchitectureClear = 'x86'}
        2 { $MSEdgeArchitectureClear = 'x64'}
    }
}
Else {
    $MSEdgeArchitectureClear = $ArchitectureClear
}

Switch ($MSEdgeChannel) {
    0 { $MSEdgeChannelClear = 'Dev'}
    1 { $MSEdgeChannelClear = 'Beta'}
    2 { $MSEdgeChannelClear = 'Stable'}
}

If ($MSEdgeWebView2_Architecture -ne "") {
    Switch ($MSEdgeWebView2_Architecture) {
        1 { $MSEdgeWebView2ArchitectureClear = 'x86'}
        2 { $MSEdgeWebView2ArchitectureClear = 'x64'}
    }
}
Else {
    $MSEdgeWebView2ArchitectureClear = $ArchitectureClear
}

If ($MSFSLogix_Architecture -ne "") {
    Switch ($MSFSLogix_Architecture) {
        1 { $MSFSLogixArchitectureClear = 'x86'}
        2 { $MSFSLogixArchitectureClear = 'x64'}
    }
}
Else {
    $MSFSLogixArchitectureClear = $ArchitectureClear
}

Switch ($MSFSLogixChannel) {
    0 { $MSFSLogixChannelClear = 'Preview'}
    1 { $MSFSLogixChannelClear = 'Production'}
    2 { $MSFSLogixChannelClear = 'Stable'}
}

If ($MSOffice_Architecture -ne "") {
    Switch ($MSOffice_Architecture) {
        1 { 
            $MSOfficeArchitectureClear = '32'
            $MSOfficeArchitecturePolicyClear = 'x86'
        }
        2 { 
            $MSOfficeArchitectureClear = '64'
            $MSOfficeArchitecturePolicyClear = 'x64'
    }
    }
}
Else {
    Switch ($Architecture) {
        0 { 
            $MSOfficeArchitectureClear = '64'
            $MSOfficeArchitecturePolicyClear = 'x64'
        }
        1 { 
            $MSOfficeArchitectureClear = '32'
            $MSOfficeArchitecturePolicyClear = 'x86'
        }
    }
}

If ($MSOffice_Language -ne "") {
    Switch ($MSOffice_Language) {
        1 { $MSOfficeLanguageClear = 'ar-SA'}
        2 { $MSOfficeLanguageClear = 'zh-CN'}
        3 { $MSOfficeLanguageClear = 'hr-HR'}
        4 { $MSOfficeLanguageClear = 'cs-CZ'}
        5 { $MSOfficeLanguageClear = 'da-DK'}
        6 { $MSOfficeLanguageClear = 'nl-NL'}
        7 { $MSOfficeLanguageClear = 'en-US'}
        8 { $MSOfficeLanguageClear = 'fi-FI'}
        9 { $MSOfficeLanguageClear = 'fr-FR'}
        10 { $MSOfficeLanguageClear = 'de-DE'}
        11 { $MSOfficeLanguageClear = 'he-IL'}
        12 { $MSOfficeLanguageClear = 'hu-HU'}
        13 { $MSOfficeLanguageClear = 'it-IT'}
        14 { $MSOfficeLanguageClear = 'ja-JP'}
        15 { $MSOfficeLanguageClear = 'ko-KR'}
        16 { $MSOfficeLanguageClear = 'nb-NO'}
        17 { $MSOfficeLanguageClear = 'pl-PL'}
        18 { $MSOfficeLanguageClear = 'pt-PT'}
        19 { $MSOfficeLanguageClear = 'ro-RO'}
        20 { $MSOfficeLanguageClear = 'ru-RU'}
        21 { $MSOfficeLanguageClear = 'sk-SK'}
        22 { $MSOfficeLanguageClear = 'sl-SL'}
        23 { $MSOfficeLanguageClear = 'es-ES'}
        24 { $MSOfficeLanguageClear = 'sv-SE'}
        25 { $MSOfficeLanguageClear = 'tr-TR'}
        26 { $MSOfficeLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MSOfficeLanguageClear = 'ar-SA'}
        1 { $MSOfficeLanguageClear = 'zh-CN'}
        2 { $MSOfficeLanguageClear = 'hr-HR'}
        3 { $MSOfficeLanguageClear = 'cs-CZ'}
        4 { $MSOfficeLanguageClear = 'da-DK'}
        5 { $MSOfficeLanguageClear = 'nl-NL'}
        6 { $MSOfficeLanguageClear = 'en-US'}
        7 { $MSOfficeLanguageClear = 'fi-FI'}
        8 { $MSOfficeLanguageClear = 'fr-FR'}
        9 { $MSOfficeLanguageClear = 'de-DE'}
        10 { $MSOfficeLanguageClear = 'he-IL'}
        11 { $MSOfficeLanguageClear = 'hu-HU'}
        12 { $MSOfficeLanguageClear = 'it-IT'}
        13 { $MSOfficeLanguageClear = 'ja-JP'}
        14 { $MSOfficeLanguageClear = 'ko-KR'}
        15 { $MSOfficeLanguageClear = 'nb-NO'}
        16 { $MSOfficeLanguageClear = 'pl-PL'}
        17 { $MSOfficeLanguageClear = 'pt-PT'}
        18 { $MSOfficeLanguageClear = 'ro-RO'}
        19 { $MSOfficeLanguageClear = 'ru-RU'}
        20 { $MSOfficeLanguageClear = 'sk-SK'}
        21 { $MSOfficeLanguageClear = 'sl-SL'}
        22 { $MSOfficeLanguageClear = 'es-ES'}
        23 { $MSOfficeLanguageClear = 'sv-SE'}
        24 { $MSOfficeLanguageClear = 'tr-TR'}
        25 { $MSOfficeLanguageClear = 'uk-UA'}
    }
}

Switch ($MSOfficeVersion) {
    0 {
        $MSOfficeVersionClear = 'PerpetualVL2019'
        $MSOfficeChannelClear = '2019'
        $MSOfficeProductIDClear = 'ProPlus2019Volume'
        $MSOfficeProjectIDClear = 'ProjectPro2019Volume'
        $MSOfficeVisioIDClear = 'VisioPro2019Volume'
    }
    1 {
        $MSOfficeVersionClear = 'PerpetualVL2021'
        $MSOfficeChannelClear = '2021 LTSC'
        $MSOfficeProductIDClear = 'ProPlus2021Volume'
        $MSOfficeProjectIDClear = 'ProjectPro2021Volume'
        $MSOfficeVisioIDClear = 'VisioPro2021Volume'
    }
}

If ($MSOffice_Project_Language -ne "") {
    Switch ($MSOffice_Project_Language) {
        1 { $MSOfficeProjectLanguageClear = 'ar-SA'}
        2 { $MSOfficeProjectLanguageClear = 'zh-CN'}
        3 { $MSOfficeProjectLanguageClear = 'hr-HR'}
        4 { $MSOfficeProjectLanguageClear = 'cs-CZ'}
        5 { $MSOfficeProjectLanguageClear = 'da-DK'}
        6 { $MSOfficeProjectLanguageClear = 'nl-NL'}
        7 { $MSOfficeProjectLanguageClear = 'en-US'}
        8 { $MSOfficeProjectLanguageClear = 'fi-FI'}
        9 { $MSOfficeProjectLanguageClear = 'fr-FR'}
        10 { $MSOfficeProjectLanguageClear = 'de-DE'}
        11 { $MSOfficeProjectLanguageClear = 'he-IL'}
        12 { $MSOfficeProjectLanguageClear = 'hu-HU'}
        13 { $MSOfficeProjectLanguageClear = 'it-IT'}
        14 { $MSOfficeProjectLanguageClear = 'ja-JP'}
        15 { $MSOfficeProjectLanguageClear = 'ko-KR'}
        16 { $MSOfficeProjectLanguageClear = 'nb-NO'}
        17 { $MSOfficeProjectLanguageClear = 'pl-PL'}
        18 { $MSOfficeProjectLanguageClear = 'pt-PT'}
        19 { $MSOfficeProjectLanguageClear = 'ro-RO'}
        20 { $MSOfficeProjectLanguageClear = 'ru-RU'}
        21 { $MSOfficeProjectLanguageClear = 'sk-SK'}
        22 { $MSOfficeProjectLanguageClear = 'sl-SL'}
        23 { $MSOfficeProjectLanguageClear = 'es-ES'}
        24 { $MSOfficeProjectLanguageClear = 'sv-SE'}
        25 { $MSOfficeProjectLanguageClear = 'tr-TR'}
        26 { $MSOfficeProjectLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MSOfficeProjectLanguageClear = 'ar-SA'}
        1 { $MSOfficeProjectLanguageClear = 'zh-CN'}
        2 { $MSOfficeProjectLanguageClear = 'hr-HR'}
        3 { $MSOfficeProjectLanguageClear = 'cs-CZ'}
        4 { $MSOfficeProjectLanguageClear = 'da-DK'}
        5 { $MSOfficeProjectLanguageClear = 'nl-NL'}
        6 { $MSOfficeProjectLanguageClear = 'en-US'}
        7 { $MSOfficeProjectLanguageClear = 'fi-FI'}
        8 { $MSOfficeProjectLanguageClear = 'fr-FR'}
        9 { $MSOfficeProjectLanguageClear = 'de-DE'}
        10 { $MSOfficeProjectLanguageClear = 'he-IL'}
        11 { $MSOfficeProjectLanguageClear = 'hu-HU'}
        12 { $MSOfficeProjectLanguageClear = 'it-IT'}
        13 { $MSOfficeProjectLanguageClear = 'ja-JP'}
        14 { $MSOfficeProjectLanguageClear = 'ko-KR'}
        15 { $MSOfficeProjectLanguageClear = 'nb-NO'}
        16 { $MSOfficeProjectLanguageClear = 'pl-PL'}
        17 { $MSOfficeProjectLanguageClear = 'pt-PT'}
        18 { $MSOfficeProjectLanguageClear = 'ro-RO'}
        19 { $MSOfficeProjectLanguageClear = 'ru-RU'}
        20 { $MSOfficeProjectLanguageClear = 'sk-SK'}
        21 { $MSOfficeProjectLanguageClear = 'sl-SL'}
        22 { $MSOfficeProjectLanguageClear = 'es-ES'}
        23 { $MSOfficeProjectLanguageClear = 'sv-SE'}
        24 { $MSOfficeProjectLanguageClear = 'tr-TR'}
        25 { $MSOfficeProjectLanguageClear = 'uk-UA'}
    }
}

If ($MSOffice_Visio_Language -ne "") {
    Switch ($MSOffice_Visio_Language) {
        1 { $MSOfficeVisioLanguageClear = 'ar-SA'}
        2 { $MSOfficeVisioLanguageClear = 'zh-CN'}
        3 { $MSOfficeVisioLanguageClear = 'hr-HR'}
        4 { $MSOfficeVisioLanguageClear = 'cs-CZ'}
        5 { $MSOfficeVisioLanguageClear = 'da-DK'}
        6 { $MSOfficeVisioLanguageClear = 'nl-NL'}
        7 { $MSOfficeVisioLanguageClear = 'en-US'}
        8 { $MSOfficeVisioLanguageClear = 'fi-FI'}
        9 { $MSOfficeVisioLanguageClear = 'fr-FR'}
        10 { $MSOfficeVisioLanguageClear = 'de-DE'}
        11 { $MSOfficeVisioLanguageClear = 'he-IL'}
        12 { $MSOfficeVisioLanguageClear = 'hu-HU'}
        13 { $MSOfficeVisioLanguageClear = 'it-IT'}
        14 { $MSOfficeVisioLanguageClear = 'ja-JP'}
        15 { $MSOfficeVisioLanguageClear = 'ko-KR'}
        16 { $MSOfficeVisioLanguageClear = 'nb-NO'}
        17 { $MSOfficeVisioLanguageClear = 'pl-PL'}
        18 { $MSOfficeVisioLanguageClear = 'pt-PT'}
        19 { $MSOfficeVisioLanguageClear = 'ro-RO'}
        20 { $MSOfficeVisioLanguageClear = 'ru-RU'}
        21 { $MSOfficeVisioLanguageClear = 'sk-SK'}
        22 { $MSOfficeVisioLanguageClear = 'sl-SL'}
        23 { $MSOfficeVisioLanguageClear = 'es-ES'}
        24 { $MSOfficeVisioLanguageClear = 'sv-SE'}
        25 { $MSOfficeVisioLanguageClear = 'tr-TR'}
        26 { $MSOfficeVisioLanguageClear = 'uk-UA'}
    }
}
Else {
    Switch ($Language) {
        0 { $MSOfficeVisioLanguageClear = 'ar-SA'}
        1 { $MSOfficeVisioLanguageClear = 'zh-CN'}
        2 { $MSOfficeVisioLanguageClear = 'hr-HR'}
        3 { $MSOfficeVisioLanguageClear = 'cs-CZ'}
        4 { $MSOfficeVisioLanguageClear = 'da-DK'}
        5 { $MSOfficeVisioLanguageClear = 'nl-NL'}
        6 { $MSOfficeVisioLanguageClear = 'en-US'}
        7 { $MSOfficeVisioLanguageClear = 'fi-FI'}
        8 { $MSOfficeVisioLanguageClear = 'fr-FR'}
        9 { $MSOfficeVisioLanguageClear = 'de-DE'}
        10 { $MSOfficeVisioLanguageClear = 'he-IL'}
        11 { $MSOfficeVisioLanguageClear = 'hu-HU'}
        12 { $MSOfficeVisioLanguageClear = 'it-IT'}
        13 { $MSOfficeVisioLanguageClear = 'ja-JP'}
        14 { $MSOfficeVisioLanguageClear = 'ko-KR'}
        15 { $MSOfficeVisioLanguageClear = 'nb-NO'}
        16 { $MSOfficeVisioLanguageClear = 'pl-PL'}
        17 { $MSOfficeVisioLanguageClear = 'pt-PT'}
        18 { $MSOfficeVisioLanguageClear = 'ro-RO'}
        19 { $MSOfficeVisioLanguageClear = 'ru-RU'}
        20 { $MSOfficeVisioLanguageClear = 'sk-SK'}
        21 { $MSOfficeVisioLanguageClear = 'sl-SL'}
        22 { $MSOfficeVisioLanguageClear = 'es-ES'}
        23 { $MSOfficeVisioLanguageClear = 'sv-SE'}
        24 { $MSOfficeVisioLanguageClear = 'tr-TR'}
        25 { $MSOfficeVisioLanguageClear = 'uk-UA'}
    }
}

If ($MSOneDrive_Installer -ne "") {
    Switch ($MSOneDrive_Installer) {
        1 { $MSOneDriveInstallerClear = 'Machine Based'}
        2 { $MSOneDriveInstallerClear = 'User Based'}
    }
}
Else {
    $MSOneDriveInstallerClear = $InstallerClear
}

If ($MSOneDrive_Architecture -ne "") {
    Switch ($MSOneDrive_Architecture) {
        1 { $MSOneDriveArchitectureClear = 'x86'}
        2 { $MSOneDriveArchitectureClear = 'x64'}
    }
}
Else {
    Switch ($Architecture) {
        0 { $MSOneDriveArchitectureClear = 'x64'}
        1 { $MSOneDriveArchitectureClear = 'x86'}
    }
}

Switch ($MSOneDriveRing) {
    0 { $MSOneDriveRingClear = 'Insider'}
    1 { $MSOneDriveRingClear = 'Production'}
    2 { $MSOneDriveRingClear = 'Enterprise'}
}

If ($MSPowerBIDesktop_Architecture -ne "") {
    Switch ($MSPowerBIDesktop_Architecture) {
        1 { $MSPowerBIDesktopArchitectureClear = 'x86'}
        2 { $MSPowerBIDesktopArchitectureClear = 'x64'}
    }
}
Else {
    $MSPowerBIDesktopArchitectureClear = $ArchitectureClear
}

If ($MSPowerShell_Architecture -ne "") {
    Switch ($MSPowerShell_Architecture) {
        1 { $MSPowerShellArchitectureClear = 'x86'}
        2 { $MSPowerShellArchitectureClear = 'x64'}
    }
}
Else {
    $MSPowerShellArchitectureClear = $ArchitectureClear
}

Switch ($MSPowerShellRelease) {
    0 { $MSPowerShellReleaseClear = 'Stable'}
    1 { $MSPowerShellReleaseClear = 'LTS'}
}


If ($MSSQLServerManagementStudio_Language -ne "") {
    Switch ($MSSQLServerManagementStudio_Language) {
        1 { $MSSQLServerManagementStudioLanguageClear = 'Chinese'}
        2 { $MSSQLServerManagementStudioLanguageClear = 'English'}
        3 { $MSSQLServerManagementStudioLanguageClear = 'French'}
        4 { $MSSQLServerManagementStudioLanguageClear = 'German'}
        5 { $MSSQLServerManagementStudioLanguageClear = 'Italian'}
        6 { $MSSQLServerManagementStudioLanguageClear = 'Japanese'}
        7 { $MSSQLServerManagementStudioLanguageClear = 'Korean'}
        8 { $MSSQLServerManagementStudioLanguageClear = 'Portuguese (Brazil)'}
        9 { $MSSQLServerManagementStudioLanguageClear = 'Russian'}
        10 { $MSSQLServerManagementStudioLanguageClear = 'Spanish'}
    }
}
Else {
    $MSSQLServerManagementStudioLanguageClear = $LanguageClear
    Switch ($LanguageClear) {
        Arabic { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Croatian { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Czech { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Danish { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Dutch { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Finnish { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Hebrew { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Hungarian { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Norwegian { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Polish { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Portuguese { $MSSQLServerManagementStudioLanguageClear = 'Portuguese (Brazil)'}
        Romanian { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Slovak { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Slovenian { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Swedish { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Turkish { $MSSQLServerManagementStudioLanguageClear = 'English'}
        Ukrainian { $MSSQLServerManagementStudioLanguageClear = 'English'}
    }
}

If ($MSTeams_Installer -ne "") {
    Switch ($MSTeams_Installer) {
        1 { $MSTeamsInstallerClear = 'Machine Based'}
        2 { $MSTeamsInstallerClear = 'User Based'}
    }
}
Else {
    $MSTeamsInstallerClear = $InstallerClear
}

If ($MSTeams_Architecture -ne "") {
    Switch ($MSTeams_Architecture) {
        1 { $MSTeamsArchitectureClear = 'x86'}
        2 { $MSTeamsArchitectureClear = 'x64'}
    }
}
Else {
    $MSTeamsArchitectureClear = $ArchitectureClear
}

Switch ($MSTeamsRing) {
    0 { $MSTeamsRingClear = 'Continuous Deployment'}
    1 { $MSTeamsRingClear = 'Exploration'}
    2 { $MSTeamsRingClear = 'Preview'}
    3 { $MSTeamsRingClear = 'General'}
}

If ($MSTeamsNew_Architecture -ne "") {
    Switch ($MSTeamsNew_Architecture) {
        1 { $MSTeamsNewArchitectureClear = 'x86'}
        2 { $MSTeamsNewArchitectureClear = 'x64'}
    }
}
Else {
    $MSTeamsNewArchitectureClear = $ArchitectureClear
}

Switch ($MSVisualCPlusPlusRuntimeRelease) {
    0 { $MSVisualCPlusPlusRuntimeReleaseClear = '2012'}
    1 { $MSVisualCPlusPlusRuntimeReleaseClear = '2013'}
    2 { $MSVisualCPlusPlusRuntimeReleaseClear = '2022'}
    3 { $MSVisualCPlusPlusRuntimeReleaseClear = 'All'}
}

If ($MSVisualCPlusPlusRuntime_Architecture -ne "") {
    Switch ($MSVisualCPlusPlusRuntime_Architecture) {
        1 { $MSVisualCPlusPlusRuntimeArchitectureClear = 'x86'}
        2 { $MSVisualCPlusPlusRuntimeArchitectureClear = 'x64'}
        3 { $MSVisualCPlusPlusRuntimeArchitectureClear = 'both'}
    }
}
Else {
    $MSVisualCPlusPlusRuntimeArchitectureClear = $ArchitectureClear
}

Switch ($MSVisualStudioEdition) {
    0 { $MSVisualStudioEditionClear = 'Enterprise'}
    1 { $MSVisualStudioEditionClear = 'Professional'}
    2 { $MSVisualStudioEditionClear = 'Community'}
}

If ($MSVisualStudioCode_Architecture -ne "") {
    Switch ($MSVisualStudioCode_Architecture) {
        1 { $MSVisualStudioCodeArchitectureClear = 'x86'}
        2 { $MSVisualStudioCodeArchitectureClear = 'x64'}
    }
}
Else {
    $MSVisualStudioCodeArchitectureClear = $ArchitectureClear
}

If ($MSVisualStudioCode_Installer -ne "") {
    Switch ($MSVisualStudioCode_Installer) {
        1 { $MSVisualStudioCodeInstallerClear = 'Machine Based'}
        2 { $MSVisualStudioCodeInstallerClear = 'User Based'}
    }
}
Else {
    $MSVisualStudioCodeInstallerClear = $InstallerClear
}

If ($MSVisualStudioCodeInstallerClear -eq "Machine Based") {
    If ($MSVisualStudioCode_Architecture -ne "") {
        Switch ($MSVisualStudioCode_Architecture) {
            1 { $MSVisualStudioCodePlatformClear = 'win32'}
            2 { $MSVisualStudioCodePlatformClear = 'win32-x64'}
        }
    }
    Else {
        Switch ($Architecture) {
            0 { $MSVisualStudioCodePlatformClear = 'win32-x64'}
            1 { $MSVisualStudioCodePlatformClear = 'win32'}
        }
    }
    $MSVisualStudioCodeModeClear = 'Per Machine'
}

If ($MSVisualStudioCodeInstallerClear -eq "User Based") {
    If ($MSVisualStudioCode_Architecture -ne "") {
        Switch ($MSVisualStudioCode_Architecture) {
            1 { $MSVisualStudioCodePlatformClear = 'win32-user'}
            2 { $MSVisualStudioCodePlatformClear = 'win32-x64-user'}
        }
    }
    Else {
        Switch ($Architecture) {
            0 { $MSVisualStudioCodePlatformClear = 'win32-x64-user'}
            1 { $MSVisualStudioCodePlatformClear = 'win32-user'}
        }
    }
    $MSVisualStudioCodeModeClear = 'Per User'
}

Switch ($MSVisualStudioCodeChannel) {
    0 { $MSVisualStudioCodeChannelClear = 'Insider'}
    1 { $MSVisualStudioCodeChannelClear = 'Stable'}
}

If ($MindView7_Language -ne "") {
    Switch ($MindView7_Language) {
        1 { $MindView7LanguageClear = 'Danish'}
        2 { $MindView7LanguageClear = 'English'}
        3 { $MindView7LanguageClear = 'French'}
        4 { $MindView7LanguageClear = 'German'}
    }
}
Else {
    $MindView7LanguageClear = $LanguageClear
    Switch ($LanguageClear) {
        Arabic { $MindView7LanguageClear = 'English'}
        Chinese { $MindView7LanguageClear = 'English'}
        Croatian { $MindView7LanguageClear = 'English'}
        Czech { $MindView7LanguageClear = 'English'}
        Dutch { $MindView7LanguageClear = 'English'}
        Hebrew { $MindView7LanguageClear = 'English'}
        Hungarian { $MindView7LanguageClear = 'English'}
        Italian { $MindView7LanguageClear = 'English'}
        Finnish { $MindView7LanguageClear = 'English'}
        Norwegian { $MindView7LanguageClear = 'English'}
        Polish { $MindView7LanguageClear = 'English'}
        Portuguese { $MindView7LanguageClear = 'English'}
        Swedish { $MindView7LanguageClear = 'English'}
        Japanese { $MindView7LanguageClear = 'English'}
        Korean { $MindView7LanguageClear = 'English'}
        Polish { $MindView7LanguageClear = 'English'}
        Russian { $MindView7LanguageClear = 'English'}
        Spanish { $MindView7LanguageClear = 'English'}
        Romanian { $MindView7LanguageClear = 'English'}
        Slovak { $MindView7LanguageClear = 'English'}
        Slovenian { $MindView7LanguageClear = 'English'}
        Turkish { $MindView7LanguageClear = 'English'}
        Ukrainian { $MindView7LanguageClear = 'English'}
    }
}

Switch ($FirefoxChannel ) {
    0 { $FirefoxChannelClear = 'Current'}
    1 { $FirefoxChannelClear = 'Extended Support'}
    2 { $FirefoxChannelClear = 'Developer'}
}

If ($Firefox_Architecture -ne "") {
    Switch ($Firefox_Architecture) {
        1 { $FirefoxArchitectureClear = 'x86'}
        2 { $FirefoxArchitectureClear = 'x64'}
    }
}
Else {
    $FirefoxArchitectureClear = $ArchitectureClear
}

If ($Firefox_Language -ne "") {
    Switch ($Firefox_Language) {
        1 { $FFLanguageClear = 'ar'}
        2 { $FFLanguageClear = 'zh-CN'}
        3 { $FFLanguageClear = 'hr'}
        4 { $FFLanguageClear = 'cs'}
        5 { $FFLanguageClear = 'da'}
        6 { $FFLanguageClear = 'nl'}
        7 { $FFLanguageClear = 'en-US'}
        8 { $FFLanguageClear = 'fi'}
        9 { $FFLanguageClear = 'fr'}
        10 { $FFLanguageClear = 'de'}
        11 { $FFLanguageClear = 'he'}
        12 { $FFLanguageClear = 'hu'}
        13 { $FFLanguageClear = 'it'}
        14 { $FFLanguageClear = 'ja'}
        15 { $FFLanguageClear = 'ko'}
        16 { $FFLanguageClear = 'nb-NO'}
        17 { $FFLanguageClear = 'pl'}
        18 { $FFLanguageClear = 'pt-PT'}
        19 { $FFLanguageClear = 'ro'}
        20 { $FFLanguageClear = 'ru'}
        21 { $FFLanguageClear = 'sk'}
        22 { $FFLanguageClear = 'sl'}
        23 { $FFLanguageClear = 'es-ES'}
        24 { $FFLanguageClear = 'sv-SE'}
        25 { $FFLanguageClear = 'tr'}
        26 { $FFLanguageClear = 'uk'}
    }
    Switch ($Firefox_Language) {
        1 { $FFLanguageLongClear = 'Arabic'}
        2 { $FFLanguageLongClear = 'Chinese'}
        3 { $FFLanguageLongClear = 'Croatian'}
        4 { $FFLanguageLongClear = 'Czech'}
        5 { $FFLanguageLongClear = 'Danish'}
        6 { $FFLanguageLongClear = 'Dutch'}
        7 { $FFLanguageLongClear = 'English'}
        8 { $FFLanguageLongClear = 'Finnish'}
        9 { $FFLanguageLongClear = 'French'}
        10 { $FFLanguageLongClear = 'German'}
        11 { $FFLanguageLongClear = 'Hebrew'}
        12 { $FFLanguageLongClear = 'Hungarian'}
        13 { $FFLanguageLongClear = 'Italian'}
        14 { $FFLanguageLongClear = 'Japanese'}
        15 { $FFLanguageLongClear = 'Korean'}
        16 { $FFLanguageLongClear = 'Norwegian'}
        17 { $FFLanguageLongClear = 'Polish'}
        18 { $FFLanguageLongClear = 'Portuguese'}
        19 { $FFLanguageLongClear = 'Romanian'}
        20 { $FFLanguageLongClear = 'Russian'}
        21 { $FFLanguageLongClear = 'Slovak'}
        22 { $FFLanguageLongClear = 'Slovenian'}
        23 { $FFLanguageLongClear = 'Spanish'}
        24 { $FFLanguageLongClear = 'Swedish'}
        25 { $FFLanguageLongClear = 'Turkish'}
        26 { $FFLanguageLongClear = 'Ukrainian'}
    }
}
Else {
    Switch ($Language) {
        0 { $FFLanguageClear = 'ar'}
        1 { $FFLanguageClear = 'zh-CN'}
        2 { $FFLanguageClear = 'hr'}
        3 { $FFLanguageClear = 'cs'}
        4 { $FFLanguageClear = 'da'}
        5 { $FFLanguageClear = 'nl'}
        6 { $FFLanguageClear = 'en-US'}
        7 { $FFLanguageClear = 'fi'}
        8 { $FFLanguageClear = 'fr'}
        9 { $FFLanguageClear = 'de'}
        10 { $FFLanguageClear = 'he'}
        11 { $FFLanguageClear = 'hu'}
        12 { $FFLanguageClear = 'it'}
        13 { $FFLanguageClear = 'ja'}
        14 { $FFLanguageClear = 'ko'}
        15 { $FFLanguageClear = 'nb-NO'}
        16 { $FFLanguageClear = 'pl'}
        17 { $FFLanguageClear = 'pt-PT'}
        18 { $FFLanguageClear = 'ro'}
        19 { $FFLanguageClear = 'ru'}
        20 { $FFLanguageClear = 'sk'}
        21 { $FFLanguageClear = 'sl'}
        22 { $FFLanguageClear = 'es-ES'}
        23 { $FFLanguageClear = 'sv-SE'}
        24 { $FFLanguageClear = 'tr'}
        25 { $FFLanguageClear = 'uk'}
    }
    Switch ($Language) {
        0 { $FFLanguageLongClear = 'Arabic'}
        1 { $FFLanguageLongClear = 'Chinese'}
        2 { $FFLanguageLongClear = 'Croatian'}
        3 { $FFLanguageLongClear = 'Czech'}
        4 { $FFLanguageLongClear = 'Danish'}
        5 { $FFLanguageLongClear = 'Dutch'}
        6 { $FFLanguageLongClear = 'English'}
        7 { $FFLanguageLongClear = 'Finnish'}
        8 { $FFLanguageLongClear = 'French'}
        9 { $FFLanguageLongClear = 'German'}
        10 { $FFLanguageLongClear = 'Hebrew'}
        11 { $FFLanguageLongClear = 'Hungarian'}
        12 { $FFLanguageLongClear = 'Italian'}
        13 { $FFLanguageLongClear = 'Japanese'}
        14 { $FFLanguageLongClear = 'Korean'}
        15 { $FFLanguageLongClear = 'Norwegian'}
        16 { $FFLanguageLongClear = 'Polish'}
        17 { $FFLanguageLongClear = 'Portuguese'}
        18 { $FFLanguageLongClear = 'Romanian'}
        19 { $FFLanguageLongClear = 'Russian'}
        20 { $FFLanguageLongClear = 'Slovak'}
        21 { $FFLanguageLongClear = 'Slovenian'}
        22 { $FFLanguageLongClear = 'Spanish'}
        23 { $FFLanguageLongClear = 'Swedish'}
        24 { $FFLanguageLongClear = 'Turkish'}
        25 { $FFLanguageLongClear = 'Ukrainian'}
    }
}

If ($MozillaThunderbird_Architecture -ne "") {
    Switch ($MozillaThunderbird_Architecture) {
        1 { $MozillaThunderbirdArchitectureClear = 'x86'}
        2 { $MozillaThunderbirdArchitectureClear = 'x64'}
    }
}
Else {
    $MozillaThunderbirdArchitectureClear = $ArchitectureClear
}

If ($MozillaThunderbird_Language -ne "") {
    Switch ($MozillaThunderbird_Language) {
        1 { $MozillaThunderbirdLanguageClear = 'ar'}
        2 { $MozillaThunderbirdLanguageClear = 'zh-CN'}
        3 { $MozillaThunderbirdLanguageClear = 'nl'}
        4 { $MozillaThunderbirdLanguageClear = 'en-US'}
        5 { $MozillaThunderbirdLanguageClear = 'fr'}
        6 { $MozillaThunderbirdLanguageClear = 'de'}
        7 { $MozillaThunderbirdLanguageClear = 'it'}
        8 { $MozillaThunderbirdLanguageClear = 'ja'}
        9 { $MozillaThunderbirdLanguageClear = 'pt-PT'}
        10 { $MozillaThunderbirdLanguageClear = 'ru'}
        11 { $MozillaThunderbirdLanguageClear = 'es-ES'}
        12 { $MozillaThunderbirdLanguageClear = 'sv-SE'}
    }
    Switch ($MozillaThunderbird_Language) {
        1 { $MozillaThunderbirdLanguageLongClear = 'Arabic'}
        2 { $MozillaThunderbirdLanguageLongClear = 'Chinese'}
        3 { $MozillaThunderbirdLanguageLongClear = 'Dutch'}
        4 { $MozillaThunderbirdLanguageLongClear = 'English'}
        5 { $MozillaThunderbirdLanguageLongClear = 'French'}
        6 { $MozillaThunderbirdLanguageLongClear = 'German'}
        7 { $MozillaThunderbirdLanguageLongClear = 'Italian'}
        8 { $MozillaThunderbirdLanguageLongClear = 'Japanese'}
        9 { $MozillaThunderbirdLanguageLongClear = 'Portuguese'}
        10 { $MozillaThunderbirdLanguageLongClear = 'Russian'}
        11 { $MozillaThunderbirdLanguageLongClear = 'Spanish'}
        12 { $MozillaThunderbirdLanguageLongClear = 'Swedish'}
    }
}
Else {
    Switch ($Language) {
        0 { $MozillaThunderbirdLanguageClear = 'ar'}
        1 { $MozillaThunderbirdLanguageClear = 'zh-CN'}
        2 { $MozillaThunderbirdLanguageClear = 'en-US'}
        3 { $MozillaThunderbirdLanguageClear = 'en-US'}
        4 { $MozillaThunderbirdLanguageClear = 'en-US'}
        5 { $MozillaThunderbirdLanguageClear = 'nl'}
        6 { $MozillaThunderbirdLanguageClear = 'en-US'}
        7 { $MozillaThunderbirdLanguageClear = 'en-US'}
        8 { $MozillaThunderbirdLanguageClear = 'fr'}
        9 { $MozillaThunderbirdLanguageClear = 'de'}
        10 { $MozillaThunderbirdLanguageClear = 'en-US'}
        11 { $MozillaThunderbirdLanguageClear = 'en-US'}
        12 { $MozillaThunderbirdLanguageClear = 'it'}
        13 { $MozillaThunderbirdLanguageClear = 'ja'}
        14 { $MozillaThunderbirdLanguageClear = 'en-US'}
        15 { $MozillaThunderbirdLanguageClear = 'en-US'}
        16 { $MozillaThunderbirdLanguageClear = 'en-US'}
        17 { $MozillaThunderbirdLanguageClear = 'pt-PT'}
        18 { $MozillaThunderbirdLanguageClear = 'en-US'}
        19 { $MozillaThunderbirdLanguageClear = 'ru'}
        20 { $MozillaThunderbirdLanguageClear = 'en-US'}
        21 { $MozillaThunderbirdLanguageClear = 'en-US'}
        22 { $MozillaThunderbirdLanguageClear = 'es-ES'}
        23 { $MozillaThunderbirdLanguageClear = 'sv-SE'}
        24 { $MozillaThunderbirdLanguageClear = 'en-US'}
        25 { $MozillaThunderbirdLanguageClear = 'en-US'}
    }
    Switch ($Language) {
        0 { $MozillaThunderbirdLanguageLongClear = 'Arabic'}
        1 { $MozillaThunderbirdLanguageLongClear = 'Chinese'}
        2 { $MozillaThunderbirdLanguageLongClear = 'English'}
        3 { $MozillaThunderbirdLanguageLongClear = 'English'}
        4 { $MozillaThunderbirdLanguageLongClear = 'English'}
        5 { $MozillaThunderbirdLanguageLongClear = 'Dutch'}
        6 { $MozillaThunderbirdLanguageLongClear = 'English'}
        7 { $MozillaThunderbirdLanguageLongClear = 'English'}
        8 { $MozillaThunderbirdLanguageLongClear = 'French'}
        9 { $MozillaThunderbirdLanguageLongClear = 'German'}
        10 { $MozillaThunderbirdLanguageLongClear = 'English'}
        11 { $MozillaThunderbirdLanguageLongClear = 'English'}
        12 { $MozillaThunderbirdLanguageLongClear = 'Italian'}
        13 { $MozillaThunderbirdLanguageLongClear = 'Japanese'}
        14 { $MozillaThunderbirdLanguageLongClear = 'English'}
        15 { $MozillaThunderbirdLanguageLongClear = 'English'}
        16 { $MozillaThunderbirdLanguageLongClear = 'English'}
        17 { $MozillaThunderbirdLanguageLongClear = 'Portuguese'}
        18 { $MozillaThunderbirdLanguageLongClear = 'English'}
        19 { $MozillaThunderbirdLanguageLongClear = 'Russian'}
        20 { $MozillaThunderbirdLanguageLongClear = 'English'}
        21 { $MozillaThunderbirdLanguageLongClear = 'English'}
        22 { $MozillaThunderbirdLanguageLongClear = 'Spanish'}
        23 { $MozillaThunderbirdLanguageLongClear = 'Swedish'}
        24 { $MozillaThunderbirdLanguageLongClear = 'English'}
        25 { $MozillaThunderbirdLanguageLongClear = 'English'}
    }
}

If ($NotepadPlusPlus_Architecture -ne "") {
    Switch ($NotepadPlusPlus_Architecture) {
        1 { $NotepadPlusPlusArchitectureClear = 'x86'}
        2 { $NotepadPlusPlusArchitectureClear = 'x64'}
    }
}
Else {
    $NotepadPlusPlusArchitectureClear = $ArchitectureClear
}

If ($OpenJDK_Architecture -ne "") {
    Switch ($OpenJDK_Architecture) {
        1 { $OpenJDKArchitectureClear = 'x86'}
        2 { $OpenJDKArchitectureClear = 'x64'}
        3 { $OpenJDKArchitectureClear = 'both'}
    }
}
Else {
    $OpenJDKArchitectureClear = $ArchitectureClear
}

Switch ($OpenJDKPackage) {
    0 { $OpenJDKPackageClear = '8'}
    1 { $OpenJDKPackageClear = '11'}
    2 { $OpenJDKPackageClear = '17'}
}

If ($OpenWebStart_Architecture -ne "") {
    Switch ($OpenWebStart_Architecture) {
        1 { $OpenWebStartArchitectureClear = 'x86'}
        2 { $OpenWebStartArchitectureClear = 'x64'}
    }
}
Else {
    $OpenWebStartArchitectureClear = $ArchitectureClear
}

If ($OperaBrowser_Architecture -ne "") {
    Switch ($OperaBrowser_Architecture) {
        1 { $OperaBrowserArchitectureClear = 'x86'}
        2 { $OperaBrowserArchitectureClear = 'x64'}
    }
}
Else {
    $OperaBrowserArchitectureClear = $ArchitectureClear
}

Switch ($OperaBrowserChannel) {
    0 { $OperaBrowserChannelClear = 'Beta'}
    1 { $OperaBrowserChannelClear = 'Developer'}
    2 { $OperaBrowserChannelClear = 'Stable'}
}

If ($OracleJava8_Architecture -ne "") {
    Switch ($OracleJava8_Architecture) {
        1 { 
            $OracleJava8ArchitectureClear = 'x86'
            $OracleJava8ArchitectureVersionClear = ''
        }
        2 { 
            $OracleJava8ArchitectureClear = 'x64'
            $OracleJava8ArchitectureVersionClear = '64-Bit'
        }
        3 { 
            $OracleJava8ArchitectureClear = 'both'
            $OracleJava8Architecture2VersionClear = ''
            $OracleJava8ArchitectureVersionClear = '64-Bit'
        }
    }
}
Else {
    $OracleJava8ArchitectureClear = $ArchitectureClear
}

If ($PaintDotNet_Architecture -ne "") {
    Switch ($PaintDotNet_Architecture) {
        1 { $PaintDotNetArchitectureClear = 'x86'}
        2 { $PaintDotNetArchitectureClear = 'x64'}
    }
}
Else {
    $PaintDotNetArchitectureClear = $ArchitectureClear
}

Switch ($pdfforgePDFCreatorChannel) {
    0 { $pdfforgePDFCreatorChannelClear = 'Free'}
    1 { $pdfforgePDFCreatorChannelClear = 'Professional'}
    2 { $pdfforgePDFCreatorChannelClear = 'Terminal Server'}
}

If ($PeaZip_Architecture -ne "") {
    Switch ($PeaZip_Architecture) {
        1 { $PeaZipArchitectureClear = 'x86'}
        2 { $PeaZipArchitectureClear = 'x64'}
    }
}
Else {
    $PeaZipArchitectureClear = $ArchitectureClear
}

If ($Putty_Architecture -ne "") {
    Switch ($Putty_Architecture) {
        1 { $PuttyArchitectureClear = 'x86'}
        2 { $PuttyArchitectureClear = 'x64'}
    }
}
Else {
    $PuttyArchitectureClear = $ArchitectureClear
}

Switch ($PuttyChannel) {
    0 { $PuttyChannelClear = 'Pre-Release'}
    1 { $PuttyChannelClear = 'Stable'}
}

If ($Slack_Installer -ne "") {
    Switch ($Slack_Installer) {
        1 { $SlackInstallerClear = 'Machine Based'}
        2 { $SlackInstallerClear = 'User Based'}
    }
}
Else {
    $SlackInstallerClear = $InstallerClear
}

If ($SlackInstallerClear -eq 'Machine Based') {
    $SlackInstallerID = '0'
} 
else {
    $SlackInstallerID = '1'
}

Switch ($SlackInstallerID) {
    0 { $SlackPlatformClear = 'PerMachine'}
    1 { $SlackPlatformClear = 'PerUser'}
}

Switch ($SlackInstallerID) {
    0 { 
        If ($Slack_Architecture -ne "") {
            Switch ($Slack_Architecture) {
                1 { $SlackArchitectureClear = 'x86'}
                2 { $SlackArchitectureClear = 'x64'}
            }
        }
        Else {
            $SlackArchitectureClear = $ArchitectureClear
        }
    }
    1 { $SlackArchitectureClear = 'x64'}
}

If ($SumatraPDF_Architecture -ne "") {
    Switch ($SumatraPDF_Architecture) {
        1 { $SumatraPDFArchitectureClear = 'x86'}
        2 { $SumatraPDFArchitectureClear = 'x64'}
    }
}
Else {
    $SumatraPDFArchitectureClear = $ArchitectureClear
}

If ($TeamViewer_Architecture -ne "") {
    Switch ($TeamViewer_Architecture) {
        1 { $TeamViewerArchitectureClear = 'x86'}
        2 { $TeamViewerArchitectureClear = 'x64'}
    }
}
Else {
    $TeamViewerArchitectureClear = $ArchitectureClear
}

If ($TechSmithSnagIt_Architecture -ne "") {
    Switch ($TechSmithSnagIt_Architecture) {
        1 { $TechSmithSnagItArchitectureClear = 'x86'}
        2 { $TechSmithSnagItArchitectureClear = 'x64'}
    }
}
Else {
    $TechSmithSnagItArchitectureClear = $ArchitectureClear
}

If ($TotalCommander_Architecture -ne "") {
    Switch ($TotalCommander_Architecture) {
        1 { $TotalCommanderArchitectureClear = 'x86'}
        2 { $TotalCommanderArchitectureClear = 'x64'}
    }
}
Else {
    $TotalCommanderArchitectureClear = $ArchitectureClear
}

If ($VLCPlayer_Architecture -ne "") {
    Switch ($VLCPlayer_Architecture) {
        1 { $VLCPlayerArchitectureClear = 'x86'}
        2 { $VLCPlayerArchitectureClear = 'x64'}
    }
}
Else {
    $VLCPlayerArchitectureClear = $ArchitectureClear
}

If ($VMwareTools_Architecture -ne "") {
    Switch ($VMwareTools_Architecture) {
        1 { $VMwareToolsArchitectureClear = 'x86'}
        2 { $VMwareToolsArchitectureClear = 'x64'}
    }
}
Else {
    $VMwareToolsArchitectureClear = $ArchitectureClear
}

If ($WinMerge_Architecture -ne "") {
    Switch ($WinMerge_Architecture) {
        1 { $WinMergeArchitectureClear = 'x86'}
        2 { $WinMergeArchitectureClear = 'x64'}
    }
}
Else {
    $WinMergeArchitectureClear = $ArchitectureClear
}

If ($WinRAR_Architecture -ne "") {
    Switch ($WinRAR_Architecture) {
        1 { $WinRARArchitectureClear = 'x86'}
        2 { $WinRARArchitectureClear = 'x64'}
    }
}
Else {
    $WinRARArchitectureClear = $ArchitectureClear
}

If ($WinRAR_Language -ne "") {
    Switch ($WinRAR_Language) {
        1 { $WinRARLanguageClear = 'Arabic'}
        2 { $WinRARLanguageClear = 'Chinese'}
        3 { $WinRARLanguageClear = 'Croatian'}
        4 { $WinRARLanguageClear = 'Czech'}
        5 { $WinRARLanguageClear = 'Danish'}
        6 { $WinRARLanguageClear = 'Dutch'}
        7 { $WinRARLanguageClear = 'English'}
        8 { $WinRARLanguageClear = 'Finnish'}
        9 { $WinRARLanguageClear = 'French'}
        10 { $WinRARLanguageClear = 'German'}
        11 { $WinRARLanguageClear = 'Hebrew'}
        12 { $WinRARLanguageClear = 'Hungarian'}
        13 { $WinRARLanguageClear = 'Italian'}
        14 { $WinRARLanguageClear = 'Japanese'}
        15 { $WinRARLanguageClear = 'Korean'}
        16 { $WinRARLanguageClear = 'Norwegian'}
        17 { $WinRARLanguageClear = 'Polish'}
        18 { $WinRARLanguageClear = 'Portuguese'}
        19 { $WinRARLanguageClear = 'Romanian'}
        20 { $WinRARLanguageClear = 'Russian'}
        21 { $WinRARLanguageClear = 'Slovak'}
        22 { $WinRARLanguageClear = 'Slovenian'}
        23 { $WinRARLanguageClear = 'Spanish'}
        24 { $WinRARLanguageClear = 'Swedish'}
        25 { $WinRARLanguageClear = 'Turkish'}
        26 { $WinRARLanguageClear = 'Ukrainian'}
    }
}
Else {
    $WinRARLanguageClear = $LanguageClear
}

Switch ($WinRARChannel) {
    0 { $WinRARChannelClear = 'Beta'}
    1 { $WinRARChannelClear = 'Stable'}
}

If ($Wireshark_Architecture -ne "") {
    Switch ($Wireshark_Architecture) {
        1 { $WiresharkArchitectureClear = 'x86'}
        2 { $WiresharkArchitectureClear = 'x64'}
    }
}
Else {
    $WiresharkArchitectureClear = $ArchitectureClear
}

If ($Zoom_Architecture -ne "") {
    Switch ($Zoom_Architecture) {
        1 { $ZoomArchitectureClear = 'x86'}
        2 { $ZoomArchitectureClear = 'x64'}
    }
}
Else {
    $ZoomArchitectureClear = $ArchitectureClear
}

If ($Zoom_Installer -ne "") {
    Switch ($Zoom_Installer) {
        1 { $ZoomInstallerClear = 'Machine Based'}
        2 { $ZoomInstallerClear = 'User Based'}
    }
}
Else {
    $ZoomInstallerClear = $InstallerClear
}

Write-Host -ForegroundColor Green "Software selection done."
Write-Output ""

Write-Host -ForegroundColor DarkGray "Selected Global Mode."
Write-Host "Global Language is $LanguageClear."
Write-Host "Global Architecture is $ArchitectureClear."
Write-Host "Global Installer Type is $InstallerClear."
Write-Output ""

Write-Host -ForegroundColor DarkGray "Selected Options."
If ($Download -eq "1") { Write-Host -ForegroundColor Green "Download Option Enabled." }
Else { Write-Host "Download Option Disabled." }
If ($Install -eq "1") { Write-Host -ForegroundColor Green "Install Option Enabled." }
Else { Write-Host "Install Option Disabled." }
If ($WhatIf) { Write-Host -ForegroundColor Green "What If Option Enabled." }
Else { Write-Host "What If Option Disabled." }
If ($Repository) { Write-Host -ForegroundColor Green "Installer Repository Option Enabled." }
Else { Write-Host "Installer Repository Option Disabled." }
If ($CleanUp) { Write-Host -ForegroundColor Green "Installer Clean Up Option Enabled." }
Else { Write-Host "Installer Clean Up Option Disabled." }
If ($CleanUpStartMenu) { Write-Host -ForegroundColor Green "Start Menu Clean Up Option Enabled." }
Else { Write-Host "Start Menu Clean Up Option Disabled." }
If ($Report) { Write-Host -ForegroundColor Green "Report Mode Option Enabled." }
Else { Write-Host "Report Mode Option Disabled." }
If ($NoDesktopIcon) { Write-Host -ForegroundColor Green "No NeverRed Icon Option Enabled." }
Else { Write-Host "No NeverRed Icon Option Disabled." }
If ($WindowsUpdate) { Write-Host -ForegroundColor Green "Windows Update Option Enabled." }
Else { Write-Host "Windows Update Option Disabled." }
Write-Output ""

#// Mark: Report Mode
If ($Report -eq "1") {
    Write-Host -ForegroundColor Magenta "Report Mode, nothing will be downloaded or installed !!!"
    Write-Host -ForegroundColor Green "The report will be saved under _Report !!!"
    Write-Output ""
    $Download = "0"
    $Install = "0"
    $ReportDir = "$PSScriptRoot\_Report"
    $ReportFileName = ("Report - $ENV:COMPUTERNAME - $Date.log")
    $ReportFile = Join-path $ReportDir $ReportFileName
    
    # Create the log directories if they don't exist
    If (!(Test-Path $ReportDir)) { New-Item -Path $ReportDir -ItemType directory | Out-Null }
    
    # Create new log file (overwrite existing one)
    New-Item $ReportFile -ItemType "file" -force | Out-Null
    Add-Content -Path "$ReportFile" -Value "Report Mode"
    Add-Content -Path "$ReportFile" -Value ""

    #Download and Install Report
    If ($1Password -eq 1) {
        $Product = "1Password"
        $1PasswordD = Get-EvergreenApp -Name 1Password | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $1PasswordD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion1 = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $1PasswordV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$1PasswordV) {
            $1PasswordV = (Get-ItemProperty HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* -ErrorAction SilentlyContinue | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersion1"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion1"
        Write-Host "Installed Version:  $1PasswordV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $1PasswordV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersion1 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($1PasswordV -lt $Version) {
            If (!$1PasswordV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($7ZIP -eq 1) {
        $Product = "7-Zip"
        $7ZipD = Get-7-Zip | Where-Object { $_.Architecture -eq "$7ZipArchitectureClear"}
        $Version = $7ZipD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$7ZipArchitectureClear" + ".txt"
        $CurrentVersion7 = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $SevenZip = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*7-Zip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SevenZip) {
            $SevenZip = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*7-Zip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $7ZipArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $7ZipArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersion7"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion7"
        Write-Host "Installed Version:  $SevenZip"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $SevenZip"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersion7 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($SevenZip -lt $Version) {
            If (!$SevenZip) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($AdobeProDC -eq 1) {
        $Product = "Adobe Pro DC"
        $PackageName = "Adobe_Pro_DC_Update_" + "$AdobeProArchitectureClear"
        $AdobeProD = Get-EvergreenApp -Name AdobeAcrobat | Where-Object { $_.Track -eq "DC" -and $_.Language -eq "Neutral" -and $_.Product -eq "Acrobat" -and $_.Architecture -eq "$AdobeProArchitectureClear" }
        $Version = $AdobeProD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeProArchitectureClear" + ".txt"
        $CurrentVersionA = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $Adobe = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Adobe Acrobat DC"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Adobe) {
            $Adobe = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Adobe Acrobat DC"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $AdobeProArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $AdobeProArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionA"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionA"
        Write-Host "Installed Version:  $Adobe"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $Adobe"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionA -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($Adobe -lt $Version) {
            If (!$Adobe) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($AdobeReaderDC -eq 1) {
        $Product = "Adobe Reader DC"
        If ($AdobeLanguageClear -eq "MUI") {
            $AdobeReaderD = Get-EvergreenApp -Name AdobeAcrobatReaderDC | Where-Object {$_.Language -eq "$AdobeLanguageClear" -and $_.Architecture -eq "$AdobeArchitectureClear"}
        } else {
            $AdobeReaderD = Get-EvergreenApp -Name AdobeAcrobatReaderDC | Where-Object {$_.Language -eq "$AdobeLanguageClear"}
        }
        $Version = $AdobeReaderD.Version
        If ($AdobeArchitectureClear -eq "x64" -and $AdobeLanguageClear -ne "MUI") {
            If ($AdobeLanguageClear -eq "German" -or $AdobeLanguageClear -eq "English" -or $AdobeLanguageClear -eq "French" -or $AdobeLanguageClear -eq "Japanese" -or $AdobeLanguageClear -eq "Spanish") {} else {
                $AdobeReaderDx64 = Get-EvergreenApp -Name AdobeAcrobatReaderDC | Where-Object {$_.Language -eq "MUI" -and $_.Architecture -eq "x64"}
                $Version = $AdobeReaderDx64.Version
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeArchitectureClear" + "_$AdobeLanguageClear" + ".txt"
        $CurrentVersionAR = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $Adobe2 = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Adobe Acrobat*" -and $_.DisplayName -notlike "*DC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Adobe2) {
            $Adobe2 = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Adobe Acrobat*" -and $_.DisplayName -notlike "*DC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $AdobeLanguageClear $AdobeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $AdobeLanguageClear $AdobeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionAR"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionAR"
        Write-Host "Installed Version:  $Adobe2"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $Adobe2"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionAR -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($Adobe2 -lt $Version) {
            If (!$Adobe2) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($AutodeskDWGTrueView -eq 1) {
        $Product = "Autodesk DWG TrueView"
        $AutodeskDWGTrueViewD = Get-DWGTrueView
        $Version = $AutodeskDWGTrueViewD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionAD = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $DWGTrueView = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*DWG TrueView*"}).DisplayName | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$DWGTrueView) {
            $DWGTrueView = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*DWG TrueView*"}).DisplayName | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($DWGTrueView) {$DWGTrueView = $DWGTrueView.split(" ")[2]}
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionAD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionAD"
        Write-Host "Installed Version:  $DWGTrueView"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $DWGTrueView"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionAD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($DWGTrueView -lt $Version) {
            If (!$DWGTrueView) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($BISF -eq 1) {
        $Product = "BIS-F"
        $BISFD = Get-EvergreenApp -Name BISF | Where-Object { $_.Type -eq "msi" }
        $Version = $BISFD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionB = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $BISFV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Base Image*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$BISFV) {
            $BISFV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Base Image*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($BISFV) {
            $BISFSplit = $BISFV.split(".")
            $BISFV = $BISFSplit[0] + "." + $BISFSplit[1] + "." + $BISFSplit[2]
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionB"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionB"
        Write-Host "Installed Version:  $BISFV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $BISFV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionB -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($BISFV -lt $Version) {
            If (!$BISFV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($BISF_Tools -eq 1) {
            $Product1 = "Citrix Optimizer"
            $Product2 = "SDelete"
            $Product3 = "DelProf2"
            $CitrixOptimizerD = Get-CitrixOptimizer
            $Version1 = $CitrixOptimizerD.Version
            $CurrentVersion1 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product1\Version.txt" -EA SilentlyContinue
            $CitrixOptimizerV = Get-Content -Path "C:\Program Files\$Product1\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "$Product1"
            Add-Content -Path "$ReportFile" -Value "$Product1"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version1"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version1"
            Write-Host "Downloaded Version: $CurrentVersion1"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion1"
            Write-Host "Installed Version:  $CitrixOptimizerV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $CitrixOptimizerV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion1 -lt $Version1) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($CitrixOptimizerV -lt $Version1) {
                If (!$CitrixOptimizerV) {
                    Write-Host -ForegroundColor Cyan "No copied version found"
                    Add-Content -Path "$ReportFile" -Value "No copied version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for copied version"
                    Add-Content -Path "$ReportFile" -Value "Update available for copied version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for copied version"
                Add-Content -Path "$ReportFile" -Value "No update available for copied version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            $SDeleteD = Get-SDelete
            $Version2 = $SDeleteD.Version
            $CurrentVersion2 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product2\Version.txt" -EA SilentlyContinue
            $SDeleteV = Get-Content -Path "C:\Windows\System32\$Product2\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "$Product2"
            Add-Content -Path "$ReportFile" -Value "$Product2"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version2"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2"
            Write-Host "Downloaded Version: $CurrentVersion2"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2"
            Write-Host "Installed Version:  $SDeleteV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $SDeleteV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion2 -lt $Version2) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($SDeleteV -lt $Version2) {
                If (!$SDeleteV) {
                    Write-Host -ForegroundColor Cyan "No copied version found"
                    Add-Content -Path "$ReportFile" -Value "No copied version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for copied version"
                    Add-Content -Path "$ReportFile" -Value "Update available for copied version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for copied version"
                Add-Content -Path "$ReportFile" -Value "No update available for copied version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            $DelProf2D = Get-DelProf2
            $Version3 = $DelProf2D.Version
            $CurrentVersion3 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product3\Version.txt" -EA SilentlyContinue
            $DelProf2V = Get-Content -Path "C:\Windows\System32\$Product3\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "$Product3"
            Add-Content -Path "$ReportFile" -Value "$Product3"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version3"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version3"
            Write-Host "Downloaded Version: $CurrentVersion3"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion3"
            Write-Host "Installed Version:  $DelProf2V"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $DelProf2V"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion3 -lt $Version3) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($DelProf2V -lt $Version3) {
                If (!$DelProf2V) {
                    Write-Host -ForegroundColor Cyan "No copied version found"
                    Add-Content -Path "$ReportFile" -Value "No copied version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for copied version"
                    Add-Content -Path "$ReportFile" -Value "Update available for copied version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for copied version"
                Add-Content -Path "$ReportFile" -Value "No update available for copied version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
    }

    If ($CiscoWebexTeams -eq 1) {
        If ($CiscoWebexTeamsClient -eq "0") {
            $Product = "Cisco Webex Teams"
            $WebexTeamsD = Get-CiscoWebex | Where-Object { $_.Architecture -eq "$CiscoWebexTeamsArchitectureClear"}
            $Version = $WebexTeamsD.Version
            $CiscoSplit = $Version.split(".")
            $CiscoStringMiddle = ([regex]::Matches($CiscoSplit[1], "." )).count
            If ($CiscoStringMiddle -lt "2") {
                $CiscoSplit[1] = "0" + $CiscoSplit[1]
                $Version = $CiscoSplit[0] + "." + $CiscoSplit[1] + "." + $CiscoSplit[2] + "." + $CiscoSplit[3]
            }
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $CurrentVersionCW = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            $CiscoCurrentSplit = $CurrentVersionCW.split(".")
            $CiscoCurrentStringMiddle = ([regex]::Matches($CiscoCurrentSplit[1], "." )).count
            If ($CiscoCurrentStringMiddle -lt "2") {
                $CiscoCurrentSplit[1] = "0" + $CiscoCurrentSplit[1]
                $CurrentVersionCW = $CiscoCurrentSplit[0] + "." + $CiscoCurrentSplit[1] + "." + $CiscoCurrentSplit[2] + "." + $CiscoCurrentSplit[3]
            }
            $CiscoWebexTeamsV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$CiscoWebexTeamsV) {
            $CiscoWebexTeamsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $CiscoDSplit = $CiscoWebexTeamsV.split(".")
            $CiscoDStringMiddle = ([regex]::Matches($CiscoDSplit[1], "." )).count
            If ($CiscoDStringMiddle -lt "2") {
                $CiscoDSplit[1] = "0" + $CiscoDSplit[1]
                $CiscoWebexTeamsV = $CiscoDSplit[0] + "." + $CiscoDSplit[1] + "." + $CiscoDSplit[2] + "." + $CiscoDSplit[3]
            }
            Write-Host -ForegroundColor Magenta "$Product $CiscoWebexTeamsArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product $CiscoWebexTeamsArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersionCW"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCW"
            Write-Host "Installed Version:  $CiscoWebexTeamsV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $CiscoWebexTeamsV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersionCW -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($CiscoWebexTeamsV -lt $Version) {
                If (!$CiscoWebexTeamsV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
        If ($CiscoWebexTeamsClient -eq "1") {
            $Product = "Cisco Webex Teams VDI Plugin"
            $WebexTeamsVDID = Get-CiscoWebexVDI | Where-Object { $_.Architecture -eq "$CiscoWebexTeamsArchitectureClear" }
            $Version = $WebexTeamsVDID.Version
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $CurrentVersionCWT = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            $WebexTeamsVDIV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex VDI Plugin"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$WebexTeamsVDIV) {
                $WebexTeamsVDIV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex VDI Plugin"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            Write-Host -ForegroundColor Magenta "$Product $CiscoWebexTeamsArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product $CiscoWebexTeamsArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersionCWT"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCWT"
            Write-Host "Installed Version:  $WebexTeamsVDIV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $WebexTeamsVDIV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersionCWT -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($WebexTeamsVDIV -lt $Version) {
                If (!$WebexTeamsVDIV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
    }

    If ($CitrixFiles -eq 1) {
        $Product = "Citrix Files"
        $CitrixFilesD = Get-NevergreenApp -Name CitrixFiles | Where-Object {$_.Type -eq "Msi"}
        $Version = $CitrixFilesD.Version
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version.txt"
        $CurrentVersionCF = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CitrixFilesV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Files*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$CitrixFilesV) {
            $CitrixFilesV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Files*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCF"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCF"
        Write-Host "Installed Version:  $CitrixFilesV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $CitrixFilesV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCF -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($CitrixFilesV -lt $Version) {
            If (!$CitrixFilesV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }
    
    If ($Citrix_Hypervisor_Tools -eq 1) {
        $Product = "Citrix Hypervisor Tools"
        $CitrixHypervisor = Get-EvergreenApp -Name CitrixVMTools | Where-Object {$_.Architecture -eq "$CitrixHypervisorToolsArchitectureClear"} | Select-Object -Last 1
        $Version = $CitrixHypervisor.Version
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version_" + "$CitrixHypervisorToolsArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $HypTools = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Hypervisor*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$HypTools) {
            $HypTools = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Hypervisor*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($HypTools) {$HypTools = $HypTools.Insert(3,'.0')}
        Write-Host -ForegroundColor Magenta "$Product $CitrixHypervisorToolsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $CitrixHypervisorToolsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCH"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCH"
        Write-Host "Installed Version:  $HypTools"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $HypTools"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCH -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($HypTools -lt $Version) {
            If (!$HypTools) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Citrix_WorkspaceApp -eq 1) {
        $Product = "Citrix WorkspaceApp $CitrixWorkspaceAppReleaseClear"
        If ($CitrixWorkspaceAppReleaseClear -eq "Current") {
            #$WSACD = Get-WorkspaceAppCurrent
            $WSACD = Get-EvergreenApp -Name CitrixWorkspaceApp -WarningAction:SilentlyContinue | Where-Object { $_.Title -like "*Workspace*" -and $_.Stream -like "*$CitrixWorkspaceAppReleaseClear*" }
        } else {
            $WSACD = Get-EvergreenApp -Name CitrixWorkspaceApp -WarningAction:SilentlyContinue | Where-Object { $_.Title -like "*Workspace*" -and $_.Stream -like "*$CitrixWorkspaceAppReleaseClear*" }
        }
        $Version = $WSACD.Version
        If ($Version) {
            $CurrentWSASplit = $Version.split(".")
            $CurrentWSAStrings = ([regex]::Matches($Version, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $CurrentVersionW = Get-Content -Path "$PSScriptRoot\Citrix\$Product\Version.txt" -EA SilentlyContinue
        If ($CurrentVersionW) {
            $CurrentWSASplit = $CurrentVersionW.split(".")
            $CurrentWSAStrings = ([regex]::Matches($CurrentVersionW, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $WSA = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*Trolley*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*Trolley*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*CWAInstaller*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*CWAInstaller*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($WSA) {
            $CurrentWSASplit = $WSA.split(".")
            $CurrentWSAStrings = ([regex]::Matches($WSA, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $WSA"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $WSA"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($WSA -lt $Version) {
            If (!$WSA) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ControlUpAgent -eq 1) {
        $Product = "ControlUp Agent"
        $ControlUpAgentD = Get-EvergreenApp -Name ControlUpAgent | Where-Object {$_.Architecture -eq "$ControlUpAgentArchitectureClear" }
        $Version = $ControlUpAgentD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpAgentArchitectureClear" + ".txt"
        $CurrentVersionCUA = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $ControlUpAgentV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUpAgent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ControlUpAgentV) {
            $ControlUpAgentV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUpAgent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $ControlUpAgentArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $ControlUpAgentArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCUA"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCUA"
        Write-Host "Installed Version:  $ControlUpAgentV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $ControlUpAgentV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCUA -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($ControlUpAgentV -lt $Version) {
            If (!$ControlUpAgentV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ControlUpEdgeDX -eq 1) {
        $Product = "ControlUp Edge DX Agent Manager"
        $ControlUpEdgeDXD = Get-ControlUpEdgeDX
        $Version = $ControlUpEdgeDXD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionCUE = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $ControlUpEdgeDXV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUp Edge DX - SIP Agent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ControlUpEdgeDXV) {
            $ControlUpEdgeDXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUp Edge DX - SIP Agent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $ControlUpEdgeDXInstallerClear"
        Add-Content -Path "$ReportFile" -Value "$Product $ControlUpEdgeDXInstallerClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCUE"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCUE"
        Write-Host "Installed Version:  $ControlUpEdgeDXV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $ControlUpEdgeDXV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCUE -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($ControlUpEdgeDXV -lt $Version) {
            If (!$ControlUpEdgeDXV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ControlUpRemoteDX -eq 1) {
        $Product = "ControlUp Remote DX"
        $CURDXD = Get-ControlUpRemoteDX | Where-Object { $_.Environment -eq "$ControlUpRemoteDXEUCClear"}
        $Version = $CURDXD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpRemoteDXEUCClear" + ".txt"
        $CurrentVersionCUR = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $CURDXV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "ControlUp Remote DX - $ControlUpRemoteDXEUCDLClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$CURDXV) {
            $CURDXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "ControlUp Remote DX - $ControlUpRemoteDXEUCDLClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $ControlUpRemoteDXEUCClear"
        Add-Content -Path "$ReportFile" -Value "$Product $ControlUpRemoteDXEUCClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCUR"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCUR"
        Write-Host "Installed Version:  $CURDXV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $CURDXV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCUR -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($CURDXV -lt $Version) {
            If (!$CURDXV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ControlUpConsole -eq 1) {
        $Product = "ControlUp Console"
        $ControlUpConsoleD = Get-EvergreenApp -Name ControlUpConsole
        $Version = $ControlUpConsoleD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionCUC = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionCUC"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionCUC"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionCUC -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($deviceTRUST -eq 1) {
        $Product = "deviceTRUST"
        $deviceTRUSTD = Get-EvergreenApp -Name deviceTRUST | Where-Object { $_.Platform -eq "Windows" -and $_.Type -eq "Bundle" } | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $deviceTRUSTD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$deviceTRUSTArchitectureClear" + ".txt"
        $CurrentVersiondT = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $deviceTRUSTClientV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Client*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTClientV) {
            $deviceTRUSTClientV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Client*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Host*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTHostV) {
            $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Host*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Agent*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTHostV) {
            $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Agent*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $deviceTRUSTConsoleV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Console*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTConsoleV) {
            $deviceTRUSTConsoleV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Console*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($deviceTRUSTClient -eq $True) {
            Write-Host -ForegroundColor Magenta "$Product Client Extension"
            Add-Content -Path "$ReportFile" -Value "$Product Client Extension"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersiondT"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersiondT"
            Write-Host "Installed Version:  $deviceTRUSTClientV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $deviceTRUSTClientV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersiondT -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($deviceTRUSTClientV -lt $Version) {
                If (!$deviceTRUSTClientV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
        If ($deviceTRUSTHost -eq $True) {
            Write-Host -ForegroundColor Magenta "$Product Agent $deviceTRUSTArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product Agent $deviceTRUSTArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersiondT"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersiondT"
            Write-Host "Installed Version:  $deviceTRUSTHostV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $deviceTRUSTHostV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersiondT -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($deviceTRUSTHostV -lt $Version) {
                If (!$deviceTRUSTHostV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
        If ($deviceTRUSTConsole -eq $True) {
            Write-Host -ForegroundColor Magenta "$Product Console $deviceTRUSTArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product Console $deviceTRUSTArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersiondT"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersiondT"
            Write-Host "Installed Version:  $deviceTRUSTConsoleV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $deviceTRUSTConsoleV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersiondT -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($deviceTRUSTConsoleV -lt $Version) {
                If (!$deviceTRUSTConsoleV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
    }

    If ($Ditto -eq 1) {
        $Product = "Ditto"
        $DittoD = Get-Ditto | Where-Object { $_.Architecture -eq "$DittoArchitectureClear" -and $_.Channel -eq "$DittoChannelClear"}
        $Version = $DittoD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$DittoArchitectureClear" + "_$DittoChannelClear" + ".txt"
        $CurrentVersionD = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $DittoV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Ditto*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$DittoV) {
            $DittoV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Ditto*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $DittoChannelClear channel $DittoArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $DittoChannelClear channel $DittoArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionD"
        Write-Host "Installed Version:  $DittoV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $DittoV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($DittoV -lt $Version) {
            If (!$DittoV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Filezilla -eq 1) {
        $Product = "Filezilla"
        $FilezillaD = Get-EvergreenApp -Name Filezilla | Where-Object { $_.URI -like "*win64*"}
        $Version = $FilezillaD.Version
        $CurrentVersionF = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $FilezillaV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Filezilla*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FilezillaV) {
            $FilezillaV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Filezilla*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionF"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionF"
        Write-Host "Installed Version:  $FilezillaV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $FilezillaV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionF -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($FilezillaV -lt $Version) {
            If (!$FilezillaV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($FoxitPDFEditor -eq 1) {
        $Product = "Foxit PDF Editor"
        $FoxitPDFEditorD = Get-EvergreenApp -Name FoxitPDFEditor -WarningAction:SilentlyContinue | Where-Object {$_.Language -eq "$FoxitPDFEditorLanguageClear"}
        $Version = $FoxitPDFEditorD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitPDFEditorLanguageClear" + ".txt"
        $CurrentVersionFR = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $FoxitPDFEditorV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Foxit PDF Editor"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FoxitPDFEditorV) {
            $FoxitPDFEditorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Foxit PDF Editor"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $FoxitPDFEditorLanguageClear"
        Add-Content -Path "$ReportFile" -Value "$Product $FoxitPDFEditorLanguageClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionFR"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionFR"
        Write-Host "Installed Version:  $FoxitPDFEditorV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $FoxitPDFEditorV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionFR -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($FoxitPDFEditorV -lt $Version) {
            If (!$FoxitPDFEditorV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Foxit_Reader -eq 1) {
        $Product = "Foxit Reader"
        $Foxit_ReaderD = Get-EvergreenApp -Name FoxitReader | Where-Object {$_.Language -eq "$FoxitReaderLanguageClear"}
        $Version = $Foxit_ReaderD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitReaderLanguageClear" + ".txt"
        $CurrentVersionFR1 = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $FReader = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FReader) {
            $FReader = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $FoxitReaderLanguageClear"
        Add-Content -Path "$ReportFile" -Value "$Product $FoxitReaderLanguageClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionFR1"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionFR1"
        Write-Host "Installed Version:  $FReader"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $FReader"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionFR1 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($FReader -lt $Version) {
            If (!$FReader) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($GIMP -eq 1) {
        $Product = "GIMP"
        $GIMPD = Get-EvergreenApp -Name GIMP
        $Version = $GIMPD.Version
        $CurrentVersionG = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $GIMPV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GIMP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GIMPV) {
            $GIMPV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GIMP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionG"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionG"
        Write-Host "Installed Version:  $GIMPV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $GIMPV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionG -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($GIMPV -lt $Version) {
            If (!$GIMPV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($GitForWindows -eq 1) {
        $Product = "Git for Windows"
        $GitForWindowsD = Get-EvergreenApp -Name GitForWindows | Where-Object {$_.Architecture -eq "$GitForWindowsArchitectureClear" -and $_.Type -eq "exe" -and $_.URI -like "*bit.exe"}
        $Version = $GitForWindowsD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GitForWindowsArchitectureClear" + ".txt"
        $CurrentVersionGW = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $GitForWindowsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Git"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GitForWindowsV) {
            $GitForWindowsV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Git"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $GitForWindowsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $GitForWindowsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionGW"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionGW"
        Write-Host "Installed Version:  $GitForWindowsV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $GitForWindowsV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionGW -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($GitForWindowsV -lt $Version) {
            If (!$GitForWindowsV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($GoogleChrome -eq 1) {
        $Product = "Google Chrome"
        $ChromeD = Get-EvergreenApp -Name GoogleChrome | Where-Object { $_.Architecture -eq "$GoogleChromeArchitectureClear" -and $_.Channel -eq "$GoogleChromeChannelClear"}
        $Version = $ChromeD.Version
        $ChromeSplit = $Version.split(".")
        $ChromeStrings = ([regex]::Matches($Version, "\." )).count
        $ChromeStringLast = ([regex]::Matches($ChromeSplit[$ChromeStrings], "." )).count
        If ($ChromeStringLast -lt "3") {
            $ChromeSplit[$ChromeStrings] = "0" + $ChromeSplit[$ChromeStrings]
        }
        Switch ($ChromeStrings) {
            1 {
                $NewVersion = $ChromeSplit[0] + "." + $ChromeSplit[1]
            }
            2 {
                $NewVersion = $ChromeSplit[0] + "." + $ChromeSplit[1] + "." + $ChromeSplit[2]
            }
            3 {
                $NewVersion = $ChromeSplit[0] + "." + $ChromeSplit[1] + "." + $ChromeSplit[2] + "." + $ChromeSplit[3]
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GoogleChromeArchitectureClear" + "_$GoogleChromeChannelClear" + ".txt"
        $CurrentVersionGC = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersionGC) {
            $CurrentChromeSplit = $CurrentVersionGC.split(".")
            $CurrentChromeStrings = ([regex]::Matches($CurrentVersionGC, "\." )).count
            $CurrentChromeStringLast = ([regex]::Matches($CurrentChromeSplit[$CurrentChromeStrings], "." )).count
            $CurrentChromeStringFirst = ([regex]::Matches($CurrentChromeSplit[0], "." )).count
            If ($CurrentChromeStringLast -lt "3") {
                $CurrentChromeSplit[$CurrentChromeStrings] = "0" + $CurrentChromeSplit[$CurrentChromeStrings]
            }
            If ($CurrentChromeStringFirst -lt "3") {
                $CurrentChromeSplit[0] = "0" + $CurrentChromeSplit[0]
            }
            Switch ($CurrentChromeStrings) {
                1 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1] + "." + $CurrentChromeSplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1] + "." + $CurrentChromeSplit[2] + "." + $CurrentChromeSplit[3]
                }
            }
        }
        If ($GoogleChromeChannelClear -eq "stable") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($GoogleChromeChannelClear -eq "dev") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($GoogleChromeChannelClear -eq "beta") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($Chrome) {
            $CurrentChromeSplit1 = $Chrome.split(".")
            $CurrentChromeStrings1 = ([regex]::Matches($Chrome, "\." )).count
            $CurrentChromeStringLast1 = ([regex]::Matches($CurrentChromeSplit1[$CurrentChromeStrings1], "." )).count
            $CurrentChromeStringFirst1 = ([regex]::Matches($CurrentChromeSplit1[0], "." )).count
            If ($CurrentChromeStringLast1 -lt "3") {
                $CurrentChromeSplit1[$CurrentChromeStrings1] = "0" + $CurrentChromeSplit1[$CurrentChromeStrings1]
            }
            If ($CurrentChromeStringFirst1 -lt "3") {
                $CurrentChromeSplit1[0] = "0" + $CurrentChromeSplit1[0]
            }
            Switch ($CurrentChromeStrings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1] + "." + $CurrentChromeSplit1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1] + "." + $CurrentChromeSplit1[2] + "." + $CurrentChromeSplit1[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($NewCurrentVersion1 -lt $NewVersion) {
            If (!$NewCurrentVersion1) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Greenshot -eq 1) {
        $Product = "Greenshot"
        $GreenshotD = Get-EvergreenApp -Name Greenshot | Where-Object { $_.Architecture -eq "x86" -and $_.URI -like "*INSTALLER*" -and $_.Type -like "exe"}
        $Version = $GreenshotD.Version
        $CurrentVersionGr = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $GreenshotV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Greenshot*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GreenshotV) {
            $GreenshotV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Greenshot*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionGr"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionGr"
        Write-Host "Installed Version:  $GreenshotV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $GreenshotV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionGr -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($GreenshotV -lt $Version) {
            If (!$GreenshotV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($IISCrypto -eq 1) {
        $Product = "IIS Crypto"
        $IISCryptoD = Get-IISCrypto
        $Version = $IISCryptoD.Version
        $CurrentVersionIIS = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionIIS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionIIS"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionIIS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ImageGlass -eq 1) {
        $Product = "ImageGlass"
        $ImageGlassD = Get-EvergreenApp -Name ImageGlass | Where-Object { $_.Architecture -eq "$ImageGlassArchitectureClear" -and $_.URI -notlike "*deleted*"  }
        $Version = $ImageGlassD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ImageGlassArchitectureClear" + ".txt"
        $CurrentVersionIG = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $ImageGlassV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ImageGlass"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ImageGlassV) {
            $ImageGlassV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ImageGlass"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $ImageGlassArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $ImageGlassArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionIG"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionIG"
        Write-Host "Installed Version:  $ImageGlassV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $ImageGlassV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionIG -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($ImageGlassV -lt $Version) {
            If (!$ImageGlassV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($IrfanView -eq 1) {
        $Product = "IrfanView"
        $IrfanViewD = Get-IrfanView | Where-Object {$_.Architecture -eq "$IrfanViewArchitectureClear"}
        $Version = $IrfanViewD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$IrfanViewArchitectureClear" + ".txt"
        $CurrentVersionIV = Get-Content -Path $VersionPath -EA SilentlyContinue 
        $IrfanViewV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IrfanView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$IrfanViewV) {
            $IrfanViewV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IrfanView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $IrfanViewLanguageLongClear $IrfanViewArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $IrfanViewLanguageLongClear $IrfanViewArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionIV"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionIV"
        Write-Host "Installed Version:  $IrfanViewV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $IrfanViewV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionIV -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($IrfanViewV -lt $Version) {
            If (!$IrfanViewV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($KeePass -eq 1) {
        $Product = "KeePass"
        $KeePassD = Get-EvergreenApp -Name KeePass | Where-Object { $_.Type -eq "msi" }
        $Version = $KeePassD.Version
        $CurrentVersionKP = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
        $KeePassV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*KeePass*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$KeePassV) {
            $KeePassV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*KeePass*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($KeePassV) {
            $KeePassVSplit = $KeePassV.split(".")
            $KeePassV = $KeePassVSplit[0] + "." + $KeePassVSplit[1]
        }
        Write-Host -ForegroundColor Magenta "$Product $KeePassLanguageClear"
        Add-Content -Path "$ReportFile" -Value "$Product $KeePassLanguageClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionKP"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionKP"
        Write-Host "Installed Version:  $KeePassV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $KeePassV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionKP -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($KeePassV -lt $Version) {
            If (!$KeePassV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($LogMeInGoToMeeting -eq 1) {
        If ($LogMeInGoToMeetingInstallerClear -eq 'Machine Based') {
            $Product = "LogMeIn GoToMeeting XenApp"
            $LogMeInGoToMeetingD = Get-EvergreenApp -Name LogMeInGoToMeeting | Where-Object { $_.Type -eq "XenAppLatest" }
            $Version = $LogMeInGoToMeetingD.Version
            $CurrentVersionGTM = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
            $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$LogMeInGoToMeetingV) {
                $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($LogMeInGoToMeetingInstallerClear -eq 'User Based') {
            $Product = "LogMeIn GoToMeeting"
            $LogMeInGoToMeetingD = Get-EvergreenApp -Name LogMeInGoToMeeting | Where-Object { $_.Type -eq "Latest" }
            $Version = $LogMeInGoToMeetingD.Version
            $CurrentVersionGTM = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
            $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$LogMeInGoToMeetingV) {
                $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionGTM"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionGTM"
        Write-Host "Installed Version:  $LogMeInGoToMeetingV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $LogMeInGoToMeetingV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionGTM -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($LogMeInGoToMeetingV -lt $Version) {
            If (!$LogMeInGoToMeetingV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSDotNetFramework -eq 1) {
        $Product = "Microsoft Dot Net Framework"
        $MSDotNetFrameworkD = Get-EvergreenApp -Name Microsoft.NET | Where-Object {$_.Architecture -eq "$MSDotNetFrameworkArchitectureClear" -and $_.Channel -eq "$MSDotNetFrameworkChannelClear" -and $_.installer -eq "windowsdesktop" }
        $Version = $MSDotNetFrameworkD.Version
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionStrings = ([regex]::Matches($Version, "\." )).count
            $VersionStringTwo = ([regex]::Matches($VersionSplit[2], "." )).count
            If ($VersionStringTwo -lt "2") {
                $VersionSplit[2] = "0" + $VersionSplit[2]
            }
            Switch ($VersionStrings) {
                1 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1]
                }
                2 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2]
                }
                3 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2] + "." + $VersionSplit[3]
                }
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSDotNetFrameworkArchitectureClear" + "_$MSDotNetFrameworkChannelClear" + ".txt"
        $CurrentVersionMSD = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($CurrentVersionMSD) {
            $CurrentSplit = $CurrentVersionMSD.split(".")
            $CurrentStrings = ([regex]::Matches($CurrentVersionMSD, "\." )).count
            $CurrentStringTwo = ([regex]::Matches($CurrentSplit[2], "." )).count
            If ($CurrentStringTwo -lt "2") {
                $CurrentSplit[2] = "0" + $CurrentSplit[2]
            }
            Switch ($CurrentStrings) {
                1 {
                    $CurrentVersionMSD = $CurrentSplit[0] + "." + $CurrentSplit[1]
                }
                2 {
                    $CurrentVersionMSD = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
                3 {
                    $CurrentVersionMSD = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2] + "." + $CurrentSplit[3]
                }
            }
        }
        $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime*" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSDotNetFrameworkV) {
            $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime*" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($MSDotNetFrameworkV) {
            $CurrentSplit = $MSDotNetFrameworkV.split(".")
            $CurrentStrings = ([regex]::Matches($MSDotNetFrameworkV, "\." )).count
            $CurrentStringTwo = ([regex]::Matches($CurrentSplit[2], "." )).count
            If ($CurrentStringTwo -lt "2") {
                $CurrentSplit[2] = "0" + $CurrentSplit[2]
            }
            If ($CurrentStrings -lt "3") {
                $CurrentSplit[3] = ""
            }
            Switch ($CurrentStrings) {
                1 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1]
                }
                2 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
                3 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMSD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMSD"
        Write-Host "Installed Version:  $MSDotNetFrameworkV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSDotNetFrameworkV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMSD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSDotNetFrameworkV -lt $Version) {
            If (!$MSDotNetFrameworkV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MS365Apps -eq 1) {
        $Product = "Microsoft 365 Apps"
        $MS365AppsD = Get-EvergreenApp -Name Microsoft365Apps | Where-Object {$_.Channel -eq "$MS365AppsChannelClearDL"}
        $Version = $MS365AppsD.Version
        $CurrentVersionM365 = Get-Content -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\Version.txt" -EA SilentlyContinue
        $MS365AppsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft 365*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MS365AppsV) {
            $MS365AppsV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft 365*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MS365AppsChannelClear setup file"
        Add-Content -Path "$ReportFile" -Value "$Product $MS365AppsChannelClear setup file"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionM365"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionM365"
        Write-Host "Installed Version:  $MS365AppsV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MS365AppsV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionM365 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MS365AppsV -lt $Version) {
            If (!$MS365AppsV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSAVDRemoteDesktop -eq 1) {
        $Product = "Microsoft AVD Remote Desktop"
        $MSAVDRemoteDesktopD = Get-EvergreenApp -Name MicrosoftWVDRemoteDesktop -WarningAction:SilentlyContinue | Where-Object { $_.Architecture -eq "$MSAVDRemoteDesktopArchitectureClear" -and $_.Channel -eq "$MSAVDRemoteDesktopChannelClear" }
        $Version = $MSAVDRemoteDesktopD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAVDRemoteDesktopChannelClear" + "$MSAVDRemoteDesktopArchitectureClear" + ".txt"
        $CurrentVersionMAVD = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $MSAVDRemoteDesktopV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Remotedesktop"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSAVDRemoteDesktopV) {
            $MSAVDRemoteDesktopV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Remotedesktop"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMAVD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMAVD"
        Write-Host "Installed Version:  $MSAVDRemoteDesktopV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSAVDRemoteDesktopV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMAVD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSAVDRemoteDesktopV -lt $Version) {
            If (!$MSAVDRemoteDesktopV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSAzureCLI -eq 1) {
        $Product = "Microsoft Azure CLI"
        $MSAzureCLID = Get-NevergreenApp -Name MicrosoftAzureCLI | Where-Object { $_.Type -eq "Msi" }
        $Version = $MSAzureCLID.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionMA = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSAzureCLIV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Azure CLI"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSAzureCLIV) {
            $MSAzureCLIV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Azure CLI"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMA"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMA"
        Write-Host "Installed Version:  $MSAzureCLIV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSAzureCLIV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMA -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSAzureCLIV -lt $Version) {
            If (!$MSAzureCLIV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSAzureDataStudio -eq 1) {
        $Product = "Microsoft Azure Data Studio"
        $MSAzureDataStudioD = Get-EvergreenApp -Name microsoftazuredatastudio | Where-Object { $_.Channel -eq "$MSAzureDataStudioChannelClear" -and $_.Platform -eq "$MSAzureDataStudioPlatformClear"}
        $Version = $MSAzureDataStudioD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear" + ".txt"
        $CurrentVersionMAD = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSAzureDataStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSAzureDataStudioV) {
            $MSAzureDataStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSAzureDataStudioV) {
            $MSAzureDataStudioV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMAD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMAD"
        Write-Host "Installed Version:  $MSAzureDataStudioV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSAzureDataStudioV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMAD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSAzureDataStudioV -lt $Version) {
            If (!$MSAzureDataStudioV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSEdge -eq 1) {
        $Product = "Microsoft Edge"
        $EdgeD = Get-EvergreenApp -Name MicrosoftEdge | Where-Object { $_.Platform -eq "Windows" -and $_.Release -eq "Consumer" -and $_.Channel -eq "$MSEdgeChannelClear" -and $_.Architecture -eq "$MSEdgeArchitectureClear" }
        $Version = $EdgeD.Version
        $EdgeSplit = $Version.split(".")
        $EdgeStrings = ([regex]::Matches($Version, "\." )).count
        $EdgeStringLast = ([regex]::Matches($EdgeSplit[$EdgeStrings], "." )).count
        $EdgeStringFirst = ([regex]::Matches($EdgeSplit[0], "." )).count
        If ($EdgeStringLast -lt "3") {
            $EdgeSplit[$EdgeStrings] = "0" + $EdgeSplit[$EdgeStrings]
        }
        If ($EdgeStringFirst -lt "3") {
            $EdgeSplit[0] = "0" + $EdgeSplit[0]
        }
        Switch ($EdgeStrings) {
            1 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1]
            }
            2 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1] + "." + $EdgeSplit[2]
            }
            3 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1] + "." + $EdgeSplit[2] + "." + $EdgeSplit[3]
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeArchitectureClear" + "_$MSEdgeChannelClear" + ".txt"
        $CurrentVersionME = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersionME) {
            $CurrentEdgeSplit = $CurrentVersionME.split(".")
            $CurrentEdgeStrings = ([regex]::Matches($CurrentVersionME, "\." )).count
            $CurrentEdgeStringLast = ([regex]::Matches($CurrentEdgeSplit[$CurrentEdgeStrings], "." )).count
            $CurrentEdgeStringFirst = ([regex]::Matches($CurrentEdgeSplit[0], "." )).count
            If ($CurrentEdgeStringLast -lt "3") {
                $CurrentEdgeSplit[$CurrentEdgeStrings] = "0" + $CurrentEdgeSplit[$CurrentEdgeStrings]
            }
            If ($CurrentEdgeStringFirst -lt "3") {
                $CurrentEdgeSplit[0] = "0" + $CurrentEdgeSplit[0]
            }
            Switch ($CurrentEdgeStrings) {
                1 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1] + "." + $CurrentEdgeSplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1] + "." + $CurrentEdgeSplit[2] + "." + $CurrentEdgeSplit[3]
                }
            }
        }
        If ($MSEdgeChannelClear -eq "Stable") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($MSEdgeChannelClear -eq "Dev") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($MSEdgeChannelClear -eq "Beta") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($Edge) {
            $CurrentEdgeSplit1 = $Edge.split(".")
            $CurrentEdgeStrings1 = ([regex]::Matches($Edge, "\." )).count
            $CurrentEdgeStringLast1 = ([regex]::Matches($CurrentEdgeSplit1[$CurrentEdgeStrings1], "." )).count
            $CurrentEdgeStringFirst1 = ([regex]::Matches($CurrentEdgeSplit1[0], "." )).count
            If ($CurrentEdgeStringLast1 -lt "3") {
                $CurrentEdgeSplit1[$CurrentEdgeStrings1] = "0" + $CurrentEdgeSplit1[$CurrentEdgeStrings1]
            }
            If ($CurrentEdgeStringFirst1 -lt "3") {
                $CurrentEdgeSplit1[0] = "0" + $CurrentEdgeSplit1[0]
            }
            Switch ($CurrentEdgeStrings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1] + "." + $CurrentEdgeSplit1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1] + "." + $CurrentEdgeSplit1[2] + "." + $CurrentEdgeSplit1[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($NewCurrentVersion1 -lt $NewVersion) {
            If (!$NewCurrentVersion1) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSEdgeWebView2 -eq 1) {
        $Product = "Microsoft Edge WebView2"
        $EdgeWebView2D = Get-EvergreenApp -Name MicrosoftEdgeWebView2Runtime | Where-Object { $_.Architecture -eq "$MSEdgeWebView2ArchitectureClear" }
        $Version = $EdgeWebView2D.Version
        $EdgeWebView2Split = $Version.split(".")
        $EdgeWebView2Strings = ([regex]::Matches($Version, "\." )).count
        $EdgeWebView2StringLast = ([regex]::Matches($EdgeWebView2Split[$EdgeWebView2Strings], "." )).count
        If ($EdgeWebView2StringLast -lt "3") {
            $EdgeWebView2Split[$EdgeWebView2Strings] = "0" + $EdgeWebView2Split[$EdgeWebView2Strings]
        }
        Switch ($EdgeWebView2Strings) {
            1 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1]
            }
            2 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1] + "." + $EdgeWebView2Split[2]
            }
            3 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1] + "." + $EdgeWebView2Split[2] + "." + $EdgeWebView2Split[3]
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeWebView2ArchitectureClear" + ".txt"
        $CurrentVersionMEW = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersionMEW) {
            $CurrentEdgeWebView2Split = $CurrentVersionMEW.split(".")
            $CurrentEdgeWebView2Strings = ([regex]::Matches($CurrentVersionMEW, "\." )).count
            $CurrentEdgeWebView2StringLast = ([regex]::Matches($CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings], "." )).count
            $CurrentEdgeWebView2StringFirst = ([regex]::Matches($CurrentEdgeWebView2Split[0], "." )).count
            If ($CurrentEdgeWebView2StringLast -lt "3") {
                $CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings] = "0" + $CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings]
            }
            If ($CurrentEdgeWebView2StringFirst -lt "3") {
                $CurrentEdgeWebView2Split[0] = "0" + $CurrentEdgeWebView2Split[0]
            }
            Switch ($CurrentEdgeWebView2Strings) {
                1 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1] + "." + $CurrentEdgeWebView2Split[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1] + "." + $CurrentEdgeWebView2Split[2] + "." + $CurrentEdgeWebView2Split[3]
                }
            }
        }
        $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$EdgeWebView2) {
            $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($EdgeWebView2) {
            $CurrentEdgeWebView2Split1 = $EdgeWebView2.split(".")
            $CurrentEdgeWebView2Strings1 = ([regex]::Matches($EdgeWebView2, "\." )).count
            $CurrentEdgeWebView2StringLast1 = ([regex]::Matches($CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1], "." )).count
            $CurrentEdgeWebView2StringFirst1 = ([regex]::Matches($CurrentEdgeWebView2Split1[0], "." )).count
            If ($CurrentEdgeWebView2StringLast1 -lt "3") {
                $CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1] = "0" + $CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1]
            }
            If ($CurrentEdgeWebView2StringFirst1 -lt "3") {
                $CurrentEdgeWebView2Split1[0] = "0" + $CurrentEdgeWebView2Split1[0]
            }
            Switch ($CurrentEdgeWebView2Strings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1] + "." + $CurrentEdgeWebView2Split1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1] + "." + $CurrentEdgeWebView2Split1[2] + "." + $CurrentEdgeWebView2Split1[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $MSEdgeWebView2ArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSEdgeWebView2ArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $NewCurrentVersion1"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($NewCurrentVersion1 -lt $NewVersion) {
            If (!$NewCurrentVersion1) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSFSLogix -eq 1) {
        $Product = "Microsoft FSLogix"
        If ($MSFSLogixChannelClear -eq "Stable") {
            $MSFSLogixD = Get-MSFSLogix
        } else {
            $MSFSLogixD = Get-EvergreenApp -Name MicrosoftFSLogixApps -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Channel -eq "$MSFSLogixChannelClear"}
            If (!($MSFSLogixD.uri)) {
                $MSFSLogixD = Get-EvergreenApp -Name MicrosoftFSLogixApps -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Channel -eq "Production"}
            }
        }
        $Version = $MSFSLogixD.Version
        $VersionPath = "$PSScriptRoot\$Product\$MSFSLogixChannelClear\Version_"+ "$MSFSLogixChannelClear" + ".txt"
        $CurrentVersionMF = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSFSLogixV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSFSLogixV) {
            $MSFSLogixV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMF"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMF"
        Write-Host "Installed Version:  $MSFSLogixV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSFSLogixV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMF -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSFSLogixV -lt $Version) {
            If (!$MSFSLogixV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSOffice -eq 1) {
        $Product = "Microsoft Office " + $MSOfficeChannelClear
        $MSOfficeD = Get-EvergreenApp -Name Microsoft365Apps | Where-Object {$_.Channel -eq "$MSOfficeVersionClear"}
        $Version = $MSOfficeD.Version
        $CurrentVersionMO = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $MSOfficeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Office*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSOfficeV) {
            $MSOfficeV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Office*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMO"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMO"
        Write-Host "Installed Version:  $MSOfficeV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSOfficeV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMO -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSOfficeV -lt $Version) {
            If (!$MSOfficeV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSOneDrive -eq 1) {
        $Product = "Microsoft OneDrive"
        $MSOneDriveD = Get-EvergreenApp -Name MicrosoftOneDrive | Where-Object { $_.Ring -eq "$MSOneDriveRingClear" -and $_.Type -eq "Exe" -and $_.Architecture -eq "$MSOneDriveArchitectureClear"} | Sort-Object -Property Version -Descending | Select-Object -Last 1
        $Version = $MSOneDriveD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear" + ".txt"
        $CurrentVersionMOD = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSOneDriveV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSOneDriveV) {
            $MSOneDriveV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSOneDriveV) {
            $MSOneDriveV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMOD"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMOD"
        Write-Host "Installed Version:  $MSOneDriveV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSOneDriveV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMOD -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSOneDriveV -lt $Version) {
            If (!$MSOneDriveV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSPowerBIDesktop -eq 1) {
        $Product = "Microsoft Power BI Desktop"
        $MSPowerBIDesktopD = Get-NevergreenApp -Name MicrosoftPowerBIDesktop | Where-Object { $_.Architecture -eq "$MSPowerBIDesktopArchitectureClear"}
        $Version = $MSPowerBIDesktopD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerBIDesktopArchitectureClear" + ".txt"
        $CurrentVersionMP = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CurrentPowerSplit = $CurrentVersionMP.split(".")
        $CurrentPowerStrings = ([regex]::Matches($CurrentVersionMP, "\." )).count
        $CurrentPowerStringSecond = ([regex]::Matches($CurrentPowerSplit[1], "." )).count
        $CurrentPowerStringThird = ([regex]::Matches($CurrentPowerSplit[2], "." )).count
        Switch ($CurrentPowerStringSecond) {
            2 {
                $CurrentPowerSplit[1] = "0" + $CurrentPowerSplit[1]
            }
        }
        Switch ($CurrentPowerStringThird) {
            3 {
                $CurrentPowerSplit[2] = "0" + $CurrentPowerSplit[2]
            }
        }
        Switch ($CurrentPowerStrings) {
            1 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1]
            }
            2 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1] + "." + $CurrentPowerSplit[2]
            }
            3 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1] + "." + $CurrentPowerSplit[2] + "." + $CurrentPowerSplit[3]
            }
        }
        $PowerSplit = $Version.split(".")
        $PowerStrings = ([regex]::Matches($Version, "\." )).count
        $PowerStringSecond = ([regex]::Matches($PowerSplit[1], "." )).count
        $PowerStringThird = ([regex]::Matches($PowerSplit[2], "." )).count
        Switch ($PowerStringSecond) {
            2 {
                $PowerSplit[1] = "0" + $PowerSplit[1]
            }
        }
        Switch ($PowerStringThird) {
            3 {
                $PowerSplit[2] = "0" + $PowerSplit[2]
            }
        }
        Switch ($PowerStrings) {
            1 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1]
            }
            2 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1] + "." + $PowerSplit[2]
            }
            3 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1] + "." + $PowerSplit[2] + "." + $PowerSplit[3]
            }
        }
        $MSPowerBIDesktopV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft PowerBI Desktop*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerBIDesktopV) {
            $MSPowerBIDesktopV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft PowerBI Desktop*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSPBISplit = $MSPowerBIDesktopV.split(".")
        $MSPBIString = ([regex]::Matches($MSPBISplit[2], "." )).count
        If ($MSPBIString -lt "4") {
            $MSPBISplit[2] = "0" + $MSPBISplit[2]
        }
        Switch ($MSPBIString) {
            1 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1]
            }
            2 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1] + "." + $MSPBISplit[2]
            }
            3 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1] + "." + $MSPBISplit[2] + "." + $MSPBISplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $MSPowerBIDesktopArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSPowerBIDesktopArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $MSPowerBIDesktopV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSPowerBIDesktopV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSPowerBIDesktopV -lt $NewVersion) {
            If (!$MSPowerBIDesktopV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSPowerBIReportBuilder -eq 1) {
        $Product = "Microsoft Power BI Report Builder"
        $MSPowerBIReportBuilderD = Get-NevergreenApp -Name MicrosoftPowerBIReportBuilder
        $Version = $MSPowerBIReportBuilderD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionMPR = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CurrentPowerBISplit = $CurrentVersionMPR.split(".")
        $CurrentPowerBIStrings = ([regex]::Matches($CurrentVersionMPR, "\." )).count
        $CurrentPowerBIStringSecond = ([regex]::Matches($CurrentPowerBISplit[2], "." )).count
        Switch ($CurrentPowerBIStringSecond) {
            4 {
                $CurrentPowerBISplit[2] = "0" + $CurrentPowerBISplit[2]
            }
        }
        Switch ($CurrentPowerBIStrings) {
            1 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1]
            }
            2 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1] + "." + $CurrentPowerBISplit[2]
            }
            3 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1] + "." + $CurrentPowerBISplit[2] + "." + $CurrentPowerBISplit[3]
            }
        }
        $PowerBISplit = $Version.split(".")
        $PowerBIStrings = ([regex]::Matches($Version, "\." )).count
        $PowerBIStringSecond = ([regex]::Matches($PowerBISplit[2], "." )).count
        Switch ($PowerBIStringSecond) {
            4 {
                $PowerBISplit[2] = "0" + $PowerBISplit[2]
            }
        }
        Switch ($PowerBIStrings) {
            1 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1]
            }
            2 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1] + "." + $PowerBISplit[2]
            }
            3 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1] + "." + $PowerBISplit[2] + "." + $PowerBISplit[3]
            }
        }
        $MSPowerBIReportBuilderV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Power BI Report Builder*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerBIReportBuilderV) {
            $MSPowerBIReportBuilderV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Power BI Report Builder*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $MSPowerBIReportBuilderV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSPowerBIReportBuilderV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSPowerBIReportBuilderV -lt $NewVersion) {
            If (!$MSPowerBIReportBuilderV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSPowerShell -eq 1) {
        $Product = "Microsoft PowerShell"
        $MSPowershellD = Get-EvergreenApp -Name MicrosoftPowerShell -WarningAction SilentlyContinue | Where-Object {$_.Architecture -eq "$MSPowerShellArchitectureClear" -and $_.Release -eq "$MSPowerShellReleaseClear"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!($MSPowershellD)) {
            $MSPowershellD = Get-EvergreenApp -Name MicrosoftPowerShell -WarningAction SilentlyContinue | Where-Object {$_.Architecture -eq "$MSPowerShellArchitectureClear" -and $_.Release -eq "Stable"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $Version = $MSPowershellD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerShellArchitectureClear" + "_$MSPowerShellReleaseClear" + ".txt"
        $CurrentVersionMPS = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $MSOneDriveV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $MSPowerShellV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerShell*" -and $_.Publisher -like "Microsoft Corporation"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerShellV) {
            $MSPowerShellV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerShell*" -and $_.Publisher -like "Microsoft Corporation"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($MSPowerShellV) {$MSPowerShellV = $MSPowerShellV -replace ".{2}$"}
        Write-Host -ForegroundColor Magenta "$Product $MSPowerShellReleaseClear Release $MSPowerShellArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSPowerShellReleaseClear Release $MSPowerShellArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMPS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMPS"
        Write-Host "Installed Version:  $MSPowerShellV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSPowerShellV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMPS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSPowerShellV -lt $Version) {
            If (!$MSPowerShellV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSPowerToys -eq 1) {
        $Product = "Microsoft PowerToys"
        $MSPowerToysD = Get-EvergreenApp -Name MicrosoftPowerToys| Where-Object {$_.Architecture -eq "x64"}
        $Version = $MSPowerToysD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
        $CurrentVersionMPT = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSPowerToysV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerToys*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerToysV) {
            $MSPowerToysV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerToys*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMPT"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMPT"
        Write-Host "Installed Version:  $MSPowerToysV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSPowerToysV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMPT -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSPowerToysV -lt $Version) {
            If (!$MSPowerToysV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSSQLServerManagementStudio -eq 1) {
        $Product = "Microsoft SQL Server Management Studio"
        $MSSQLServerManagementStudioD = Get-EvergreenApp -Name MicrosoftSsms -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Language -eq "$MSSQLServerManagementStudioLanguageClear" }
        $Version = $MSSQLServerManagementStudioD.Version
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionSplit2 = $VersionSplit[2].Substring(0,3)
            $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit2
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSSQLServerManagementStudioLanguageClear" + ".txt"
        $CurrentVersionMSQL = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($CurrentVersionMSQL) {
            $VersionSplit = $CurrentVersionMSQL.split(".")
            $VersionSplit2 = $VersionSplit[2].Substring(0,3)
            $CurrentVersionMSQL = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit2
        }
        $MSSQLServerManagementStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*SQL Server Management Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSSQLServerManagementStudioV) {
            $MSSQLServerManagementStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*SQL Server Management Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($MSSQLServerManagementStudioV) {
            $MSSQLServerManagementStudioVSplit = $MSSQLServerManagementStudioV.split(".")
            $MSSQLServerManagementStudioVSplit2 = $MSSQLServerManagementStudioVSplit[2].Substring(0,3)
            $MSSQLServerManagementStudioV = $MSSQLServerManagementStudioVSplit[0] + "." + $MSSQLServerManagementStudioVSplit[1] + "." + $MSSQLServerManagementStudioVSplit2
        }
        Write-Host -ForegroundColor Magenta "$Product $MSSQLServerManagementStudioLanguageClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSSQLServerManagementStudioLanguageClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMSQL"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMSQL"
        Write-Host "Installed Version:  $MSSQLServerManagementStudioV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSSQLServerManagementStudioV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMSQL -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSSQLServerManagementStudioV -lt $Version) {
            If (!$MSSQLServerManagementStudioV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSSysinternals -eq 1) {
        $Product = "Microsoft Sysinternals"
        $MSSysinternalsD = Get-NevergreenApp -Name MicrosoftSysinternals | Where-Object { $_.Type -eq "Zip" -and $_.Architecture -eq "Multi" -and $_.Name -eq "Microsoft Sysinternals Suite" }
        $Version = $MSSysinternalsD.Version
        If ($Version) {
            $CurrentWSASplit = $Version.split(".")
            $CurrentWSAStrings = ([regex]::Matches($Version, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $CurrentVersionMSI = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        If ($CurrentVersionMSI) {
            $CurrentWSASplit = $CurrentVersionMSI.split(".")
            $CurrentWSAStrings = ([regex]::Matches($CurrentVersionMSI, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $CurrentVersionMSI = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $CurrentVersionMSI = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $CurrentVersionMSI = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMSI"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMSI"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMSI -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

If ($MSTeams -eq 1) {
        If ($MSTeamsInstallerClear -eq 'Machine Based') {
            $Product = "Microsoft Teams Machine Based"
            If ($MSTeamsRingClear -eq 'Continuous Deployment' -or $MSTeamsRingClear -eq 'Exploration') {
                $TeamsD = Get-NevergreenApp -Name MicrosoftTeams | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and $_.Ring -eq "Preview" -and $_.Type -eq "MSI"}
            }
            Else {
                $TeamsD = Get-EvergreenApp -Name MicrosoftTeams | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and $_.Ring -eq "$MSTeamsRingClear" -and $_.Type -eq "MSI"}
            }
            $Version = $TeamsD.Version
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $NewVersion = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $CurrentVersionMT = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            If ($CurrentVersionMT) {
                $CurrentTeamsSplit = $CurrentVersionMT.split(".")
                $CurrentTeamsStrings = ([regex]::Matches($CurrentVersionMT, "\." )).count
                $CurrentTeamsStringLast = ([regex]::Matches($CurrentTeamsSplit[$CurrentTeamsStrings], "." )).count
                If ($CurrentTeamsStringLast -lt "5") {
                    $CurrentTeamsSplit[$CurrentTeamsStrings] = "0" + $CurrentTeamsSplit[$CurrentTeamsStrings]
                }
                $NewCurrentVersion = $CurrentTeamsSplit[0] + "." + $CurrentTeamsSplit[1] + "." + $CurrentTeamsSplit[2] + "." + $CurrentTeamsSplit[3]
            }
            If (Test-Path -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                $Teams = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If (!$Teams) {
                If (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                    $Teams = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            If ($Teams) {$Teams = $Teams.Insert(5,'0')}
        }
        If ($MSTeamsInstallerClear -eq 'User Based') {
            $Product = "Microsoft Teams User Based"
            $TeamsD = Get-MicrosoftTeamsUser | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and $_.Ring -eq "$MSTeamsRingClear"}
            $NewVersion = $TeamsD.Version
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $NewCurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            If (Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                $Teams = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If (!$Teams) {
                If (Test-Path -Path "HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                    $Teams = (Get-ItemProperty HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
        }
        Write-Host -ForegroundColor Magenta "$Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $NewVersion"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $NewVersion"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $Teams"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $Teams"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($Teams -lt $Version) {
            If (!$Teams) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSVisualCPlusPlusRuntime -eq 1) {
        $Product = "Microsoft Visual C++ Runtime"
        If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
            $MSVisualCPlusPlusRuntimeArchitectureClear = "x64"
            $MSVisualCPlusPlusRuntimeArchitecture2Clear = "x86"
        }
        If ($MSVisualCPlusPlusRuntimeRelease -ne 3) {
			$MSVisualCPlusPlusRuntimeD = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "$MSVisualCPlusPlusRuntimeReleaseClear"}
			$Version = $MSVisualCPlusPlusRuntimeD.Version
			$VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
			$CurrentVersionMV = Get-Content -Path "$VersionPath" -EA SilentlyContinue
			$MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
			If (!$MSVisualCPlusPlusRuntimeV) {
				$MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
			}
			If (!$MSVisualCPlusPlusRuntimeV) {
				$MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
			}
			If (!$MSVisualCPlusPlusRuntimeV) {
				$MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
			}
			Write-Host -ForegroundColor Magenta "$Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear"
			Add-Content -Path "$ReportFile" -Value "$Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear"
			Add-Content -Path "$ReportFile" -Value ""
			Write-Host "Internet Version:   $Version"
			Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
			Write-Host "Downloaded Version: $CurrentVersionMV"
			Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMV"
			Write-Host "Installed Version:  $MSVisualCPlusPlusRuntimeV"
			Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntimeV"
			Add-Content -Path "$ReportFile" -Value ""
			If ($CurrentVersionMV -lt $Version) {
				Write-Host -ForegroundColor Yellow "New version available in the internet"
				Add-Content -Path "$ReportFile" -Value "New version available in the internet"
				Write-Output ""
				Add-Content -Path "$ReportFile" -Value ""
			} Else {
				Write-Host -ForegroundColor Green "No new version available in the internet"
				Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
				Write-Output ""
				Add-Content -Path "$ReportFile" -Value ""
			}
			If ($MSVisualCPlusPlusRuntimeV -lt $Version) {
				If (!$MSVisualCPlusPlusRuntimeV) {
					Write-Host -ForegroundColor Cyan "No installed version found"
					Add-Content -Path "$ReportFile" -Value "No installed version found"
					Write-Output ""
					Add-Content -Path "$ReportFile" -Value ""
				} Else {
					Write-Host -ForegroundColor Yellow "Update available for installed version"
					Add-Content -Path "$ReportFile" -Value "Update available for installed version"
					Write-Output ""
					Add-Content -Path "$ReportFile" -Value ""
				}
			} Else {
				Write-Host -ForegroundColor Green "No update available for installed version"
				Add-Content -Path "$ReportFile" -Value "No update available for installed version"
				Write-Output ""
				Add-Content -Path "$ReportFile" -Value ""
			}
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $MSVisualCPlusPlusRuntimeD = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "$MSVisualCPlusPlusRuntimeReleaseClear"}
                $Version = $MSVisualCPlusPlusRuntimeD.Version
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersionMV = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                }
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
                }
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
                }
				Write-Host -ForegroundColor Magenta "$Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear"
				Add-Content -Path "$ReportFile" -Value "$Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear"
				Add-Content -Path "$ReportFile" -Value ""
				Write-Host "Internet Version:   $Version"
				Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
				Write-Host "Downloaded Version: $CurrentVersionMV"
				Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMV"
				Write-Host "Installed Version:  $MSVisualCPlusPlusRuntimeV"
				Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntimeV"
				Add-Content -Path "$ReportFile" -Value ""
				If ($CurrentVersionMV -lt $Version) {
					Write-Host -ForegroundColor Yellow "New version available in the internet"
					Add-Content -Path "$ReportFile" -Value "New version available in the internet"
					Write-Output ""
					Add-Content -Path "$ReportFile" -Value ""
				} Else {
					Write-Host -ForegroundColor Green "No new version available in the internet"
					Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
					Write-Output ""
					Add-Content -Path "$ReportFile" -Value ""
				}
				If ($MSVisualCPlusPlusRuntimeV -lt $Version) {
					If (!$MSVisualCPlusPlusRuntimeV) {
						Write-Host -ForegroundColor Cyan "No installed version found"
						Add-Content -Path "$ReportFile" -Value "No installed version found"
						Write-Output ""
						Add-Content -Path "$ReportFile" -Value ""
					} Else {
						Write-Host -ForegroundColor Yellow "Update available for installed version"
						Add-Content -Path "$ReportFile" -Value "Update available for installed version"
						Write-Output ""
						Add-Content -Path "$ReportFile" -Value ""
					}
				} Else {
					Write-Host -ForegroundColor Green "No update available for installed version"
					Add-Content -Path "$ReportFile" -Value "No update available for installed version"
					Write-Output ""
					Add-Content -Path "$ReportFile" -Value ""
				}
			}
        } Else {
            $MSVisualCPlusPlusRuntime2022D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2022"}
            $MSVisualCPlusPlusRuntime2012D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2012"}
            $MSVisualCPlusPlusRuntime2013D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2013"}
            $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
            $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
            $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
            $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2022 = Get-Content -Path "$VersionPath2022" -EA SilentlyContinue
            $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2012 = Get-Content -Path "$VersionPath2012" -EA SilentlyContinue
            $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2013 = Get-Content -Path "$VersionPath2013" -EA SilentlyContinue
            $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2012V) {
                $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2013V) {
                $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2022V) {
                $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            Write-Host -ForegroundColor Magenta "$Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version2012"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2012"
            Write-Host "Downloaded Version: $CurrentVersion2012"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2012"
            Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2012V"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2012V"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion2012 -lt $Version2012) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($MSVisualCPlusPlusRuntime2012V -lt $Version2012) {
                If (!$MSVisualCPlusPlusRuntime2012V) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            Write-Host -ForegroundColor Magenta "$Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version2013"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2013"
            Write-Host "Downloaded Version: $CurrentVersion2013"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2013"
            Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2013V"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2013V"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion2013 -lt $Version2013) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($MSVisualCPlusPlusRuntime2013V -lt $Version2013) {
                If (!$MSVisualCPlusPlusRuntime2013V) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            Write-Host -ForegroundColor Magenta "$Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value "$Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version2022"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2022"
            Write-Host "Downloaded Version: $CurrentVersion2022"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2022"
            Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2022V"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2022V"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersion2022 -lt $Version2022) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($MSVisualCPlusPlusRuntime2022V -lt $Version2022) {
                If (!$MSVisualCPlusPlusRuntime2022V) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $MSVisualCPlusPlusRuntime2022D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2022"}
                $MSVisualCPlusPlusRuntime2012D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2012"}
                $MSVisualCPlusPlusRuntime2013D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2013"}
                $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
                $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
                $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
                $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2022 = Get-Content -Path "$VersionPath2022" -EA SilentlyContinue
                $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2012 = Get-Content -Path "$VersionPath2012" -EA SilentlyContinue
                $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2013 = Get-Content -Path "$VersionPath2013" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "$Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value "$Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version2012"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2012"
                Write-Host "Downloaded Version: $CurrentVersion2012"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2012"
                Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2012V"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2012V"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersion2012 -lt $Version2012) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($MSVisualCPlusPlusRuntime2012V -lt $Version2012) {
                    If (!$MSVisualCPlusPlusRuntime2012V) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                Write-Host -ForegroundColor Magenta "$Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value "$Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version2013"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2013"
                Write-Host "Downloaded Version: $CurrentVersion2013"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2013"
                Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2013V"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2013V"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersion2013 -lt $Version2013) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($MSVisualCPlusPlusRuntime2013V -lt $Version2013) {
                    If (!$MSVisualCPlusPlusRuntime2013V) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                Write-Host -ForegroundColor Magenta "$Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value "$Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version2022"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version2022"
                Write-Host "Downloaded Version: $CurrentVersion2022"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersion2022"
                Write-Host "Installed Version:  $MSVisualCPlusPlusRuntime2022V"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualCPlusPlusRuntime2022V"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersion2022 -lt $Version2022) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($MSVisualCPlusPlusRuntime2022V -lt $Version2022) {
                    If (!$MSVisualCPlusPlusRuntime2022V) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
        }
    }

    If ($MSVisualStudio -eq 1) {
        $Product = "Microsoft Visual Studio 2019"
        $MSVisualStudioD = Get-EvergreenApp -Name MicrosoftVisualStudio
        $Version = $MSVisualStudioD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
        $CurrentVersionMVS = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSVisualStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio $MSVisualStudioEditionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSVisualStudioV) {
            $MSVisualStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio $MSVisualStudioEditionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSVisualStudioEditionClear edition"
        Add-Content -Path "$ReportFile" -Value "$Product $MSVisualStudioEditionClear edition"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMVS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMVS"
        Write-Host "Installed Version:  $MSVisualStudioV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualStudioV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMVS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSVisualStudioV -lt $Version) {
            If (!$MSVisualStudioV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MSVisualStudioCode -eq 1) {
        $Product = "Microsoft Visual Studio Code"
        $MSVisualStudioCodeD = Get-EvergreenApp -Name MicrosoftVisualStudioCode | Where-Object { $_.Architecture -eq "$MSVisualStudioCodeArchitectureClear" -and $_.Channel -eq "$MSVisualStudioCodeChannelClear" -and $_.Platform -eq "$MSVisualStudioCodePlatformClear"}
        $Version = $MSVisualStudioCodeD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear" + ".txt"
        $CurrentVersionMVSC = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MSVisualStudioCodeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSVisualStudioCodeV) {
            $MSVisualStudioCodeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSVisualStudioCodeV) {
            $MSVisualStudioCodeV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMVSC"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMVSC"
        Write-Host "Installed Version:  $MSVisualStudioCodeV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MSVisualStudioCodeV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMVSC -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MSVisualStudioCodeV -lt $Version) {
            If (!$MSVisualStudioCodeV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MindView7 -eq 1) {
        $Product = "MindView"
        $MindView7D = Get-MindView | Where-Object { $_.Language -eq "$MindView7LanguageClear"}
        $Version = $MindView7D.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MindView7LanguageClear" + ".txt"
        $CurrentVersionMV7 = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MindView7V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*MindView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MindView7V) {
            $MindView7V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*MindView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MindView7LanguageClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MindView7LanguageClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionMV7"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionMV7"
        Write-Host "Installed Version:  $MindView7V"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MindView7V"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionMV7 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MindView7V -lt $Version) {
            If (!$MindView7V) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Firefox -eq 1) {
        $Product = "Mozilla Firefox"
        $FirefoxD = Get-EvergreenApp -Name MozillaFirefox -AppParams @{Language="$FFLanguageClear"} -WarningAction silentlyContinue -ErrorAction SilentlyContinue | Where-Object { $_.Type -eq "msi" -and $_.Architecture -eq "$FirefoxArchitectureClear" -and $_.Channel -like "*$FirefoxChannelClear*"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $FirefoxD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FirefoxChannelClear" + "$FirefoxArchitectureClear" + "$FFLanguageClear" + ".txt"
        $CurrentVersionFF = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $FirefoxSplit = $CurrentVersionFF.split(".")
        $FirefoxStrings = ([regex]::Matches($CurrentVersionFF, "\." )).count
        $FirefoxStringFirst = ([regex]::Matches($FirefoxSplit[0], "." )).count
        If ($FirefoxStringFirst -lt "3") {
            $FirefoxSplit[0] = "0" + $FirefoxSplit[0]
        }
        Switch ($FirefoxStrings) {
            1 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1]
            }
            2 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1] + "." + $FirefoxSplit[2]
            }
            3 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1] + "." + $FirefoxSplit[2] + "." + $FirefoxSplit[3]
            }
        }
        $FirefoxV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Firefox*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FirefoxV) {
            $FirefoxV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Firefox*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $NewCurrentVersion"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $NewCurrentVersion"
        Write-Host "Installed Version:  $FirefoxV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $FirefoxV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($NewCurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($FirefoxV -lt $Version) {
            If (!$FirefoxV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($MozillaThunderbird -eq 1) {
        $Product = "Mozilla Thunderbird"
        $ThunderbirdD = Get-EvergreenApp -Name MozillaThunderbird -AppParams @{Language="$MozillaThunderbirdLanguageClear"} -WarningAction silentlyContinue -ErrorAction SilentlyContinue | Where-Object { $_.Type -eq "msi" -and $_.Architecture -eq "$MozillaThunderbirdArchitectureClear"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $ThunderbirdD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MozillaThunderbirdArchitectureClear" + "_$MozillaThunderbirdLanguageClear" + ".txt"
        $CurrentVersionTh = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $MozillaThunderbirdV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Thunderbird*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MozillaThunderbirdV) {
            $MozillaThunderbirdV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Thunderbird*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionTh"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTh"
        Write-Host "Installed Version:  $MozillaThunderbirdV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $MozillaThunderbirdV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionTh -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($MozillaThunderbirdV -lt $Version) {
            If (!$MozillaThunderbirdV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($mRemoteNG -eq 1) {
        $Product = "mRemoteNG"
        $mRemoteNGD = Get-EvergreenApp -Name mRemoteNG | Where-Object { $_.Type -eq "msi" }
        $Version = $mRemoteNGD.Version
        $CurrentVersionmrng = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $mRemoteNGV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "mRemoteNG"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$mRemoteNGV) {
            $mRemoteNGV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "mRemoteNG"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($mRemoteNGV) {$mRemoteNGV = $mRemoteNGV -replace ".{6}$"}
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionmrng"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionmrng"
        Write-Host "Installed Version:  $mRemoteNGV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $mRemoteNGV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionmrng -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($mRemoteNGV -lt $Version) {
            If (!$mRemoteNGV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Nmap -eq 1) {
        $Product = "Nmap"
        $NMapD = Get-NevergreenApp -Name NMap | Where-Object { $_.Architecture -eq "x86" -and $_.Type -eq "exe" }
        $Version = $NMapD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionnm = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NmapV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Nmap*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$NmapV) {
            $NmapV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Nmap*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionnm"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionnm"
        Write-Host "Installed Version:  $NmapV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $NmapV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionnm -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($NmapV -lt $Version) {
            If (!$NmapV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($NotePadPlusPlus -eq 1) {
        $Product = "NotepadPlusPlus"
        $NotepadD = Get-EvergreenApp -Name NotepadPlusPlus | Where-Object { $_.Architecture -eq "$NotepadPlusPlusArchitectureClear" -and $_.Type -eq "exe" }
        $Version = $NotepadD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$NotepadPlusPlusArchitectureClear" + ".txt"
        $CurrentVersionN = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $Notepad = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Notepad++*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Notepad) {
            $Notepad = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Notepad++*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $NotepadPlusPlusArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $NotepadPlusPlusArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionN"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionN"
        Write-Host "Installed Version:  $Notepad"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $Notepad"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionN -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($Notepad -lt $Version) {
            If (!$Notepad) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($OpenJDK -eq 1) {
        $Product = "OpenJDK"
        If ($openJDK_Architecture -eq 3) {
            $openJDKArchitectureClear = "x64"
            $openJDKArchitecture2Clear = "x86"
        }
        If ($OpenJDKPackageClear -eq "8") {
            $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitectureClear" -and $_.Type -eq "msi" -and $_.Version -like "1.8*" -and $_.URI -notlike "*-jre-*"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        } Else {
            $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitectureClear" -and $_.Type -eq "msi" -and $_.Version -like "$OpenJDKPackageClear*" -and $_.URI -notlike "*-jre-*" -and $_.URI -notlike "*.jre.*"} | Sort-Object -Property Size -Descending | Select-Object -First 4 | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $Version = $OpenJDKD.Version
        If ($openJDKArchitectureClear -eq "x86") {
            $x86Version = $Version.split("-x")
            $Version = $x86Version[0] + $x86Version[1]
        }
        If ($Version) {$Version = $Version -replace('-','.')}
        If ($Version) {$Version = $Version -replace('b0','')}
        If ($Version) {$Version = $Version -replace('8.0','8')}
        If ($OpenJDKPackageClear -eq "11") {
            $OpenJDKSplit = $Version.split(".")
            $OpenJDKStrings = ([regex]::Matches($Version, "\." )).count
            $OpenJDKStringsNotLast = $OpenJDKStrings
            $OpenJDKStringsNotLast --
            $OpenJDKStringPenultimate = ([regex]::Matches($OpenJDKSplit[$OpenJDKStringsNotLast], "." )).count
            Switch ($OpenJDKStrings) {
                1 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                4 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[4]
                }
            }
        }
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$openJDKArchitectureClear" + "_$OpenJDKPackageClear" + ".txt"
        $CurrentVersionO = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($OpenJDKPackageClear -eq "8") {
            If ($openJDKArchitectureClear -eq "x86") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            } else {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            $OpenJDKSplit = $OpenJDKV.split(".")
            $OpenJDKStrings = ([regex]::Matches($OpenJDKV, "\." )).count
            $OpenJDKStringsNotLast = $OpenJDKStrings
            $OpenJDKStringsNotLast --
            $OpenJDKStringPenultimate = ([regex]::Matches($OpenJDKSplit[$OpenJDKStringsNotLast], "." )).count
            If ($OpenJDKStringPenultimate -eq "4") {
                $OpenJDKDR = $OpenJDKSplit[$OpenJDKStringsNotLast]
                $OpenJDKDR = $OpenJDKDR[0] + $OpenJDKDR[1] + $OpenJDKDR[2] + "." + $OpenJDKDR[3]
                $OpenJDKSplit[$OpenJDKStringsNotLast] = $OpenJDKDR
            }
            Switch ($OpenJDKStrings) {
                1 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[3]
                }
            }
            If ($CurrentVersionO) {$CurrentVersionO = $CurrentVersionO -replace "-"}
            If ($CurrentVersionO) {$CurrentVersionO = $CurrentVersionO -replace "\.0"}
            If ($CurrentVersionO -like "*b0*") {$CurrentVersionO = $CurrentVersionO -replace "b0"}
        }
        If ($OpenJDKPackageClear -eq "11") {
            $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$OpenJDKV) {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If ($CurrentVersionO) {$CurrentVersionO = $CurrentVersionO -replace ".-"}
        }
        If ($OpenJDKPackageClear -eq "17") {
            $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$OpenJDKV) {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $OpenJDKSplit = $OpenJDKV.split(".")
            $OpenJDKStrings = ([regex]::Matches($OpenJDKV, "\." )).count
            $OpenJDKDR = $OpenJDKSplit[1]
            $OpenJDKDR = $OpenJDKDR[1] + "." + $OpenJDKDR[2] + "." + $OpenJDKDR[3]
            $OpenJDKSplit[1] = $OpenJDKDR
            Switch ($OpenJDKStrings) {
                1 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[3]
                }
            }
            If ($CurrentVersionO) {$CurrentVersionO = $CurrentVersionO -replace('-','.')}
            If ($CurrentVersionO) {$CurrentVersionO = $CurrentVersionO -replace('.0.1.','.001')}
            If ($OpenJDKV) {$OpenJDKV = $OpenJDKV -replace('.0030.','.0.3.0.')}
        }
        Write-Host -ForegroundColor Magenta "$Product release $OpenJDKPackageClear $openJDKArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product release $OpenJDKPackageClear $openJDKArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionO"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionO"
        Write-Host "Installed Version:  $OpenJDKV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $OpenJDKV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionO -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($OpenJDKV -lt $Version) {
            If (!$OpenJDKV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($OpenShellMenu -eq 1) {
        $Product = "Open-Shell Menu"
        $OpenShellMenuD = Get-EvergreenApp -Name OpenShellMenu
        $Version = $OpenShellMenuD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionOSM = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $OpenShellMenuV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Open-Shell*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OpenShellMenuV) {
            $OpenShellMenuV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Open-Shell*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionOSM"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionOSM"
        Write-Host "Installed Version:  $OpenShellMenuV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $OpenShellMenuV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionOSM -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($OpenShellMenuV -lt $Version) {
            If (!$OpenShellMenuV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($OperaBrowser -eq 1) {
        $Product = "Opera Browser"
        $OperaBrowserD = Get-EvergreenApp -Name OperaBrowser | Where-Object { $_.Architecture -eq "$OperaBrowserArchitectureClear" -and $_.Channel -eq "$OperaBrowserChannelClear"}
        $Version = $OperaBrowserD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OperaBrowserArchitectureClear" + "_$OperaBrowserChannelClear" + ".txt"
        $CurrentVersionOB = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $OperaBrowserV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Opera*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OperaBrowserV) {
            $OperaBrowserV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Opera*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionOB"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionOB"
        Write-Host "Installed Version:  $OperaBrowserV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $OperaBrowserV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionOB -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($OperaBrowserV -lt $Version) {
            If (!$OperaBrowserV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($OracleJava8 -eq 1) {
        $Product = "Oracle Java 8"
        If ($OracleJava8_Architecture -eq 3) {
            $OracleJava8ArchitectureClear = "x64"
            $OracleJava8Architecture2Clear = "x86"
        }
        $OracleJava8D = Get-EvergreenApp -Name OracleJava8 | Where-Object { $_.Architecture -eq "$OracleJava8ArchitectureClear" }
        $Version = $OracleJava8D.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OracleJava8ArchitectureClear" + ".txt"
        $CurrentVersionOJ = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $OracleJava = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8ArchitectureVersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OracleJava) {
            $OracleJava = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8ArchitectureVersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($OracleJava) {
            $OracleJavaSplit = $OracleJava.split(".")
            $OracleJavaSplit2 = (Select-String '.{3}' -Input $OracleJavaSplit[2]).Matches.Value
            $OracleJava = "1." + $OracleJavaSplit[0] + "." + $OracleJavaSplit[1] + "_" + $OracleJavaSplit2 + "-b" + $OracleJavaSplit[3]
        }
        Write-Host -ForegroundColor Magenta "$Product $OracleJava8ArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $OracleJava8ArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionOJ"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionOJ"
        Write-Host "Installed Version:  $OracleJava"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $OracleJava"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionOJ -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($OracleJava -lt $Version) {
            If (!$OracleJava) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PaintDotNet -eq 1) {
        $Product = "Paint.Net"
        $PaintDotNetD = Get-EvergreenApp -Name PaintDotNetOfflineInstaller | Where-Object { $_.Architecture -eq "$PaintDotNetArchitectureClear" -and $_.URI -like "*winmsi*"}
        $Version = $PaintDotNetD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PaintDotNetArchitectureClear" + ".txt"
        $CurrentVersionP = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $PaintDotNetV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Paint.Net*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PaintDotNetV) {
            $PaintDotNetV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Paint.Net*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $PaintDotNetArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $PaintDotNetArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionP"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionP"
        Write-Host "Installed Version:  $PaintDotNetV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PaintDotNetV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionP -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PaintDotNetV -lt $Version) {
            If (!$PaintDotNetV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PDF24Creator -eq 1) {
        $Product = "PDF24 Creator"
        $PDF24CreatorD = Get-evergreenApp -name GeekSoftwarePDF24Creator | Where-Object { $_.Type -eq "Msi"}
        $Version = $PDF24CreatorD.Version
        $CurrentVersionP24 = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $PDF24CreatorV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PDF24 Creator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PDF24CreatorV) {
            $PDF24CreatorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PDF24 Creator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionP24"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionP24"
        Write-Host "Installed Version:  $PDF24CreatorV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PDF24CreatorV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionP24 -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PDF24CreatorV -lt $Version) {
            If (!$PDF24CreatorV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PDFForgeCreator -eq 1) {
        $Product = "pdfforge PDFCreator"
        $PDFForgeCreatorD = Get-PDFForgePDFCreator | Where-Object { $_.Channel -eq "$pdfforgePDFCreatorChannelClear" }
        $Version = $PDFForgeCreatorD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$pdfforgePDFCreatorChannelClear" + ".txt"
        $CurrentVersionPF = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $PDFForgeCreatorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFCreator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PDFForgeCreatorV) {
            $PDFForgeCreatorV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFCreator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $pdfforgePDFCreatorChannelClear edition"
        Add-Content -Path "$ReportFile" -Value "$Product $pdfforgePDFCreatorChannelClear edition"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionPF"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionPF"
        Write-Host "Installed Version:  $PDFForgeCreatorV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PDFForgeCreatorV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionPF -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PDFForgeCreatorV -lt $Version) {
            If (!$PDFForgeCreatorV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PDFsam -eq 1) {
        $Product = "PDF Split & Merge"
        $PDFsamD = Get-PDFsam
        $Version = $PDFsamD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionPSam = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $PDFsamV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFsam*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PDFsamV) {
            $PDFsamV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFsam*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($PDFsamV) {
            $PDFsamSplit = $PDFsamV.split(".")
            $PDFsamV = $PDFsamSplit[0] + "." + $PDFsamSplit[1] + "." + $PDFsamSplit[2]
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionPSam"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionPSam"
        Write-Host "Installed Version:  $PDFsamV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PDFsamV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionPSam -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PDFsamV -lt $Version) {
            If (!$PDFsamV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PeaZip -eq 1) {
        $Product = "PeaZip"
        $PeaZipD = Get-EvergreenApp -Name PeaZipPeaZip | Where-Object {$_.Architecture -eq "$PeaZipArchitectureClear" -and $_.Type -eq "exe"}
        $Version = $PeaZipD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PeaZipArchitectureClear" + ".txt"
        $CurrentVersionPZ = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $PeaZipV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PeaZip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PeaZipV) {
            $PeaZipV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PeaZip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $PeaZipArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $PeaZipArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionPZ"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionPZ"
        Write-Host "Installed Version:  $PeaZipV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PeaZipV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionPZ -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PeaZipV -lt $Version) {
            If (!$PeaZipV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($PuTTY -eq 1) {
        $Product = "PuTTY"
        $PuTTYD = Get-Putty | Where-Object { $_.Architecture -eq "$PuTTYArchitectureClear" -and $_.Channel -eq "$PuttyChannelClear"}
        $Version = $PuTTYD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PuTTYArchitectureClear" + "_$PuttyChannelClear" + ".txt"
        $CurrentVersionPu = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $PuTTYV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PuTTY*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PuTTYV) {
            $PuTTYV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PuTTY*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($PuTTYV) {
            $PuTTYV = $PuTTYV.Split(".")
            $PuTTYV = $PuTTYV[0] + "." + $PuTTYV[1]
        }
        Write-Host -ForegroundColor Magenta "$Product $PuttyChannelClear $PuTTYArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $PuttyChannelClear $PuTTYArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionPu"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionPu"
        Write-Host "Installed Version:  $PuTTYV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $PuTTYV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionPu -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($PuTTYV -lt $Version) {
            If (!$PuTTYV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($RemoteDesktopManager -eq 1) {
        Switch ($RemoteDesktopManagerType) {
            0 {
                $Product = "Remote Desktop Manager Free"
            	$URLVersion = "https://devolutions.net/remote-desktop-manager/de/release-notes/free"
                $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($URLVersion) -SessionVariable websession
                $regexAppVersion = "\d\d\d\d\.\d\.\d\d\.\d+"
                $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $Version = $webVersion.Trim("</td>").Trim("</td>")
                $RemoteDesktopManagerFreeD = $Version
                $CurrentVersionRDM = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $RemoteDesktopManagerFree = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Remote Desktop Manager*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                Write-Host -ForegroundColor Magenta "$Product"
                Add-Content -Path "$ReportFile" -Value "$Product"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
                Write-Host "Downloaded Version: $CurrentVersionRDM"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionRDM"
                Write-Host "Installed Version:  $RemoteDesktopManagerFree"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $RemoteDesktopManagerFree"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionRDM -lt $Version) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($RemoteDesktopManagerFree -lt $Version) {
                    If (!$RemoteDesktopManagerFree) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
            1 {
                $Product = "Remote Desktop Manager Enterprise"
            	$URLVersion = "https://devolutions.net/remote-desktop-manager/de/release-notes"
                $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($URLVersion) -SessionVariable websession
                $regexAppVersion = "\d\d\d\d\.\d\.\d\d\.\d+"
                $webVersionRDM = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $Version = $webVersionRDM.Trim("</td>").Trim("</td>")
                $RemoteDesktopManagerEnterpriseD = $Version
                $CurrentVersionRDM = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $RemoteDesktopManagerEnterprise = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Remote Desktop Manager*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                Write-Host -ForegroundColor Magenta "$Product"
                Add-Content -Path "$ReportFile" -Value "$Product"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
                Write-Host "Downloaded Version: $CurrentVersionRDM"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionRDM"
                Write-Host "Installed Version:  $RemoteDesktopManagerEnterprise"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $RemoteDesktopManagerEnterprise"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionRDM -lt $Version) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($RemoteDesktopManagerEnterprise -lt $Version) {
                    If (!$RemoteDesktopManagerEnterprise) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
        }
    }

    If ($Screenpresso -eq 1) {
        $Product = "Screenpresso"
        $ScreenpressoD = Get-Screenpresso
        $Version = $ScreenpressoD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionS = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $ScreenpressoV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ScreenpressoV) {
            $ScreenpressoV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$ScreenpressoV) {
            $ScreenpressoV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($ScreenpressoV) {
            $ScreenpressoV = $ScreenpressoV.Split(".")
            $ScreenpressoV = $ScreenpressoV[0] + "." + $ScreenpressoV[1] + "." + $ScreenpressoV[2]
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionS"
        Write-Host "Installed Version:  $ScreenpressoV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $ScreenpressoV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($ScreenpressoV -lt $Version) {
            If (!$ScreenpressoV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($ShareX -eq 1) {
        $Product = "ShareX"
        $ShareXD = Get-EvergreenApp -Name ShareX | Where-Object {$_.Type -eq "exe"}
        $Version = $ShareXD.Version
        $CurrentVersionSh = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $ShareXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*ShareX*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ShareXV) {
            $ShareXV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*ShareX*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionSh"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionSh"
        Write-Host "Installed Version:  $ShareXV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $ShareXV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionSh -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($ShareXV -lt $Version) {
            If (!$ShareXV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Slack -eq 1) {
        $Product = "Slack"
        $SlackD = Get-EvergreenApp -Name Slack | Where-Object {$_.Architecture -eq "$SlackArchitectureClear" -and $_.Platform -eq "PerMachine" }
        $Version = $SlackD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SlackArchitectureClear" + "_$SlackPlatformClear" + ".txt"
        $CurrentVersionSl = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $SlackV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SlackV) {
            $SlackV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$SlackV) {
            $SlackV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$SlackV) {
        }
        Else {
            If ($SlackV.length -ne "6") {$SlackV = $SlackV -replace ".{2}$"}
        }
        Write-Host -ForegroundColor Magenta "$Product $SlackArchitectureClear $SlackPlatformClear"
        Add-Content -Path "$ReportFile" -Value "$Product $SlackArchitectureClear $SlackPlatformClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionSl"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionSl"
        Write-Host "Installed Version:  $SlackV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $SlackV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionSl -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($SlackV -lt $Version) {
            If (!$SlackV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($SumatraPDF -eq 1) {
        $Product = "Sumatra PDF"
        $SumatraPDFD = Get-EvergreenApp -Name SumatraPDFReader | Where-Object {$_.Architecture -eq "$SumatraPDFArchitectureClear" }
        $Version = $SumatraPDFD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SumatraPDFArchitectureClear" + ".txt"
        $CurrentVersionSu = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $SumatraPDFV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "SumatraPDF"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SumatraPDFV) {
            $SumatraPDFV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "SumatraPDF"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $SumatraPDFArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $SumatraPDFArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionSu"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionSu"
        Write-Host "Installed Version:  $SumatraPDFV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $SumatraPDFV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionSu -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($SumatraPDFV -lt $Version) {
            If (!$SumatraPDFV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($TeamViewer -eq 1) {
        $Product = "TeamViewer"
        $TeamViewerD = Get-EvergreenApp -Name TeamViewer
        $Version = $TeamViewerD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TeamViewerArchitectureClear" + ".txt"
        $CurrentVersionT = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $TeamViewerV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TeamViewer*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TeamViewerV) {
            $TeamViewerV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "TeamViewer"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $TeamViewerArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $TeamViewerArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionT"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionT"
        Write-Host "Installed Version:  $TeamViewerV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $TeamViewerV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionT -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($TeamViewerV -lt $Version) {
            If (!$TeamViewerV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($TechSmithCamtasia -eq 1) {
        $Product = "TechSmith Camtasia"
        $TechSmithCamtasiaD = Get-EvergreenApp -Name TechSmithCamtasia | Where-Object { $_.Type -eq "msi" }
        $Version = $TechSmithCamtasiaD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionTC = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $TechSmithCamtasiaV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Camtasia*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TechSmithCamtasiaV) {
            $TechSmithCamtasiaV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Camtasia*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($TechSmithCamtasiaV) {$TechSmithCamtasiaSplit = $TechSmithCamtasiaV.split(".")}
        If ($TechSmithCamtasiaSplit) {$TechSmithCamtasiaStrings = ([regex]::Matches($TechSmithCamtasiaV, "\." )).count}
        Switch ($TechSmithCamtasiaStrings) {
            1 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1]
            }
            2 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1] + "." + $TechSmithCamtasiaSplit[2]
            }
            3 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1] + "." + $TechSmithCamtasiaSplit[2]
            }
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionTC"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTC"
        Write-Host "Installed Version:  $TechSmithCamtasiaVN"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $TechSmithCamtasiaVN"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionTC -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($TechSmithCamtasiaVN -lt $Version) {
            If (!$TechSmithCamtasiaVN) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($TechSmithSnagIt -eq 1) {
        $Product = "TechSmith SnagIt"
        $TechSmithSnagitD = Get-EvergreenApp -Name TechSmithSnagit | Where-Object { $_.Architecture -eq "$TechSmithSnagItArchitectureClear" -and $_.Type -eq "msi" }
        $Version = $TechSmithSnagitD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TechSmithSnagItArchitectureClear" + ".txt"
        $CurrentVersionTCS = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $TechSmithSnagItV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "SnagIt*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TechSmithSnagItV) {
            $TechSmithSnagItV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "SnagIt*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $TechSmithSnagItArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $TechSmithSnagItArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionTCS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTCS"
        Write-Host "Installed Version:  $TechSmithSnagItV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $TechSmithSnagItV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionTCS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($TechSmithSnagItV -lt $Version) {
            If (!$TechSmithSnagItV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($TotalCommander -eq 1) {
        $Product = "Total Commander"
        $TotalCommanderD = Get-TotalCommander | Where-Object {$_.Architecture -eq "$TotalCommanderArchitectureClear"}
        $Version = $TotalCommanderD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TotalCommanderArchitectureClear" + ".txt"
        $CurrentVersionTCo = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $TotalCommanderV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Total Commander*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TotalCommanderV) {
            $TotalCommanderV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Total Commander*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $TotalCommanderArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $TotalCommanderArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionTCo"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTCo"
        Write-Host "Installed Version:  $TotalCommanderV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $TotalCommanderV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionTCo -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($TotalCommanderV -lt $Version) {
            If (!$TotalCommanderV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($TreeSize -eq 1) {
        Switch ($TreeSizeType) {
            0 {
                $Product = "TreeSize Free"
                $TreeSizeFreeD = Get-EvergreenApp -Name JamTreeSizeFree
                $Version = $TreeSizeFreeD.Version
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $CurrentVersionTre = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $CurrentVersionC = ([regex]::Matches($CurrentVersionTre, "\." )).count
                If ($CurrentVersionC -ne 2){
                    $CurrentVersionTre = $CurrentVersionTre.Insert(3,'.')
                }
                $TreeSizeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize Free*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$TreeSizeV) {
                    $TreeSizeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize Free*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                Write-Host -ForegroundColor Magenta "$Product"
                Add-Content -Path "$ReportFile" -Value "$Product"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
                Write-Host "Downloaded Version: $CurrentVersionTre"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTre"
                Write-Host "Installed Version:  $TreeSizeV"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $TreeSizeV"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionTre -lt $Version) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($TreeSizeV -lt $Version) {
                    If (!$TreeSizeV) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
            1 {
                $Product = "TreeSize Professional"
                $TreeSizeProfD = Get-EvergreenApp -Name JamTreeSizeProfessional
                $Version = $TreeSizeProfD.Version
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $CurrentVersionTre = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $CurrentVersionC = ([regex]::Matches($CurrentVersionTre, "\." )).count
                If ($CurrentVersionC -ne 2){
                    $CurrentVersionTre = $CurrentVersionTre.Insert(3,'.')
                }
                $TreeSizeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize V*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$TreeSizeV) {
                    $TreeSizeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize V*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                Write-Host -ForegroundColor Magenta "$Product"
                Add-Content -Path "$ReportFile" -Value "$Product"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
                Write-Host "Downloaded Version: $CurrentVersionTre"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionTre"
                Write-Host "Installed Version:  $TreeSizeV"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $TreeSizeV"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionTre -lt $Version) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($TreeSizeV -lt $Version) {
                    If (!$TreeSizeV) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
        }
    }

    If ($VLCPlayer -eq 1) {
        $Product = "VLC Player"
        $VLCD = Get-EvergreenApp -Name VideoLanVlcPlayer | Where-Object { $_.Platform -eq "Windows" -and $_.Architecture -eq "$VLCPlayerArchitectureClear" -and $_.Type -eq "MSI" }
        $Version = $VLCD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VLCPlayerArchitectureClear" + ".txt"
        $CurrentVersionV = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $VLC = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VLC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$VLC) {
            $VLC = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VLC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($VLC) {$VLC = $VLC -replace ".{2}$"}
        Write-Host -ForegroundColor Magenta "$Product $VLCPlayerArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $VLCPlayerArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionV"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionV"
        Write-Host "Installed Version:  $VLC"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $VLC"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionV -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($VLC -lt $Version) {
            If (!$VLC) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($VMwareTools -eq 1) {
        $Product = "VMware Tools"
        $VMwareToolsD = Get-VMwareTools | Where-Object { $_.Architecture -eq "$VMwareToolsArchitectureClear" }
        $Version = $VMwareToolsD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VMwareToolsArchitectureClear" + ".txt"
        $CurrentVersionVM = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $VMWT = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VMware Tools*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$VMWT) {
            $VMWT = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VMware Tools*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($VMWT) {$VMWT = $VMWT -replace ".{9}$"}
        Write-Host -ForegroundColor Magenta "$Product $VMwareToolsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $VMwareToolsArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionVM"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionVM"
        Write-Host "Installed Version:  $VMWT"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $VMWT"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionVM -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($VMWT -lt $Version) {
            If (!$VMWT) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($WinMerge -eq 1) {
        $Product = "WinMerge"
        $WinMergeD = Get-EvergreenApp -Name WinMerge | Where-Object {$_.Architecture -eq "$WinMergeArchitectureClear" -and $_.URI -notlike "*PerUser*"}
        $Version = $WinMergeD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinMergeArchitectureClear" + ".txt"
        $CurrentVersionW = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $WinMergeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinMerge*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WinMergeV) {
            $WinMergeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinMerge*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $WinMergeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $WinMergeArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionW"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionW"
        Write-Host "Installed Version:  $WinMergeV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $WinMergeV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionW -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($WinMergeV -lt $Version) {
            If (!$WinMergeV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($WinRAR -eq 1) {
        $Product = "WinRAR"
        $WinRARD = Get-WinRAR | Where-Object {$_.Architecture -eq "$WinRARArchitectureClear" -and $_.Channel -eq "$WinRARChannelClear" -and $_.Language -eq "$WinRARLanguageClear"}
        $Version = $WinRARD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear" + ".txt"
        $CurrentVersionWR = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $WinRARV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinRAR*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WinRARV) {
            $WinRARV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinRAR*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($WinRARV) {$WinRARV = $WinRARV -replace "\.\d*$"}
        Write-Host -ForegroundColor Magenta "$Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionWR"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionWR"
        Write-Host "Installed Version:  $WinRARV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $WinRARV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionWR -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($WinRARV -lt $Version) {
            If (!$WinRARV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($WinSCP -eq 1) {
        $Product = "WinSCP"
        $WinSCPD = Get-EvergreenApp -Name WinSCP | Where-Object {$_.URI -like "*Setup*"}
        $Version = $WinSCPD.Version
        $CurrentVersionWS = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $WSCP = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*WinSCP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionWS"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionWS"
        Write-Host "Installed Version:  $WSCP"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $WSCP"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionWS -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($WSCP -lt $Version) {
            If (!$WSCP) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Wireshark -eq 1) {
        $Product = "Wireshark"
        $WiresharkD = Get-EvergreenApp -Name Wireshark | Where-Object { $_.Architecture -eq "$WiresharkArchitectureClear" -and $_.Type -eq "exe"}
        $Version = $WiresharkD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WiresharkArchitectureClear" + ".txt"
        $CurrentVersionWI = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $WiresharkV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Wireshark*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WiresharkV) {
            $WiresharkV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Wireshark*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product $WiresharkArchitectureClear"
        Add-Content -Path "$ReportFile" -Value "$Product $WiresharkArchitectureClear"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionWI"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionWI"
        Write-Host "Installed Version:  $WiresharkV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $WiresharkV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionWI -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($WiresharkV -lt $Version) {
            If (!$WiresharkV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($XCA -eq 1) {
        $Product = "XCA"
        $XCAD = Get-XCA
        $Version = $XCAD.Version
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersionX = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $XCAV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*XCA*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$XCAV) {
            $XCAV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*XCA*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "$Product"
        Add-Content -Path "$ReportFile" -Value "$Product"
        Add-Content -Path "$ReportFile" -Value ""
        Write-Host "Internet Version:   $Version"
        Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
        Write-Host "Downloaded Version: $CurrentVersionX"
        Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionX"
        Write-Host "Installed Version:  $XCAV"
        Add-Content -Path "$ReportFile" -Value "Installed Version:  $XCAV"
        Add-Content -Path "$ReportFile" -Value ""
        If ($CurrentVersionX -lt $Version) {
            Write-Host -ForegroundColor Yellow "New version available in the internet"
            Add-Content -Path "$ReportFile" -Value "New version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        } Else {
            Write-Host -ForegroundColor Green "No new version available in the internet"
            Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
        If ($XCAV -lt $Version) {
            If (!$XCAV) {
                Write-Host -ForegroundColor Cyan "No installed version found"
                Add-Content -Path "$ReportFile" -Value "No installed version found"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Yellow "Update available for installed version"
                Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        } Else {
            Write-Host -ForegroundColor Green "No update available for installed version"
            Add-Content -Path "$ReportFile" -Value "No update available for installed version"
            Write-Output ""
            Add-Content -Path "$ReportFile" -Value ""
        }
    }

    If ($Zoom -eq 1) {
        If ($ZoomCitrixClient -eq 0) {
            If ($ZoomInstallerClear -eq 'User Based') {
                $Product = "Zoom"
                $ZoomD = Get-NevergreenApp -Name Zoom -WarningAction:SilentlyContinue | Where-Object {$_.Name -eq "Zoom" -and $_.Architecture -eq "$ZoomArchitectureClear" -and $_.Type -eq "Msi"}
                $Version = $ZoomD.Version
                $VersionSplit = $Version.split(".")
                $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[3]
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ZoomArchitectureClear" + ".txt"
                $CurrentVersionZ = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Zoom"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$ZoomV) {
                    $ZoomV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Zoom"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                Write-Host -ForegroundColor Magenta "$Product $ZoomArchitectureClear"
                Add-Content -Path "$ReportFile" -Value "$Product $ZoomArchitectureClear"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $Version"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
                Write-Host "Downloaded Version: $CurrentVersionZ"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionZ"
                Write-Host "Installed Version:  $ZoomV"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $ZoomV"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionZ -lt $Version) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($ZoomV -lt $Version) {
                    If (!$ZoomV) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
            If ($ZoomInstallerClear -eq 'Machine Based') {
                $Product = "Zoom VDI"
                $ZoomD = Get-ZoomVDI
                $Version = $ZoomD.Version
                $VersionApps = $ZoomD.VersionApps
                $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
                $CurrentVersionZ = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Zoom Client for VDI*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                Write-Host -ForegroundColor Magenta "$Product"
                Add-Content -Path "$ReportFile" -Value "$Product"
                Add-Content -Path "$ReportFile" -Value ""
                Write-Host "Internet Version:   $VersionApps"
                Add-Content -Path "$ReportFile" -Value "Internet Version:   $VersionApps"
                Write-Host "Downloaded Version: $CurrentVersionZ"
                Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionZ"
                Write-Host "Installed Version:  $ZoomV"
                Add-Content -Path "$ReportFile" -Value "Installed Version:  $ZoomV"
                Add-Content -Path "$ReportFile" -Value ""
                If ($CurrentVersionZ -lt $VersionApps) {
                    Write-Host -ForegroundColor Yellow "New version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Green "No new version available in the internet"
                    Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
                If ($ZoomV -lt $VersionApps) {
                    If (!$ZoomV) {
                        Write-Host -ForegroundColor Cyan "No installed version found"
                        Add-Content -Path "$ReportFile" -Value "No installed version found"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    } Else {
                        Write-Host -ForegroundColor Yellow "Update available for installed version"
                        Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                        Write-Output ""
                        Add-Content -Path "$ReportFile" -Value ""
                    }
                } Else {
                    Write-Host -ForegroundColor Green "No update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            }
        }
    }
    If ($Zoom -eq 1) {
        If ($ZoomCitrixClient -eq 1) {
            $Product = "Zoom Citrix HDX Media Plugin"
            $ZoomCitrix = Get-NevergreenApp -Name Zoom -EA SilentlyContinue -WarningAction:SilentlyContinue | Where-Object {$_.Name -like "*Citrix*"}
            $Version = $ZoomCitrix.version
            $VersionPath = "$PSScriptRoot\$Product\Version.txt"
            $CurrentVersionZ = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Zoom Plugin*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            Write-Host -ForegroundColor Magenta "$Product"
            Add-Content -Path "$ReportFile" -Value "$Product"
            Add-Content -Path "$ReportFile" -Value ""
            Write-Host "Internet Version:   $Version"
            Add-Content -Path "$ReportFile" -Value "Internet Version:   $Version"
            Write-Host "Downloaded Version: $CurrentVersionZ"
            Add-Content -Path "$ReportFile" -Value "Downloaded Version: $CurrentVersionZ"
            Write-Host "Installed Version:  $ZoomV"
            Add-Content -Path "$ReportFile" -Value "Installed Version:  $ZoomV"
            Add-Content -Path "$ReportFile" -Value ""
            If ($CurrentVersionZ -lt $Version) {
                Write-Host -ForegroundColor Yellow "New version available in the internet"
                Add-Content -Path "$ReportFile" -Value "New version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            } Else {
                Write-Host -ForegroundColor Green "No new version available in the internet"
                Add-Content -Path "$ReportFile" -Value "No new version available in the internet"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
            If ($ZoomV -lt $Version) {
                If (!$ZoomV) {
                    Write-Host -ForegroundColor Cyan "No installed version found"
                    Add-Content -Path "$ReportFile" -Value "No installed version found"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                } Else {
                    Write-Host -ForegroundColor Yellow "Update available for installed version"
                    Add-Content -Path "$ReportFile" -Value "Update available for installed version"
                    Write-Output ""
                    Add-Content -Path "$ReportFile" -Value ""
                }
            } Else {
                Write-Host -ForegroundColor Green "No update available for installed version"
                Add-Content -Path "$ReportFile" -Value "No update available for installed version"
                Write-Output ""
                Add-Content -Path "$ReportFile" -Value ""
            }
        }
    }
}

#// Mark: End Test Zone

If ($Download -eq "1") {
    # Logging
    # Global variables
    # $StartDir = $PSScriptRoot # the directory path of the script currently being executed
    $LogDir = "$PSScriptRoot\_Install Logs"
    $LogTemp = "$env:windir\Logs\NeverRed"
    $LogFileName = ("$ENV:COMPUTERNAME - $Date.log")
    $LogFile = Join-path $LogDir $LogFileName
    $FWFileName = ("Firewall - $Date.log")
    $FWFile = Join-path $LogDir $FWFileName
    $WhatIfFileName = ("WhatIf - $Date.log")
    $WhatIfFile = Join-path $LogDir $WhatIfFileName

    # Create the log directories if they don't exist
    If (!(Test-Path $LogDir)) { New-Item -Path $LogDir -ItemType directory | Out-Null }
    If (!(Test-Path $LogTemp)) { New-Item -Path $LogTemp -ItemType directory | Out-Null }

    # Create new log file (overwrite existing one)
    New-Item $FWFile -ItemType "file" -force | Out-Null
    DS_WriteLog "I" "START SCRIPT - " $FWFile
    DS_WriteLog "-" "" $FWFile

    # Create new log file (overwrite existing one)
    If ($WhatIf -eq "1") {
        New-Item $WhatIfFile -ItemType "file" -force | Out-Null
        DS_WriteLog "I" "START SCRIPT - " $WhatIfFile
        DS_WriteLog "-" "" $WhatIfFile
    }

    # Default Browser
    $DefaultBrowserReg = Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice" | Select-Object -ExpandProperty "ProgId"
    Switch ($DefaultBrowserReg) {
        MSEdgeHTM {$DefaultBrowser = "msedge"}
        FirefoxURL {$DefaultBrowser = "firefox"}
        ChromeHTML {$DefaultBrowser = "chrome"}
        IE.HTTP {$DefaultBrowser = "iexplorer"}
    }

    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    If (!($NoPSModuleCheck)) {
        #// Mark: Install / Update PowerShell module
        Write-Host -ForegroundColor DarkGray "Install / Update PowerShell module!"

        If (!(Test-Path -Path "C:\Program Files\PackageManagement\ProviderAssemblies\nuget")) {
            Write-Host "Install Nuget include dependencies."
            Find-PackageProvider -Name 'Nuget' -ForceBootstrap -IncludeDependencies | Install-PackageProvider -Force | Out-Null
            Write-Host -ForegroundColor Green "Install Nuget include dependencies done."
            Write-Output ""
        }

        If (!(Get-Module -ListAvailable -Name Evergreen)) {
            Write-Host "Install Evergreen module."
            Install-Module Evergreen -Force | Import-Module Evergreen
            $eversion = (Get-Module -ListAvailable Evergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $estringver = $eversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $ea = $estringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host -ForegroundColor Green "Install Evergreen module done. Version"$ea
            Write-Output ""
        }
        Else {
            Write-Host "Check Evergreen module version."
            $eversion = (Get-Module -ListAvailable Evergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $epsgalleryversion = Find-Module -Name Evergreen | Sort-Object Version -Descending | Select-Object Version -First 1
            $estringver = $eversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $ea = $estringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host "Installed Evergreen module version:" $ea
            $eonlinever = $epsgalleryversion | select-object @{n='OnlineVersion'; e={$_.Version -as [string]}}
            $eb = $eonlinever | Select-Object OnlineVersion -ExpandProperty OnlineVersion
            Write-Host "Online available Evergreen module version:" $eb
            if ([version]"$ea" -ge [version]"$eb") {
                Write-Host -ForegroundColor Green "Installed Evergreen module version is up to date."
                Write-Output ""
            }
            else {
                Write-Host "Update Evergreen module."
                Update-Module Evergreen -force | Import-Module Evergreen -force
                Install-Module Evergreen -Force | Import-Module Evergreen -force
                $eversion = (Get-Module -ListAvailable Evergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
                $estringver = $eversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
                $ea = $estringver | Select-Object Moduleversion -ExpandProperty Moduleversion
                Write-Host -ForegroundColor Green "Update Evergreen module done. Version"$ea
                Write-Output ""
            }
        }

        If (!(Get-Module -ListAvailable -Name Nevergreen)) {
            Write-Host "Install Nevergreen module."
            Install-Module Nevergreen -Force | Import-Module Nevergreen
            $nversion = (Get-Module -ListAvailable Nevergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $nstringver = $nversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $na = $nstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host -ForegroundColor Green "Install Nevergreen module done. Version"$na
            Write-Output ""
        }
        Else {
            Write-Host "Check Nevergreen module version."
            $nversion = (Get-Module -ListAvailable Nevergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $npsgalleryversion = Find-Module -Name Nevergreen | Sort-Object Version -Descending | Select-Object Version -First 1
            $nstringver = $nversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $na = $nstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host "Installed Nevergreen module version:" $na
            $nonlinever = $npsgalleryversion | select-object @{n='OnlineVersion'; e={$_.Version -as [string]}}
            $nb = $nonlinever | Select-Object OnlineVersion -ExpandProperty OnlineVersion
            Write-Host "Online available Nevergreen module version:" $nb
            if ([version]"$na" -ge [version]"$nb") {
                Write-Host -ForegroundColor Green "Installed Nevergreen module version is up to date."
                Write-Output ""
            }
            else {
                Write-Host "Update Nevergreen module."
                Update-Module Nevergreen -force | Import-Module Nevergreen -force
                Install-Module Nevergreen -Force | Import-Module Nevergreen
                $nversion = (Get-Module -ListAvailable Nevergreen) | Sort-Object Version -Descending  | Select-Object Version -First 1
                $nstringver = $nversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
                $na = $nstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
                Write-Host -ForegroundColor Green "Update Nevergreen module done. Version"$na
                Write-Output ""
        }
        }

        If (!(Get-Module -ListAvailable -Name VcRedist)) {
            Write-Host "Install VcRedist module."
            Install-Module VcRedist -Force | Import-Module VcRedist
            $vversion = (Get-Module -ListAvailable VcRedist) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $vstringver = $vversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $va = $vstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host -ForegroundColor Green "Install VcRedist module done. Version"$va
            Write-Output ""
        }
        Else {
            Write-Host "Check VcRedist module version."
            $vversion = (Get-Module -ListAvailable VcRedist) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $vpsgalleryversion = Find-Module -Name VcRedist | Sort-Object Version -Descending | Select-Object Version -First 1
            $vstringver = $vversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $va = $vstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host "Installed VcRedist module version:" $va
            $vonlinever = $vpsgalleryversion | select-object @{n='OnlineVersion'; e={$_.Version -as [string]}}
            $vb = $vonlinever | Select-Object OnlineVersion -ExpandProperty OnlineVersion
            Write-Host "Online available VcRedist module version:" $vb
            if ([version]"$va" -ge [version]"$vb") {
                Write-Host -ForegroundColor Green "Installed VcRedist module version is up to date."
                Write-Output ""
            }
            else {
                Write-Host "Update VcRedist module."
                Update-Module VcRedist -force | Import-Module VcRedist -force
                Install-Module VcRedist -Force | Import-Module VcRedist
                $vversion = (Get-Module -ListAvailable VcRedist) | Sort-Object Version -Descending  | Select-Object Version -First 1
                $vstringver = $vversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
                $va = $vstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
                Write-Host -ForegroundColor Green "Update VcRedist module done. Version"$va
                Write-Output ""
            }
        }
        If (!(Get-Module -ListAvailable -Name PSWindowsUpdate)) {
            Write-Host "Install PSWindowsUpdate module."
            Install-Module PSWindowsUpdate -Force | Import-Module PSWindowsUpdate
            $pversion = (Get-Module -ListAvailable PSWindowsUpdate) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $pstringver = $pversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $pa = $pstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host -ForegroundColor Green "Install PSWindowsUpdate module done. Version"$pa
            Write-Output ""
        }
        Else {
            Write-Host "Check PSWindowsUpdate module version."
            $pversion = (Get-Module -ListAvailable PSWindowsUpdate) | Sort-Object Version -Descending  | Select-Object Version -First 1
            $ppsgalleryversion = Find-Module -Name PSWindowsUpdate | Sort-Object Version -Descending | Select-Object Version -First 1
            $pstringver = $pversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
            $pa = $pstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
            Write-Host "Installed PSWindowsUpdate module version:" $pa
            $ponlinever = $ppsgalleryversion | select-object @{n='OnlineVersion'; e={$_.Version -as [string]}}
            $pb = $ponlinever | Select-Object OnlineVersion -ExpandProperty OnlineVersion
            Write-Host "Online available PSWindowsUpdate module version:" $pb
            if ([version]"$pa" -ge [version]"$pb") {
                Write-Host -ForegroundColor Green "Installed PSWindowsUpdate module version is up to date."
                Write-Output ""
            }
            else {
                Write-Host "Update PSWindowsUpdate module."
                Update-Module PSWindowsUpdate -force | Import-Module PSWindowsUpdate -force
                Install-Module PSWindowsUpdate -Force | Import-Module PSWindowsUpdate
                $pversion = (Get-Module -ListAvailable PSWindowsUpdate) | Sort-Object Version -Descending  | Select-Object Version -First 1
                $pstringver = $pversion | Select-Object @{n='ModuleVersion'; e={$_.Version -as [string]}}
                $pa = $pstringver | Select-Object Moduleversion -ExpandProperty Moduleversion
                Write-Host -ForegroundColor Green "Update PSWindowsUpdate module done. Version"$pa
                Write-Output ""
            }
        }
    }

    Write-Host -ForegroundColor DarkGray "Starting downloads..."
    Write-Output ""

    # Download script part (AddScript)

    If ($WhatIf -eq '1') {
        Write-Host -BackgroundColor Magenta "WhatIf Mode, nothing will be downloaded !!!"
        Write-Host -BackgroundColor Green "The FW log will be created !!!"
        Write-Output ""
    }

    #// Mark: Download 1Password
    If ($1Password -eq 1) {
        $Product = "1Password"
        $PackageName = "1Password-Setup"
        $1PasswordD = Get-EvergreenApp -Name 1Password | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $1PasswordD.Version
        $1PWSplit = $Version.split(".")
        $1PWStringSecond = ([regex]::Matches($1PWSplit[1], "." )).count
        If ($1PWStringSecond -lt "2") {
            $1PWSplit[1] = "0" + $1PWSplit[1]
        }
        $Version = $1PWSplit[0] + "." + $1PWSplit[1] + "." + $1PWSplit[2]
        $URL = $1PasswordD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $1PWCSplit = $CurrentVersion.split(".")
        $1PWCStringSecond = ([regex]::Matches($1PWCSplit[1], "." )).count
        If ($1PWCStringSecond -lt "2") {
            $1PWCSplit[1] = "0" + $1PWCSplit[1]
        }
        $CurrentVersion = $1PWCSplit[0] + "." + $1PWCSplit[1] + "." + $1PWCSplit[2]
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version:  $Version"
        Write-Host "Current Version:   $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            If ($CleanUp -eq '1') {
                $1PasswordV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$1PasswordV) {
                    $1PasswordV = (Get-ItemProperty HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* -ErrorAction SilentlyContinue | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                $1PWVSplit = $1PasswordV.split(".")
                $1PWVStringSecond = ([regex]::Matches($1PWVSplit[1], "." )).count
                If ($1PWVStringSecond -lt "2") {
                    $1PWVSplit[1] = "0" + $1PWVSplit[1]
                }
                $1PasswordV = $1PWVSplit[0] + "." + $1PWVSplit[1] + "." + $1PWVSplit[2]
                Write-Host -ForegroundColor Blue "CleanUp Mode"
                Write-Host "Installed Version: $1PasswordV"
                If ($1PasswordV -lt $Version) {
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                } Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            } Else {
                Write-Host "Starting download of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download 7 Zip
    If ($7ZIP -eq 1) {
        $Product = "7-Zip"
        $PackageName = "7-Zip_" + "$7ZipArchitectureClear"
        $7ZipD = Get-7-Zip | Where-Object { $_.Architecture -eq "$7ZipArchitectureClear"}
        $Version = $7ZipD.Version
        $URL = $7ZipD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$7ZipArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $7ZipArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $7ZipArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Adobe Pro DC
    If ($AdobeProDC -eq 1) {
        $Product = "Adobe Pro DC"
        $PackageName = "Adobe_Pro_DC_Update_" + "$AdobeProArchitectureClear"
        $AdobeProD = Get-EvergreenApp -Name AdobeAcrobat | Where-Object { $_.Track -eq "DC" -and $_.Language -eq "Neutral" -and $_.Product -eq "Acrobat" -and $_.Architecture -eq "$AdobeProArchitectureClear" }
        $Version = $AdobeProD.Version
        $URL = $AdobeProD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msp"
        $Source = "$PackageName" + "." + "$InstallerType"
        $InstallerURL = "https://trials.adobe.com/AdobeProducts/APRO/Acrobat_HelpX/win32/Acrobat_DC_Web_WWMUI.zip"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeProArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $AdobeProArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msp" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Copy-Item -Path "$PSScriptRoot\$Product\*.cab" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Include *.msp, *.log, Version.txt, Download* -Exclude *.msi, *.cab -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $AdobeProArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            If (!(Test-Path "$PSScriptRoot\$Product\AcroPro.msi" -PathType leaf)) {
                Write-Host "Starting download of $Product installer"
                If ($WhatIf -eq '0') {
                    Get-Download $InstallerURL "$PSScriptRoot\$Product\" "AcrobatDCWeb.zip" -includeStats
                    expand-archive -path "$PSScriptRoot\$Product\AcrobatDCWeb.zip" -destinationpath "$PSScriptRoot\$Product"
                    Remove-Item -Path "$PSScriptRoot\$Product\AcrobatDCWeb.zip" -Force
                    Move-Item -Path "$PSScriptRoot\$Product\Adobe Acrobat\AcroPro.msi" -Destination "$PSScriptRoot\$Product" -ErrorAction SilentlyContinue
                    Move-Item -Path "$PSScriptRoot\$Product\Adobe Acrobat\Data1.cab" -Destination "$PSScriptRoot\$Product" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\$Product\Adobe Acrobat" -Force -Recurse
                }
                Write-Host -ForegroundColor Green "Download of the installer finished!"
            }
            Write-Verbose "Stop logging"
            Stop-Transcript | Out-Null
            Write-Output ""
            $PackageNameP = "AcrobatADMTemplate"
            $URL = "https://ardownload2.adobe.com/pub/adobe/acrobat/win/AcrobatDC/misc/AcrobatADMTemplate.zip"
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX files version $VersionP"
            If ($WhatIf -eq '0') {
                Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($SourceP))
                expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\AcrobatDC.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\AcrobatDC.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\AcrobatDC.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\en-US\AcrobatDC.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\AcrobatDC.adm" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\en-US" -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Adobe Reader DC
    If ($AdobeReaderDC -eq 1) {
        $Product = "Adobe Reader DC"
        $PackageName = "Adobe_Reader_DC_"
        $AdobeReaderD = Get-EvergreenApp -Name AdobeAcrobatReaderDC | Where-Object {$_.Language -eq "$AdobeLanguageClear" -and $_.Architecture -eq "$AdobeArchitectureClear"}
        $Version = $AdobeReaderD.Version
        $URL = $AdobeReaderD.uri
        #If ($AdobeArchitectureClear -eq "x64" -and $AdobeLanguageClear -ne "MUI") {
        #    If ($AdobeLanguageClear -eq "German" -or $AdobeLanguageClear -eq "English" -or $AdobeLanguageClear -eq "French" -or $AdobeLanguageClear -eq "Japanese" -or $AdobeLanguageClear -eq "Spanish") {
        #        $Adobex64URL = $URL.Replace("reader", "acrobat")
        #        $URL = $Adobex64URL.Replace("AcroRdrDC", "AcroRdrDCx64")
        #    } else {
        #        $AdobeReaderDx64 = Get-EvergreenApp -Name AdobeAcrobatReaderDC | Where-Object {$_.Language -eq "MUI" -and $_.Architecture -eq "x64"}
        #        $URLx64 = $AdobeReaderDx64.uri
        #        $Version = $AdobeReaderDx64.Version
        #        $URLsplit = $URL.Split("_")
        #        $URLx64split = $URLx64.Split("_")[0]
        #        $URL = $URLx64split + "_" + $URLsplit[1] + "_" + $URLsplit[2]
        #    }
        #}
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "$AdobeArchitectureClear" + "$AdobeLanguageClear" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeArchitectureClear" + "_$AdobeLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $AdobeLanguageClear $AdobeArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $AdobeLanguageClear $AdobeArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            $PackageNameP = "ReaderTemplate"
            $ReaderDP = Get-AdobeAcrobatReaderDCAdmx
            $VersionP = $ReaderDP.version
            $URL = $ReaderDP.uri
            $URL = $URL.Split(":")[1]
            $URL = "http:" + "$URL"
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX files version $VersionP"
            If ($WhatIf -eq '0') {
                Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($SourceP))
                expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\AcrobatReaderDC.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\AcrobatReaderDC.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\AcrobatReaderDC.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\en-US\AcrobatReaderDC.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\en-US" -Force -Recurse
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Adopt Open JDK
    If ($AdoptOpenJDK -eq 1) {
        $Product = "Adopt Open JDK"
        $PackageName = "AdoptOpenJDK_" + "$AdoptOpenJDKVersionClear" + "_$AdoptOpenJDKArchitectureClear"
        Switch ($AdoptOpenJDKVersionClear) {
            8 { $AdoptOpenJDKD = Get-EvergreenApp -Name AdoptOpenJDK8 | Where-Object {$_.Architecture -eq $AdoptOpenJDKArchitectureClear -and $_.URI -like "*-jdk*"}
                $regexVersion = "openj9_8u.*"
                $webVersion = $AdoptOpenJDKD.uri | Select-String -Pattern $regexVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $appVersion = $webVersion.Split("_")[1]
                $Version = $appVersion -replace('u','.0.')
                $Version = $Version -replace('b','.')
            }
            11 { 
                $AdoptOpenJDKArchitectureClear = "x64"
                $AdoptOpenJDKD = Get-EvergreenApp -Name AdoptOpenJDK11 | Where-Object {$_.Architecture -eq $AdoptOpenJDKArchitectureClear -and $_.URI -like "*-jdk*"
                $Version = $AdoptOpenJDKD.Version
                $Version = $Version -replace('.','.')
            }
            }
            16 {
                $AdoptOpenJDKArchitectureClear = "x64"
                $AdoptOpenJDKD = Get-EvergreenApp -Name AdoptOpenJDK16 | Where-Object {$_.Architecture -eq $AdoptOpenJDKArchitectureClear -and $_.URI -like "*-jdk*"}
                $regexVersion = "openj9_16.*"
                $webVersion = $AdoptOpenJDKD.uri | Select-String -Pattern $regexVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $Version = $webVersion.Split("_")[1] + "." + $webVersion.Split("_")[2]
            }
        }
        $URL = $AdoptOpenJDKD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdoptOpenJDKVersionClear" + "_$AdoptOpenJDKArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $AdoptOpenJDKVersionClear $AdoptOpenJDKArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting Download of $Product $AdoptOpenJDKVersionClear $AdoptOpenJDKArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
        #// Mark: Download Adopt Open JDK Iced Tea Web
        If ($AdoptOpenJDKIcedTeaWeb -eq 1) {
            $Product = "Adopt Open JDK Iced Tea Web"
            $PackageName = "AdoptOpenJDKIcedTeaWeb"
    	    $AdoptOpenJDKITWD = Get-EvergreenApp -Name AdoptOpenJDKIcedTeaWeb | Where-Object {$_.Type -eq "msi"}
            $Version = $AdoptOpenJDKITWD.Version
            $URL = $AdoptOpenJDKITWD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version.txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting Download of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Autodesk DWG TrueView
    If ($AutodeskDWGTrueView -eq 1) {
        $Product = "Autodesk DWG TrueView"
        $PackageName = "AutodeskDWGTrueView"
        $AutodeskDWGTrueViewD = Get-DWGTrueView
        $Version = $AutodeskDWGTrueViewD.Version
        $URL = $AutodeskDWGTrueViewD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download BIS-F
    If ($BISF -eq 1) {
        $Product = "BIS-F"
        $PackageName = "setup-BIS-F"
        $BISFD = Get-EvergreenApp -Name BISF | Where-Object { $_.Type -eq "msi" }
        $Version = $BISFD.Version
        $URL = $BISFD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -exclude SDelete,DelProf2,Citrix Optimizer
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
        If ($BISF_Tools -eq 1) {
            Write-Host -ForegroundColor Magenta "Download BIS-F Additional Tools"
            $Product1 = "Citrix Optimizer"
            $Product2 = "SDelete"
            $Product3 = "DelProf2"
            $PackageName1 = "CitrixOptimizer"
            $PackageName2 = "SDelete"
            $PackageName3 = "DelProf2"
            $CitrixOptimizerD = Get-CitrixOptimizer
            #$Version1 = $CitrixOptimizerD.Version
            #$URL1 = $CitrixOptimizerD.uri
            $URL1 = "https://www.deyda.net/wp-content/uploads/2023/12/CitrixOptimizerTool.zip"
            $Version1 = "3.2.1.1"
            Add-Content -Path "$FWFile" -Value "$URL1"
            $InstallerType1 = "zip"
            $Source1 = "$PackageName1" + "." + "$InstallerType1"
            $CurrentVersion1 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product1\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product1"
            Write-Host "Download Version: $Version1"
            Write-Host "Current Version:  $CurrentVersion1"
            If ($CurrentVersion1 -lt $Version1) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\BIS-F\$Product1")) { New-Item -Path "$PSScriptRoot\BIS-F\$Product1" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\BIS-F\$Product1\" + "$Product1 $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion1) {
                            Write-Host "Copy $Product1 installer version $CurrentVersion1 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product1")) { New-Item -Path "$PSScriptRoot\_Repository\$Product1" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product1\$CurrentVersion1")) { New-Item -Path "$PSScriptRoot\_Repository\$Product1\$CurrentVersion1" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\BIS-F\$Product1\$Product1\" -Destination "$PSScriptRoot\_Repository\$Product1\$CurrentVersion1" -ErrorAction SilentlyContinue -Recurse
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion1 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\BIS-F\$Product1\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\BIS-F\$Product1\Version.txt" -Value "$Version1"
                }
                Write-Host "Starting download of $Product1 version $Version1"
                If ($WhatIf -eq '0') {
                    Get-Download $URL1 "$PSScriptRoot\BIS-F\$Product1\" $Source1 -includeStats
                    expand-archive -path "$PSScriptRoot\BIS-F\$Product1\$Source1" -destinationpath "$PSScriptRoot\BIS-F\$Product1\$Product1"
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product1\$Source1" -Force
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version1 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            $SDeleteD = Get-SDelete
            $Version2 = $SDeleteD.Version
            $URL2 = $SDeleteD.uri
            Add-Content -Path "$FWFile" -Value "$URL2"
            $InstallerType2 = "zip"
            $Source2 = "$PackageName2" + "." + "$InstallerType2"
            $CurrentVersion2 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product2\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product2"
            Write-Host "Download Version: $Version2"
            Write-Host "Current Version:  $CurrentVersion2"
            If ($CurrentVersion2 -lt $Version2) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\BIS-F\$Product2")) { New-Item -Path "$PSScriptRoot\BIS-F\$Product2" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\BIS-F\$Product2\" + "$Product2 $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion2) {
                            Write-Host "Copy $Product2 installer version $CurrentVersion2 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product2")) { New-Item -Path "$PSScriptRoot\_Repository\$Product2" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2")) { New-Item -Path "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\BIS-F\$Product2\*.exe" -Destination "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\BIS-F\$Product2\*" -Exclude *.ps1, *.lnk -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\BIS-F\$Product2\Version.txt" -Value "$Version2"
                }
                Write-Host "Starting download of $Product2 version $Version2"
                If ($WhatIf -eq '0') {
                    Get-Download $URL2 "$PSScriptRoot\BIS-F\$Product2\" $Source2 -includeStats
                    expand-archive -path "$PSScriptRoot\BIS-F\$Product2\$Source2" -destinationpath "$PSScriptRoot\BIS-F\$Product2"
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product2\$Source2" -Force
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product2\sdelete64a.exe" -Force
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product2\sdelete.exe" -Force
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product2\Eula.txt" -Force
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version2 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            $DelProf2D = Get-DelProf2
            $Version3 = $DelProf2D.Version
            $URL3 = $DelProf2D.uri
            Add-Content -Path "$FWFile" -Value "$URL3"
            $InstallerType3 = "zip"
            $Source3 = "$PackageName3" + "." + "$InstallerType3"
            $CurrentVersion3 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product3\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product3"
            Write-Host "Download Version: $Version3"
            Write-Host "Current Version:  $CurrentVersion3"
            If ($CurrentVersion3 -lt $Version3) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\BIS-F\$Product3")) { New-Item -Path "$PSScriptRoot\BIS-F\$Product3" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\BIS-F\$Product3\" + "$Product3 $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion3) {
                            Write-Host "Copy $Product3 installer version $CurrentVersion3 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product3")) { New-Item -Path "$PSScriptRoot\_Repository\$Product3" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product3\$CurrentVersion3")) { New-Item -Path "$PSScriptRoot\_Repository\$Product3\$CurrentVersion3" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\BIS-F\$Product3\*.zip" -Destination "$PSScriptRoot\_Repository\$Product3\$CurrentVersion3" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion3 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\BIS-F\$Product3\*" -Exclude *.ps1, *.lnk -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\BIS-F\$Product3\Version.txt" -Value "$Version3"
                }
                Write-Host "Starting download of $Product3 version $Version3"
                If ($WhatIf -eq '0') {
                    Get-Download $URL3 "$PSScriptRoot\BIS-F\$Product3\" $Source3 -includeStats
                    expand-archive -path "$PSScriptRoot\BIS-F\$Product3\$Source3" -destinationpath "$PSScriptRoot\BIS-F\$Product3"
                    $DelProf2Path = "Delprof2 " + $Version3 + "\DelProf2.exe"
                    $DelProf2Path2 = "Delprof2 " + $Version3
                    Move-Item -Path "$PSScriptRoot\BIS-F\$Product3\$DelProf2Path" -Destination "$PSScriptRoot\BIS-F\$Product3" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product3\$DelProf2Path2" -Force -Recurse
                    Remove-Item -Path "$PSScriptRoot\BIS-F\$Product3\$Source3" -Force
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version3 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Bloomberg Terminal
    If ($Bloomberg -eq 1) {
        $Product = "Bloomberg Terminal"
        $PackageName = "sotr"
        $BloombergD = Get-Bloomberg
        $Version = $BloombergD.Version
        $URL = $BloombergD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Cisco Webex Teams
    If ($CiscoWebexTeams -eq 1) {
        If ($CiscoWebexTeamsClient -eq "0") {
            $Product = "Cisco Webex Teams"
            $PackageName = "webexteams-" + "$CiscoWebexTeamsArchitectureClear"
            $WebexTeamsD = Get-CiscoWebex | Where-Object { $_.Architecture -eq "$CiscoWebexTeamsArchitectureClear"}
            $Version = $WebexTeamsD.Version
            $CiscoSplit = $Version.split(".")
            $CiscoStringMiddle = ([regex]::Matches($CiscoSplit[1], "." )).count
            If ($CiscoStringMiddle -lt "2") {
                $CiscoSplit[1] = "0" + $CiscoSplit[1]
                $Version = $CiscoSplit[0] + "." + $CiscoSplit[1] + "." + $CiscoSplit[2] + "." + $CiscoSplit[3]
            }
            $URL = $WebexTeamsD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            $CiscoCurrentSplit = $CurrentVersion.split(".")
            $CiscoCurrentStringMiddle = ([regex]::Matches($CiscoCurrentSplit[1], "." )).count
            If ($CiscoCurrentStringMiddle -lt "2") {
                $CiscoCurrentSplit[1] = "0" + $CiscoCurrentSplit[1]
                $CurrentVersion = $CiscoCurrentSplit[0] + "." + $CiscoCurrentSplit[1] + "." + $CiscoCurrentSplit[2] + "." + $CiscoCurrentSplit[3]
            }
            Write-Host -ForegroundColor Magenta "Download $Product $CiscoWebexTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product $CiscoWebexTeamsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
        If ($CiscoWebexTeamsClient -eq "1") {
            $Product = "Cisco Webex Teams VDI Plugin"
            $PackageName = "webexteamsvdiplugin-" + "$CiscoWebexTeamsArchitectureClear"
            $WebexTeamsVDID = Get-CiscoWebexVDI | Where-Object { $_.Architecture -eq "$CiscoWebexTeamsArchitectureClear" }
            $Version = $WebexTeamsVDID.Version
            $URL = $WebexTeamsVDID.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product $CiscoWebexTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product $CiscoWebexTeamsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Citrix Files
    If ($CitrixFiles -eq 1) {
        $Product = "Citrix Files"
        $PackageName = "CitrixFilesForWindows"
        $CitrixFilesD = Get-NevergreenApp -Name CitrixFiles | Where-Object {$_.Type -eq "Msi"}
        $Version = $CitrixFilesD.Version
        $URL = $CitrixFilesD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\Citrix\$Product")) { New-Item -Path "$PSScriptRoot\Citrix\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\Citrix\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\Citrix\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\Citrix\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting Download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\Citrix\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Citrix Hypervisor Tools
    If ($Citrix_Hypervisor_Tools -eq 1) {
        $Product = "Citrix Hypervisor Tools"
        $PackageName = "managementagent" + "$CitrixHypervisorToolsArchitectureClear"
        $CitrixHypervisor = Get-EvergreenApp -Name CitrixVMTools | Where-Object {$_.Architecture -eq "$CitrixHypervisorToolsArchitectureClear"} | Select-Object -Last 1
        $Version = $CitrixHypervisor.Version
        $URL = $CitrixHypervisor.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version_" + "$CitrixHypervisorToolsArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $CitrixHypervisorToolsArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\Citrix\$Product")) { New-Item -Path "$PSScriptRoot\Citrix\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\Citrix\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\Citrix\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\Citrix\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting Download of $Product $CitrixHypervisorToolsArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\Citrix\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Citrix WorkspaceApp
    If ($Citrix_WorkspaceApp -eq 1) {
        $Product = "Citrix WorkspaceApp $CitrixWorkspaceAppReleaseClear"
        Switch ($CitrixWorkspaceAppRelease) {
            0 {$PackageName = "CitrixWorkspaceApp"}
            1 {$PackageName = "CitrixWorkspaceApp"}
            2 {$PackageName = "CitrixWorkspaceAppWeb"}
            3 {$PackageName = "CitrixWorkspaceAppWeb"}
        }
        If ($CitrixWorkspaceAppReleaseClear -eq "Current") {
            #$WSACD = Get-WorkspaceAppCurrent
            $WSACD = Get-EvergreenApp -Name CitrixWorkspaceApp -WarningAction:SilentlyContinue | Where-Object { $_.Stream -like "*$CitrixWorkspaceAppReleaseClear*" }
        } else {
            $WSACD = Get-EvergreenApp -Name CitrixWorkspaceApp -WarningAction:SilentlyContinue | Where-Object { $_.Stream -like "*$CitrixWorkspaceAppReleaseClear*" }
        }
        $Version = $WSACD.version
        If ($Version -eq "0.0.0.0") {
            $SplitVersion = $WSACD.uri
            $SplitVersion = $SplitVersion.split("/")
            $SplitVersion = $SplitVersion[7].split("p")
            $SplitVersion = $SplitVersion[3].split(".")
            $Version = $SplitVersion[0] + "." + $SplitVersion[1] + "." + $SplitVersion[2] + "." + $SplitVersion[3]
        }
        If ($Version) {
            $CurrentWSASplit = $Version.split(".")
            $CurrentWSAStrings = ([regex]::Matches($Version, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            $CurrentWSAStringLast = ([regex]::Matches($CurrentWSASplit[3], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            If ($CurrentWSAStringLast -lt "3") {
                $CurrentWSASplit[3] = "0" + $CurrentWSASplit[3]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $URL = $WSACD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\Citrix\$Product\Version.txt" -EA SilentlyContinue
        If ($CurrentVersion) {
            $CurrentWSASplit = $CurrentVersion.split(".")
            $CurrentWSAStrings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            $CurrentWSAStringLast = ([regex]::Matches($CurrentWSASplit[3], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            If ($CurrentWSAStringLast -lt "3") {
                $CurrentWSASplit[3] = "0" + $CurrentWSASplit[3]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        If ($WhatIf -eq '0') {
            If (!(Test-Path -Path "$PSScriptRoot\Citrix\ReceiverCleanupUtility")) { New-Item -Path "$PSScriptRoot\Citrix\ReceiverCleanupUtility" -ItemType Directory | Out-Null }
        }
        If (!(Test-Path -Path "$PSScriptRoot\Citrix\ReceiverCleanupUtility\ReceiverCleanupUtility.exe")) {
            Write-Host -ForegroundColor Magenta "Download Citrix Receiver Cleanup Utility"
            If ($WhatIf -eq '0') {
                Get-Download https://fileservice.citrix.com/downloadspecial/support/article/CTX137494/downloads/ReceiverCleanupUtility.zip "$PSScriptRoot\Citrix\ReceiverCleanupUtility\" ReceiverCleanupUtility.zip
                Expand-Archive -path "$PSScriptRoot\Citrix\ReceiverCleanupUtility\ReceiverCleanupUtility.zip" -destinationpath "$PSScriptRoot\Citrix\ReceiverCleanupUtility\"
                Remove-Item -Path "$PSScriptRoot\Citrix\ReceiverCleanupUtility\ReceiverCleanupUtility.zip" -Force
            }
            Write-Host -ForegroundColor Green "Download Citrix Receiver Cleanup Utility finished!"
            Write-Output ""
        }
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\Citrix\$Product")) { New-Item -Path "$PSScriptRoot\Citrix\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\Citrix\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\Citrix\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\Citrix\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\Citrix\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\Citrix\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            $PackageNameP = "CitrixWorkspace_ADMX"
            If ($CitrixWorkspaceAppReleaseClear -eq "Current") {
                $CWADP = Get-CitrixWorkspaceAppCurrentAdmx
            }
            else {
                $CWADP = Get-CitrixWorkspaceAppLTSRAdmx
            }
            $URL = $CWADP.uri
            $Path = $CWADP.path
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            If ($CitrixWorkspaceAppReleaseClear -eq "Current") {
                $CWAPath = "CitrixWorkspace_ADMX_Files_" + "$Path"
                $CWASubFolderPath = "$CWAPath" + "\Configuration"
            }
            else {
                $CWAPath = "CitrixWorkspace_ADMX_ADML_Files_" + "$Path"
                $CWASubFolderPath = "$CWAPath"
            }
            Write-Host "Starting download of $Product ADMX files version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\Citrix\$Product\" $SourceP -includeStats
                expand-archive -path "$PSScriptRoot\Citrix\$Product\$SourceP" -destinationpath "$PSScriptRoot\Citrix\$Product"
                Remove-Item -Path "$PSScriptRoot\Citrix\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\CitrixBase.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\receiver.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\en-US\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\en-US\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\de-DE\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\de-DE\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\es-ES\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\es-ES\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\fr-FR\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\fr-FR\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\it-IT\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\it-IT\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ja-JP")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ja-JP\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ja-JP\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ja-JP\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\nl-NL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\nl-NL\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\nl-NL\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\nl-NL\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ko-KR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ko-KR\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ko-KR\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ko-KR\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-BR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-BR\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\pt-BR\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\pt-BR\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ru-RU\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\ru-RU\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\receiver.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\receiver.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\CitrixBase.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\zh-CN\receiver.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\Citrix\$Product\$CWASubFolderPath\zh-CN\CitrixBase.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\Citrix\$Product\$CWAPath" -Force -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ControlUp Agent
    If ($ControlUpAgent -eq 1) {
        $Product = "ControlUp Agent"
        $PackageName = "ControlUpAgent-" + "$ControlUpAgentArchitectureClear"
        $ControlUpAgentD = Get-EvergreenApp -Name ControlUpAgent | Where-Object {$_.ARchitecture -eq "$ControlUpAgentArchitectureClear" }
        $Version = $ControlUpAgentD.Version
        $URL = $ControlUpAgentD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpAgentArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CUASplit = $CurrentVersion.split(".")
        $CUCount = ([regex]::Matches($CUASplit[3], "." )).count
        If ($CUCount -lt "3") {
            $CUASplit[3] = "0" + $CUASplit[3]
            $CurrentVersion = $CUASplit[0] + "." + $CUASplit[1] + "." + $CUASplit[2] + "." + $CUASplit[3]
        }
        
        Write-Host -ForegroundColor Magenta "Download $Product $ControlUpAgentArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $ControlUpAgentArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ControlUp Edge DX
    If ($ControlUpEdgeDX -eq 1) {
        $Product = "ControlUp Edge DX Agent Manager"
        $PackageName = "ControlUpEdgeDX-AgentManagerSetup"
        $ControlUpEdgeDXD = Get-ControlUpEdgeDX
        $Version = $ControlUpEdgeDXD.Version
        $URL = $ControlUpEdgeDXD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse -Exclude "DevRegCode.txt, TenantName.txt"
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ControlUp Remote DX
    If ($ControlUpRemoteDX -eq 1) {
        $Product = "ControlUp Remote DX"
        $PackageName = "CURDX_Windows_"
        $CURDXD = Get-ControlUpRemoteDX | Where-Object { $_.Environment -eq "$ControlUpRemoteDXEUCClear"}
        $Version = $CURDXD.Version
        $URL = $CURDXD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "$ControlUpRemoteDXEUCDLClear" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpRemoteDXEUCClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product for $ControlUpRemoteDXEUCClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product for $ControlUpRemoteDXEUCClear installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product for $ControlUpRemoteDXEUCClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ControlUp Console
    If ($ControlUpConsole -eq 1) {
        $Product = "ControlUp Console"
        $PackageName = "ControlUpConsole"
        $ControlUpConsoleD = Get-EvergreenApp -Name ControlUpConsole
        $Version = $ControlUpConsoleD.Version
        $URL = $ControlUpConsoleD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "zip"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product" $Source -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$Source" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$Source" -Force
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download deviceTRUST
    If ($deviceTRUST -eq 1) {
        $Product = "deviceTRUST"
        $PackageName = "deviceTRUST"
        $deviceTRUSTD = Get-EvergreenApp -Name deviceTRUST | Where-Object { $_.Platform -eq "Windows" -and $_.Type -eq "Bundle" } | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $deviceTRUSTD.Version
        $URL = $deviceTRUSTD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "zip"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$deviceTRUSTArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $deviceTRUSTArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $deviceTRUSTArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                expand-archive -path "$PSScriptRoot\$Product\deviceTRUST.zip" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\deviceTRUST.zip" -Force
                Remove-Item -Path "$PSScriptRoot\$Product\dtreporting-$Version.zip" -Force
                If (Test-Path -Path "$PSScriptRoot\$Product\dtdemotool-release-$Version.exe") {Remove-Item -Path "$PSScriptRoot\$Product\dtdemotool-release-$Version.exe" -Force}
                Switch ($deviceTRUSTArchitectureClear) {
                    x64 {
                        Get-ChildItem -Path "$PSScriptRoot\$Product" | Where-Object Name -like *"x86"* | Remove-Item
                        Rename-Item -Path "$PSScriptRoot\$Product\dtclient-extension-release-$Version.exe" -NewName "dtclient-extension-release.exe"
                        Rename-Item -Path "$PSScriptRoot\$Product\dtconsole-x64-release-$Version.msi" -NewName "dtconsole-x64-release.msi"
                        Rename-Item -Path "$PSScriptRoot\$Product\dtagent-x64-release-$Version.msi" -NewName "dtagent-x64-release.msi"
                    }
                    x86 {
                        Get-ChildItem -Path "$PSScriptRoot\$Product" | Where-Object Name -like *"x64"* | Remove-Item
                        Rename-Item -Path "$PSScriptRoot\$Product\dtclient-extension-release-$Version.exe" -NewName "dtclient-extension-release.exe"
                        Rename-Item -Path "$PSScriptRoot\$Product\dtconsole-x86-release-$Version.msi" -NewName "dtconsole-x86-release.msi"
                        Rename-Item -Path "$PSScriptRoot\$Product\dtagent-x86-release-$Version.msi" -NewName "dtagent-x86-release.msi"
                    }
                }
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            Write-Host "Starting copy of $Product ADMX files version $Version"
            If ($WhatIf -eq '0') {
                expand-archive -path "$PSScriptRoot\$Product\dtpolicydefinitions-$Version.zip" -destinationpath "$PSScriptRoot\$Product\_ADMX"
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\_ADMX\deviceTRUST.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\deviceTRUST.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\deviceTRUST.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\_ADMX\en-US\deviceTRUST.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\dtpolicydefinitions-$Version.zip" -Force
                Remove-Item -Path "$PSScriptRoot\$Product\_ADMX" -Force -Recurse
            }
            Write-Host -ForegroundColor Green "Copy of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Ditto
    If ($Ditto -eq 1) {
        $Product = "Ditto"
        $PackageName = "Ditto-Setup-" + "$DittoArchitectureClear" + "-$DittoChannelClear"
        $DittoD = Get-Ditto | Where-Object { $_.Architecture -eq "$DittoArchitectureClear" -and $_.Channel -eq "$DittoChannelClear"}
        $Version = $DittoD.Version
        $URL = $DittoD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$DittoArchitectureClear" + "_$DittoChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $DittoChannelClear channel $DittoArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $DittoChannelClear channel $DittoArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($Source))
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Filezilla
    If ($Filezilla -eq 1) {
        $Product = "Filezilla"
        $PackageName = "Filezilla-win64"
        $FilezillaD = Get-EvergreenApp -Name Filezilla | Where-Object { $_.URI -like "*win64*"}
        $Version = $FilezillaD.Version
        $URL = $FilezillaD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($Source)) -UserAgent 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36'
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Foxit PDF Editor
    If ($FoxitPDFEditor -eq 1) {
        $Product = "Foxit PDF Editor"
        $PackageName = "FoxitPDFEditor-Setup-" + "$FoxitPDFEditorLanguageClear"
        $FoxitPDFEditorD = Get-EvergreenApp -Name FoxitPDFEditor -WarningAction:SilentlyContinue | Where-Object {$_.Language -eq "$FoxitPDFEditorLanguageClear"}
        $Version = $FoxitPDFEditorD.Version
        $URL = $FoxitPDFEditorD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitPDFEditorLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $FoxitPDFEditorLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $FoxitPDFEditorLanguageClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Foxit Reader
    If ($Foxit_Reader -eq 1) {
        $Product = "Foxit Reader"
        $PackageName = "FoxitReader-Setup-" + "$FoxitReaderLanguageClear"
        $Foxit_ReaderD = Get-EvergreenApp -Name FoxitReader | Where-Object {$_.Language -eq "$FoxitReaderLanguageClear"}
        $Version = $Foxit_ReaderD.Version
        $URL = $Foxit_ReaderD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitReaderLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $FoxitReaderLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $FoxitReaderLanguageClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download GIMP
    If ($GIMP -eq 1) {
        $Product = "GIMP"
        $PackageName = "gimp-setup"
        $GIMPD = Get-EvergreenApp -Name GIMP | Where-Object {$_.Channel -eq "Stable"}
        $Version = $GIMPD.Version
        $URL = $GIMPD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Git for Windows
    If ($GitForWindows -eq 1) {
        $Product = "Git for Windows"
        $PackageName = "GitForWindows_" + "$GitForWindowsArchitectureClear"
        $GitForWindowsD = Get-EvergreenApp -Name GitForWindows | Where-Object {$_.Architecture -eq "$GitForWindowsArchitectureClear" -and $_.Type -eq "exe" -and $_.URI -like "*bit.exe"}
        $Version = $GitForWindowsD.Version
        $URL = $GitForWindowsD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GitForWindowsArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $GitForWindowsArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $GitForWindowsArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Google Chrome
    If ($GoogleChrome -eq 1) {
        $Product = "Google Chrome"
        $PackageName = "googlechromestandaloneenterprise_" + "$GoogleChromeArchitectureClear" + "_$GoogleChromeChannelClear"
        $ChromeD = Get-EvergreenApp -Name GoogleChrome | Where-Object { $_.Architecture -eq "$GoogleChromeArchitectureClear" -and $_.Channel -eq "$GoogleChromeChannelClear" -and $_.Type -eq "msi"}
        $Version = $ChromeD.Version
        $ChromeSplit = $Version.split(".")
        $ChromeStrings = ([regex]::Matches($Version, "\." )).count
        $ChromeStringLast = ([regex]::Matches($ChromeSplit[$ChromeStrings], "." )).count
        If ($ChromeStringLast -lt "3") {
            $ChromeSplit[$ChromeStrings] = "0" + $ChromeSplit[$ChromeStrings]
        }
        Switch ($ChromeStrings) {
            1 {
                $NewChromeVersion = $ChromeSplit[0] + "." + $ChromeSplit[1]
            }
            2 {
                $NewChromeVersion = $ChromeSplit[0] + "." + $ChromeSplit[1] + "." + $ChromeSplit[2]
            }
            3 {
                $NewChromeVersion = $ChromeSplit[0] + "." + $ChromeSplit[1] + "." + $ChromeSplit[2] + "." + $ChromeSplit[3]
            }
        }
        $URL = $ChromeD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GoogleChromeArchitectureClear" + "_$GoogleChromeChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersion) {
            $CurrentChromeSplit = $CurrentVersion.split(".")
            $CurrentChromeStrings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentChromeStringLast = ([regex]::Matches($CurrentChromeSplit[$CurrentChromeStrings], "." )).count
            $CurrentChromeStringFirst = ([regex]::Matches($CurrentChromeSplit[0], "." )).count
            If ($CurrentChromeStringLast -lt "3") {
                $CurrentChromeSplit[$CurrentChromeStrings] = "0" + $CurrentChromeSplit[$CurrentChromeStrings]
            }
            If ($CurrentChromeStringFirst -lt "3") {
                $CurrentChromeSplit[0] = "0" + $CurrentChromeSplit[0]
            }
            Switch ($CurrentChromeStrings) {
                1 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1] + "." + $CurrentChromeSplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentChromeSplit[0] + "." + $CurrentChromeSplit[1] + "." + $CurrentChromeSplit[2] + "." + $CurrentChromeSplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear"
        Write-Host "Download Version: $NewChromeVersion"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $NewChromeVersion) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear version $NewChromeVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $NewChromeVersion finished!"
            Write-Output ""
            $PackageNameP = "Chrome-Templates"
            $ChromeDP = Get-GoogleChromeAdmx
            $VersionP = $ChromeDP.version
            $URL = $ChromeDP.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX files version $VersionP"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\google.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\chrome.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\en-US\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\en-US\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\de-DE\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\de-DE\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\es-ES\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\es-ES\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fr-FR\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fr-FR\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\it-IT\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\it-IT\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ja-JP")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ja-JP\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ja-JP\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ja-JP\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\nl-NL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\nl-NL\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nl-NL\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nl-NL\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ko-KR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ko-KR\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ko-KR\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ko-KR\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-BR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-BR\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-BR\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-BR\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ru-RU\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ru-RU\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\chrome.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\google.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\chrome.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\zh-CN\chrome.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\zh-CN\google.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\common" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\chromeos" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\VERSION" -Force -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\windows" -Force -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Google Drive
    If ($GoogleDrive -eq 1) {
        $Product = "Google Drive"
        $PackageName = "GoogleDrive"
        $GoogleDriveD = Get-NevergreenApp -Name GoogleDrive
        $Version = $GoogleDriveD.Version
        $URL = $GoogleDriveD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Greenshot
    If ($Greenshot -eq 1) {
        $Product = "Greenshot"
        $PackageName = "Greenshot-INSTALLER-x86"
        $GreenshotD = Get-EvergreenApp -Name Greenshot | Where-Object { $_.Architecture -eq "x86" -and $_.URI -like "*INSTALLER*" -and $_.Type -like "exe"}
        $Version = $GreenshotD.Version
        $URL = $GreenshotD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download IIS Crypto
    If ($IISCrypto -eq 1) {
        $Product = "IIS Crypto"
        $PackageName = "IISCrypto"
        $IISCryptoD = Get-IISCrypto
        $Version = $IISCryptoD.Version
        $URL = $IISCryptoD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ImageGlass
    If ($ImageGlass -eq 1) {
        $Product = "ImageGlass"
        $PackageName = "ImageGlass_" + "$ImageGlassArchitectureClear"
        $ImageGlassD = Get-EvergreenApp -Name ImageGlass | Where-Object { $_.Architecture -eq "x64" -and $_.URI -notlike "*delete*"  }
        $Version = $ImageGlassD.Version
        $URL = $ImageGlassD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ImageGlassArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $ImageGlassArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -ne $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $ImageGlassArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download IrfanView
    If ($IrfanView -eq 1) {
        $Product = "IrfanView"
        $PackageName = "IrfanView" + "$IrfanViewArchitectureClear"
        $IrfanViewD = Get-IrfanView | Where-Object {$_.Architecture -eq "$IrfanViewArchitectureClear"}
        $Version = $IrfanViewD.Version
        $URL = $IrfanViewD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$IrfanViewArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path $VersionPath -EA SilentlyContinue 
        Write-Host -ForegroundColor Magenta "Download $Product $IrfanViewLanguageLongClear $IrfanViewArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $IrfanViewArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            If ($IrfanViewLanguageLongClear -ne "English") {
                $IrfanViewLD = Get-NevergreenApp -Name IrfanView | Where-Object {$_.Language -eq "$IrfanViewLanguageClear" -and $_.Type -eq "Zip"}
                $VersionL = $IrfanViewLD.Version
                $URLL = $IrfanViewLD.uri
                $PackageNameL = "IrfanView_lang_" + "$IrfanViewLanguageLongClear"
                $SourceL = "$PackageNameL" + ".zip"
                Write-Host "Starting download of $Product $IrfanViewLanguageLongClear language pack version $VersionL"
                If ($WhatIf -eq '0') {
                    Get-Download $URLL "$PSScriptRoot\$Product\" $SourceL -includeStats
                    expand-archive -path "$PSScriptRoot\$Product\$SourceL" -destinationpath "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear"
                    Remove-Item "$PSScriptRoot\$Product\$SourceL"
                }
                Write-Host -ForegroundColor Green "Download of the $IrfanViewLanguageLongClear language pack version $VersionL finished!"
            }
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Jabra Direct
    If ($JabraDirect -eq 1) {
        $Product = "Jabra Direct"
        $PackageName = "JabraDirect"
        $JabraDirectD = Get-JabraDirect
        $Version = $JabraDirectD.Version
        $URL = $JabraDirectD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download KeePass
    If ($KeePass -eq 1) {
        $Product = "KeePass"
        $PackageName = "KeePass"
        $KeePassD = Get-EvergreenApp -Name KeePass | Where-Object { $_.Type -eq "msi" }
        $Version = $KeePassD.Version
        $URL = $KeePassD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
        Write-Host -ForegroundColor Magenta "Download $Product $KeePassLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            $KeePassLD = Get-KeePassLanguage | Where-Object {$_.Language -eq "$KeePassLanguageClear"}
            $VersionL = $KeePassLD.Version
            $URLL = $KeePassLD.uri
            $PackageNameL = "KeePass-" + "$KeePassLanguageClear"
            $SourceL = "$PackageNameL" + ".zip"
            Write-Host "Starting download of $Product $KeePassLanguageClear language pack version $VersionL"
            If ($WhatIf -eq '0') {
                Get-Download $URLL "$PSScriptRoot\$Product\" $SourceL -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$SourceL" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item "$PSScriptRoot\$Product\$SourceL"
            }
            Write-Host -ForegroundColor Green "Download of the $KeePassLanguageClear language pack version $VersionL finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download LogMeIn GoToMeeting
    If ($LogMeInGoToMeeting -eq 1) {
        If ($LogMeInGoToMeetingInstallerClear -eq 'Machine Based') {
            $Product = "LogMeIn GoToMeeting XenApp"
            $PackageName = "GoToMeeting-Setup"
            $LogMeInGoToMeetingD = Get-EvergreenApp -Name LogMeInGoToMeeting | Where-Object { $_.Type -eq "XenAppLatest" }
            $Version = $LogMeInGoToMeetingD.Version
            $URL = $LogMeInGoToMeetingD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
            Write-Host -ForegroundColor Magenta "Download $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                }
                Write-Host "Starting download of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
        If ($LogMeInGoToMeetingInstallerClear -eq 'User Based') {
            $Product = "LogMeIn GoToMeeting"
            $PackageName = "GoToMeeting-Setup"
            $LogMeInGoToMeetingD = Get-EvergreenApp -Name LogMeInGoToMeeting | Where-Object { $_.Type -eq "Latest" }
            $Version = $LogMeInGoToMeetingD.Version
            $URL = $LogMeInGoToMeetingD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt"-EA SilentlyContinue 
            Write-Host -ForegroundColor Magenta "Download $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                }
                Write-Host "Starting download of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Microsoft .Net Framework
    If ($MSDotNetFramework -eq 1) {
        $Product = "Microsoft Dot Net Framework"
        $PackageName = "NetFramework-runtime_" + "$MSDotNetFrameworkArchitectureClear" + "_$MSDotNetFrameworkChannelClear"
        $MSDotNetFrameworkD = Get-EvergreenApp -Name Microsoft.NET | Where-Object {$_.Architecture -eq "$MSDotNetFrameworkArchitectureClear" -and $_.Channel -eq "$MSDotNetFrameworkChannelClear" -and $_.installer -eq "windowsdesktop" }
        $Version = $MSDotNetFrameworkD.Version
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionStrings = ([regex]::Matches($Version, "\." )).count
            $VersionStringTwo = ([regex]::Matches($VersionSplit[2], "." )).count
            If ($VersionStringTwo -lt "2") {
                $VersionSplit[2] = "0" + $VersionSplit[2]
            }
            Switch ($VersionStrings) {
                1 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1]
                }
                2 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2]
                }
                3 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2] + "." + $VersionSplit[3]
                }
            }
        }
        $URL = $MSDotNetFrameworkD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSDotNetFrameworkArchitectureClear" + "_$MSDotNetFrameworkChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($CurrentVersion) {
            $CurrentSplit = $CurrentVersion.split(".")
            $CurrentStrings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentStringTwo = ([regex]::Matches($CurrentSplit[2], "." )).count
            If ($CurrentStringTwo -lt "2") {
                $CurrentSplit[2] = "0" + $CurrentSplit[2]
            }
            Switch ($CurrentStrings) {
                1 {
                    $CurrentVersion = $CurrentSplit[0] + "." + $CurrentSplit[1]
                }
                2 {
                    $CurrentVersion = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
                3 {
                    $CurrentVersion = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2] + "." + $CurrentSplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft 365 Apps
    If ($MS365Apps -eq 1) {
        $Product = "Microsoft 365 Apps"
        $PackageName = "setup_" + "$MS365AppsChannelClear"
        $MS365AppsD = Get-EvergreenApp -Name Microsoft365Apps | Where-Object {$_.Channel -eq "$MS365AppsChannelClearDL"}
        $Version = $MS365AppsD.Version
        $URL = $MS365AppsD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MS365AppsChannelClear setup file"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        $OldInstall = Select-String -path "$PSScriptRoot\$Product\$MS365AppsChannelClear\install.xml" -pattern "Logging" -quiet
        If ($WhatIf -eq '0') {
            If (!(Test-Path -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear")) {New-Item -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear" -ItemType Directory | Out-Null}
            If (!(Test-Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\remove.xml" -PathType leaf)) {
                Write-Host "Create remove.xml"
                [System.XML.XMLDocument]$XML=New-Object System.XML.XMLDocument
                [System.XML.XMLElement]$Root = $XML.CreateElement("Configuration")
                    $XML.appendChild($Root) | out-null
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Remove"))
                    $Node1.SetAttribute("All","True")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Display"))
                    $Node1.SetAttribute("Level","None")
                    $Node1.SetAttribute("AcceptEULA","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","AUTOACTIVATE")
                    $Node1.SetAttribute("Value","0")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","FORCEAPPSHUTDOWN")
                    $Node1.SetAttribute("Value","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","SharedComputerLicensing")
                    $Node1.SetAttribute("Value","0")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","PinIconsToTaskbar")
                    $Node1.SetAttribute("Value","FALSE")
                $XML.Save("$PSScriptRoot\$Product\$MS365AppsChannelClear\remove.xml")
                Write-Host -ForegroundColor Green "Create remove.xml finished!"
            }
            If ($OldInstall) {
                Remove-Item "$PSScriptRoot\$Product\$MS365AppsChannelClear\install.xml"
            }
            If (!(Test-Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\install.xml" -PathType leaf)) {
                If ($MS365AppsInstallerClear -eq 'Machine Based') {
                    Write-Host "Create install.xml for Machine Based Install"
                    [System.XML.XMLDocument]$XML=New-Object System.XML.XMLDocument
                    [System.XML.XMLElement]$Root = $XML.CreateElement("Configuration")
                        $XML.appendChild($Root) | out-null
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Add"))
                        $Node1.SetAttribute("SourcePath","$PSScriptRoot\$Product\$MS365AppsChannelClear")
                        $Node1.SetAttribute("OfficeClientEdition","$MS365AppsArchitectureClear")
                        $Node1.SetAttribute("Channel","$MS365AppsChannelClearDL")
                    [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","O365ProPlusRetail")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","MatchOS")
                        $Node3.SetAttribute("Fallback","en-us")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","$MS365AppsLanguageClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Teams")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Lync")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Groove")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","OneDrive")
                    If ($MS365Apps_Visio -eq '1') {
                        Write-Host "Add Microsoft Visio to install.xml for Machine Based Install"
                        [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","VisioProRetail")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","MatchOS")
                            $Node3.SetAttribute("Fallback","en-us")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","$MS365AppsVisioLanguageClear")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Teams")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Lync")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Groove")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","OneDrive")
                    }
                    If ($MS365Apps_Project -eq '1') {
                        Write-Host "Add Microsoft Project to install.xml for Machine Based Install"
                        [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","ProjectProRetail")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","MatchOS")
                            $Node3.SetAttribute("Fallback","en-us")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","$MS365AppsProjectLanguageClear")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Teams")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Lync")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Groove")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","OneDrive")
                    }
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Display"))
                        $Node1.SetAttribute("Level","None")
                        $Node1.SetAttribute("AcceptEULA","TRUE")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Logging"))
                        $Node1.SetAttribute("Level","Standard")
                        $Node1.SetAttribute("Path","%temp%")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","SharedComputerLicensing")
                        $Node1.SetAttribute("Value","1")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","FORCEAPPSHUTDOWN")
                        $Node1.SetAttribute("Value","TRUE")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","DeviceBasedLicensing")
                        $Node1.SetAttribute("Value","0")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","AUTOACTIVATE")
                        $Node1.SetAttribute("Value","1")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Updates"))
                        $Node1.SetAttribute("Enabled","FALSE")
                        $XML.Save("$PSScriptRoot\$Product\$MS365AppsChannelClear\install.xml")
                    Write-Host -ForegroundColor Green "Create install.xml for Machine Based Install finished!"
                }
                If ($MS365AppsInstallerClear -eq 'User Based') {
                    Write-Host "Create install.xml for User Based Install"
                    [System.XML.XMLDocument]$XML=New-Object System.XML.XMLDocument
                    [System.XML.XMLElement]$Root = $XML.CreateElement("Configuration")
                        $XML.appendChild($Root) | out-null
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Add"))
                        $Node1.SetAttribute("SourcePath","$PSScriptRoot\$Product\$MS365AppsChannelClear")
                        $Node1.SetAttribute("OfficeClientEdition","$MS365AppsArchitectureClear")
                        $Node1.SetAttribute("Channel","$MS365AppsChannelClearDL")
                    [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","O365ProPlusRetail")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","MatchOS")
                        $Node3.SetAttribute("Fallback","en-us")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","$MS365AppsLanguageClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Teams")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Lync")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Groove")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","OneDrive")
                    If ($MS365Apps_Visio -eq '1') {
                        Write-Host "Add Microsoft Visio to install.xml for User Based Install"
                        [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","VisioProRetail")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","MatchOS")
                            $Node3.SetAttribute("Fallback","en-us")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","$MS365AppsVisioLanguageClear")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Teams")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Lync")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Groove")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","OneDrive")
                    }
                    If ($MS365Apps_Project -eq '1') {
                        Write-Host "Add Microsoft Project to install.xml for User Based Install"
                        [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                        $Node2.SetAttribute("ID","ProjectProRetail")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","MatchOS")
                            $Node3.SetAttribute("Fallback","en-us")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                            $Node3.SetAttribute("ID","$MS365AppsProjectLanguageClear")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Teams")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Lync")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","Groove")
                        [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                            $Node3.SetAttribute("ID","OneDrive")
                    }
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Display"))
                        $Node1.SetAttribute("Level","None")
                        $Node1.SetAttribute("AcceptEULA","TRUE")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Logging"))
                        $Node1.SetAttribute("Level","Standard")
                        $Node1.SetAttribute("Path","%temp%")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","SharedComputerLicensing")
                        $Node1.SetAttribute("Value","0")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                        $Node1.SetAttribute("Name","FORCEAPPSHUTDOWN")
                        $Node1.SetAttribute("Value","TRUE")
                    [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Updates"))
                        $Node1.SetAttribute("Enabled","FALSE")
                        $XML.Save("$PSScriptRoot\$Product\$MS365AppsChannelClear\install.xml")
                    Write-Host -ForegroundColor Green "Create install.xml for User Based Install finished!"
                }
            }
        }
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                $LogPS = "$PSScriptRoot\$Product\$MS365AppsChannelClear\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\$MS365AppsChannelClear\*" -Recurse -Exclude install.xml,remove.xml
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MS365AppsChannelClear version $Version setup file"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\$MS365AppsChannelClear" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version setup file finished!"
            Write-Output ""
            $PackageNameP = "admintemplates-office"
            $MS365AppsPD = Get-MicrosoftOfficeAdmx| Where-Object {$_.Architecture -eq "$MS365AppsArchitecturePolicyClear"}
            $Version = $MS365AppsPD.Version
            $URL = $MS365AppsPD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "exe"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX Files version $Version"
            $InstallDir = "$PSScriptRoot\$Product\$SourceP"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                Start-Process -FilePath "$InstallDir" -ArgumentList "/extract:$env:TEMP /passive /quiet" -wait
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\office16.admx" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse
                }
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                copy-item -Path "$env:TEMP\admx\*" -Destination "$PSScriptRoot\_ADMX\$Product" -Force -Recurse
                copy-item -Path "$env:TEMP\office2016grouppolicyandoctsettings.xlsx" -Destination "$PSScriptRoot\_ADMX\$Product" -Force
                Remove-Item -Path "$InstallDir" -Force
                Remove-Item -Path "$env:TEMP\admx" -Force -Recurse
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft AVD Remote Desktop
    If ($MSAVDRemoteDesktop -eq 1) {
        $Product = "Microsoft AVD Remote Desktop"
        $PackageName = "RemoteDesktop_" + "$MSAVDRemoteDesktopArchitectureClear" + "_$MSAVDRemoteDesktopChannelClear"
        $MSAVDRemoteDesktopD = Get-EvergreenApp -Name MicrosoftWVDRemoteDesktop -WarningAction:SilentlyContinue | Where-Object { $_.Architecture -eq "$MSAVDRemoteDesktopArchitectureClear" -and $_.Channel -eq "$MSAVDRemoteDesktopChannelClear" }
        $Version = $MSAVDRemoteDesktopD.Version
        $URL = $MSAVDRemoteDesktopD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAVDRemoteDesktopChannelClear" + "$MSAVDRemoteDesktopArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Azure CLI
    If ($MSAzureCLI -eq 1) {
        $Product = "Microsoft Azure CLI"
        $PackageName = "AzureCLI"
        $MSAzureCLID = Get-NevergreenApp -Name MicrosoftAzureCLI | Where-Object { $_.Type -eq "Msi" }
        $Version = $MSAzureCLID.Version
        $URL = $MSAzureCLID.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Azure Data Studio
    If ($MSAzureDataStudio -eq 1) {
        $Product = "Microsoft Azure Data Studio"
        $PackageName = "AzureDataStudio-Setup-"
        $MSAzureDataStudioD = Get-EvergreenApp -Name microsoftazuredatastudio | Where-Object { $_.Channel -eq "$MSAzureDataStudioChannelClear" -and $_.Platform -eq "$MSAzureDataStudioPlatformClear"}
        $Version = $MSAzureDataStudioD.Version
        $URL = $MSAzureDataStudioD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Edge
    If ($MSEdge -eq 1) {
        $Product = "Microsoft Edge"
        $PackageName = "MicrosoftEdgeEnterprise_" + "$MSEdgeArchitectureClear" + "_$MSEdgeChannelClear"
        $EdgeD = Get-EvergreenApp -Name MicrosoftEdge | Where-Object { $_.Platform -eq "Windows" -and $_.Release -eq "Consumer" -and $_.Channel -eq "$MSEdgeChannelClear" -and $_.Architecture -eq "$MSEdgeArchitectureClear" }
        $Version = $EdgeD.Version
        $EdgeSplit = $Version.split(".")
        $EdgeStrings = ([regex]::Matches($Version, "\." )).count
        $EdgeStringLast = ([regex]::Matches($EdgeSplit[$EdgeStrings], "." )).count
        $EdgeStringFirst = ([regex]::Matches($EdgeSplit[0], "." )).count
        If ($EdgeStringLast -lt "3") {
            $EdgeSplit[$EdgeStrings] = "0" + $EdgeSplit[$EdgeStrings]
        }
        If ($EdgeStringFirst -lt "3") {
            $EdgeSplit[0] = "0" + $EdgeSplit[0]
        }
        Switch ($EdgeStrings) {
            1 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1]
            }
            2 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1] + "." + $EdgeSplit[2]
            }
            3 {
                $NewVersion = $EdgeSplit[0] + "." + $EdgeSplit[1] + "." + $EdgeSplit[2] + "." + $EdgeSplit[3]
            }
        }
        $URL = $EdgeD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeArchitectureClear" + "_$MSEdgeChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersion) {
            $CurrentEdgeSplit = $CurrentVersion.split(".")
            $CurrentEdgeStrings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentEdgeStringLast = ([regex]::Matches($CurrentEdgeSplit[$CurrentEdgeStrings], "." )).count
            $CurrentEdgeStringFirst = ([regex]::Matches($CurrentEdgeSplit[0], "." )).count
            If ($CurrentEdgeStringLast -lt "3") {
                $CurrentEdgeSplit[$CurrentEdgeStrings] = "0" + $CurrentEdgeSplit[$CurrentEdgeStrings]
            }
            If ($CurrentEdgeStringFirst -lt "3") {
                $CurrentEdgeSplit[0] = "0" + $CurrentEdgeSplit[0]
            }
            Switch ($CurrentEdgeStrings) {
                1 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1] + "." + $CurrentEdgeSplit[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentEdgeSplit[0] + "." + $CurrentEdgeSplit[1] + "." + $CurrentEdgeSplit[2] + "." + $CurrentEdgeSplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear"
        Write-Host "Download Version: $NewVersion"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $NewVersion.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$NewVersion"
            }
            Write-Host "Starting download of $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear version $NewVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $NewVersion finished!"
            Write-Output ""
            $PackageNameP = "MicrosoftEdgePolicy"
            $EdgeDP = Get-EvergreenApp -name microsoftedge | Where-Object { $_.Channel -eq "Policy" }
            $URL = $EdgeDP.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "cab"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product $MSEdgeChannelClear channel ADMX files version $NewVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                expand ."$PSScriptRoot\$Product\$SourceP" ."$PSScriptRoot\$Product\MicrosoftEdgePolicyTemplates.zip" | Out-Null
                expand-archive -path "$PSScriptRoot\$Product\MicrosoftEdgePolicyTemplates.zip" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\MicrosoftEdgePolicyTemplates.zip" -Force -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\mac" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\html" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\examples" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\VERSION" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\msedge.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\msedgeupdate.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\msedgewebview2.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\en-US\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\en-US\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\en-US\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\de-DE\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\de-DE\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\de-DE\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\da-DK")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\da-DK" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\da-DK\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\da-DK\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\da-DK\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\da-DK\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\da-DK\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\da-DK" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\da-DK\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\da-DK" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\da-DK\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\da-DK" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\es-ES\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\es-ES\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\es-ES\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fi-FI")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fi-FI" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fi-FI\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fi-FI\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fi-FI\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fi-FI\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fi-FI\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fi-FI" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fi-FI\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fi-FI" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fi-FI\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fi-FI" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fr-FR\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fr-FR\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\fr-FR\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\it-IT\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\it-IT\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\it-IT\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ja-JP")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ja-JP\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ja-JP\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ja-JP\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ja-JP\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ko-KR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ko-KR\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ko-KR\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ko-KR\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ko-KR\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\nb-NO")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\nb-NO" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\nb-NO\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nb-NO\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nb-NO\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nb-NO\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nb-NO\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nb-NO" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nb-NO\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nb-NO" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nb-NO\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nb-NO" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\nl-NL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\nl-NL\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nl-NL\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nl-NL\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\nl-NL\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pl-PL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pl-PL\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pl-PL\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pl-PL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pl-PL\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pl-PL" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pl-PL\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pl-PL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-BR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-BR\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-BR\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-BR\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-BR\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-PT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-PT\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-PT\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-PT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-PT\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-PT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\pt-PT\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-PT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ru-RU\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ru-RU\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\ru-RU\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\sv-SE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\sv-SE\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\sv-SE\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\sv-SE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\sv-SE\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\sv-SE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\sv-SE\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\sv-SE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\msedge.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\msedgeupdate.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\msedge.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\msedgewebview2.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\zh-CN\msedge.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\zh-CN\msedgeupdate.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\admx\zh-CN\msedgewebview2.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\windows" -Force -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $NewVersion finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Edge WebView2
    If ($MSEdgeWebView2 -eq 1) {
        $Product = "Microsoft Edge WebView2"
        $PackageName = "MicrosoftEdgeWebView2_" + "$MSEdgeWebView2ArchitectureClear"
        $EdgeWebView2D = Get-EvergreenApp -Name MicrosoftEdgeWebView2Runtime | Where-Object { $_.Architecture -eq "$MSEdgeWebView2ArchitectureClear" }
        $Version = $EdgeWebView2D.Version
        $EdgeWebView2Split = $Version.split(".")
        $EdgeWebView2Strings = ([regex]::Matches($Version, "\." )).count
        $EdgeWebView2StringLast = ([regex]::Matches($EdgeWebView2Split[$EdgeWebView2Strings], "." )).count
        If ($EdgeWebView2StringLast -lt "3") {
            $EdgeWebView2Split[$EdgeWebView2Strings] = "0" + $EdgeWebView2Split[$EdgeWebView2Strings]
        }
        Switch ($EdgeWebView2Strings) {
            1 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1]
            }
            2 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1] + "." + $EdgeWebView2Split[2]
            }
            3 {
                $NewVersion = $EdgeWebView2Split[0] + "." + $EdgeWebView2Split[1] + "." + $EdgeWebView2Split[2] + "." + $EdgeWebView2Split[3]
            }
        }
        $URL = $EdgeWebView2D.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeWebView2ArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $NewCurrentVersion = ""
        If ($CurrentVersion) {
            $CurrentEdgeWebView2Split = $CurrentVersion.split(".")
            $CurrentEdgeWebView2Strings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentEdgeWebView2StringLast = ([regex]::Matches($CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings], "." )).count
            $CurrentEdgeWebView2StringFirst = ([regex]::Matches($CurrentEdgeWebView2Split[0], "." )).count
            If ($CurrentEdgeWebView2StringLast -lt "3") {
                $CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings] = "0" + $CurrentEdgeWebView2Split[$CurrentEdgeWebView2Strings]
            }
            If ($CurrentEdgeWebView2StringFirst -lt "3") {
                $CurrentEdgeWebView2Split[0] = "0" + $CurrentEdgeWebView2Split[0]
            }
            Switch ($CurrentEdgeWebView2Strings) {
                1 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1]
                }
                2 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1] + "." + $CurrentEdgeWebView2Split[2]
                }
                3 {
                    $NewCurrentVersion = $CurrentEdgeWebView2Split[0] + "." + $CurrentEdgeWebView2Split[1] + "." + $CurrentEdgeWebView2Split[2] + "." + $CurrentEdgeWebView2Split[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSEdgeWebView2ArchitectureClear"
        Write-Host "Download Version: $NewVersion"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $NewVersion.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$NewVersion"
            }
            Write-Host "Starting download of $Product $MSEdgeWebView2ArchitectureClear version $NewVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $NewVersion finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft FSLogix
    If ($MSFSLogix -eq 1) {
        $Product = "Microsoft FSLogix"
        $PackageName = "FSLogixAppsSetup_" + "$MSFSLogixChannelCLear"
        If ($MSFSLogixChannelClear -eq "Stable") {
            $MSFSLogixD = Get-MSFSLogix
        } else {
            $MSFSLogixD = Get-EvergreenApp -Name MicrosoftFSLogixApps -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Channel -eq "$MSFSLogixChannelClear"}
            If (!($MSFSLogixD.uri)) {
                $MSFSLogixD = Get-EvergreenApp -Name MicrosoftFSLogixApps -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Channel -eq "Production"}
            }
        }
        $Version = $MSFSLogixD.Version
        $URL = $MSFSLogixD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "zip"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\$MSFSLogixChannelClear\Version_"+ "$MSFSLogixChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear")) { New-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\$MSFSLogixChannelClear\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\$MSFSLogixChannelClear\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
                $FolderPath = "FSLogix_Apps_" + $Version
            }
            Write-Host "Starting download of $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\$MSFSLogixChannelClear\" + ($Source))
                expand-archive -path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$Source" -destinationpath "$PSScriptRoot\$Product\$MSFSLogixChannelClear"
                Remove-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$Source" -Force
                Switch ($MSFSLogixArchitectureClear) {
                    x86 {
                        Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\Win32\Release\*" -Destination "$PSScriptRoot\$Product\$MSFSLogixChannelClear"
                        Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\Win32\Release\*" -Destination "$PSScriptRoot\$Product\$MSFSLogixChannelClear"
                    }
                    x64 {
                        Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\x64\Release\*" -Destination "$PSScriptRoot\$Product\$MSFSLogixChannelClear"
                        Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\x64\Release\*" -Destination "$PSScriptRoot\$Product\$MSFSLogixChannelClear"
                    }
                }
                Remove-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\Win32" -Force -Recurse
                Remove-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\x64" -Force -Recurse
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            Write-Host "Starting copy of $Product $MSFSLogixChannelClear release ADMX files version $Version"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fslogix.admx" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fslogix.admx" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\fslogix.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\fslogix.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\fslogix.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath\fslogix.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\$MSFSLogixChannelClear\$FolderPath" -Force -Recurse
            }
            Write-Host -ForegroundColor Green "Copy of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Office
    If ($MSOffice -eq 1) {
        $Product = "Microsoft Office " + $MSOfficeChannelClear
        $PackageName = "setup"
        $MSOfficeD = Get-EvergreenApp -Name Microsoft365Apps | Where-Object {$_.Channel -eq "$MSOfficeVersionClear"}
        $Version = $MSOfficeD.Version
        $URL = $MSOfficeD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product setup file"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($WhatIf -eq '0') {
            If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
            If (!(Test-Path "$PSScriptRoot\$Product\remove.xml" -PathType leaf)) {
                Write-Host "Create remove.xml"
                [System.XML.XMLDocument]$XML=New-Object System.XML.XMLDocument
                [System.XML.XMLElement]$Root = $XML.CreateElement("Configuration")
                    $XML.appendChild($Root) | out-null
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Remove"))
                    $Node1.SetAttribute("All","True")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Display"))
                    $Node1.SetAttribute("Level","None")
                    $Node1.SetAttribute("AcceptEULA","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","AUTOACTIVATE")
                    $Node1.SetAttribute("Value","0")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","FORCEAPPSHUTDOWN")
                    $Node1.SetAttribute("Value","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","SharedComputerLicensing")
                    $Node1.SetAttribute("Value","0")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","PinIconsToTaskbar")
                    $Node1.SetAttribute("Value","FALSE")
                $XML.Save("$PSScriptRoot\$Product\remove.xml")
                Write-Host -ForegroundColor Green  "Create remove.xml finished!"
            }
            If (!(Test-Path "$PSScriptRoot\$Product\install.xml" -PathType leaf)) {
                Write-Host "Create install.xml for install."
                [System.XML.XMLDocument]$XML=New-Object System.XML.XMLDocument
                [System.XML.XMLElement]$Root = $XML.CreateElement("Configuration")
                    $XML.appendChild($Root) | out-null
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Add"))
                    $Node1.SetAttribute("SourcePath","$PSScriptRoot\$Product")
                    $Node1.SetAttribute("OfficeClientEdition","$MSOfficeArchitectureClear")
                    $Node1.SetAttribute("Channel","$MSOfficeVersionClear")
                [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                    $Node2.SetAttribute("ID","$MSOfficeProductIDClear")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                    $Node3.SetAttribute("ID","MatchOS")
                    $Node3.SetAttribute("Fallback","en-us")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                    $Node3.SetAttribute("ID","$MSOfficeLanguageClear")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                    $Node3.SetAttribute("ID","Teams")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                    $Node3.SetAttribute("ID","Lync")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                    $Node3.SetAttribute("ID","Groove")
                [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                    $Node3.SetAttribute("ID","OneDrive")
                If ($MSOffice_Visio -eq '1') {
                    Write-Host "Add Microsoft Visio to install.xml for install."
                    [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                    $Node2.SetAttribute("ID","$MSOfficeVisioIDClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","MatchOS")
                        $Node3.SetAttribute("Fallback","en-us")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","$MSOfficeVisioLanguageClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Teams")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Lync")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Groove")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","OneDrive")
                }
                If ($MSOffice_Project -eq '1') {
                    Write-Host "Add Microsoft Project to install.xml for install."
                    [System.XML.XMLElement]$Node2 = $Node1.AppendChild($XML.CreateElement("Product"))
                    $Node2.SetAttribute("ID","$MSOfficeProjectIDClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","MatchOS")
                        $Node3.SetAttribute("Fallback","en-us")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("Language"))
                        $Node3.SetAttribute("ID","$MSOfficeProjectLanguageClear")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Teams")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Lync")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","Groove")
                    [System.XML.XMLElement]$Node3 = $Node2.AppendChild($XML.CreateElement("ExcludeApp"))
                        $Node3.SetAttribute("ID","OneDrive")
                }
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Display"))
                    $Node1.SetAttribute("Level","None")
                    $Node1.SetAttribute("AcceptEULA","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","SharedComputerLicensing")
                    $Node1.SetAttribute("Value","0")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Property"))
                    $Node1.SetAttribute("Name","FORCEAPPSHUTDOWN")
                    $Node1.SetAttribute("Value","TRUE")
                [System.XML.XMLElement]$Node1 = $Root.AppendChild($XML.CreateElement("Updates"))
                    $Node1.SetAttribute("Enabled","FALSE")
                    $XML.Save("$PSScriptRoot\$Product\install.xml")
                Write-Host -ForegroundColor Green  "Create install.xml for install finished!"
            }
        }
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse -Exclude install.xml,remove.xml
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version setup file"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            $PackageNameP = "admintemplates-office"
            $MSOfficePD = Get-MicrosoftOfficeAdmx | Where-Object {$_.Architecture -eq "$MSOfficeArchitecturePolicyClear"}
            $Version = $MSOfficePD.Version
            $URL = $MSOfficePD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "exe"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX Files version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                $InstallDir = "$PSScriptRoot\$Product\$SourceP"
                Start-Process -FilePath "$InstallDir" -ArgumentList "/extract:$env:TEMP /passive /quiet" -wait
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\office16.admx" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse
                }
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                copy-item -Path "$env:TEMP\admx\*" -Destination "$PSScriptRoot\_ADMX\$Product" -Force -Recurse
                copy-item -Path "$env:TEMP\office2016grouppolicyandoctsettings.xlsx" -Destination "$PSScriptRoot\_ADMX\$Product" -Force
                Remove-Item -Path "$InstallDir" -Force
                Remove-Item -Path "$env:TEMP\admx" -Force -Recurse
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft OneDrive
    If ($MSOneDrive -eq 1) {
        $Product = "Microsoft OneDrive"
        $PackageName = "OneDriveSetup-" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear"
        $MSOneDriveD = Get-EvergreenApp -Name MicrosoftOneDrive -ErrorAction SilentlyContinue | Where-Object { $_.Ring -eq "$MSOneDriveRingClear" -and $_.Type -eq "Exe" -and $_.Architecture -eq "$MSOneDriveArchitectureClear"} | Sort-Object -Property Version -Descending | Select-Object -Last 1
        $Version = $MSOneDriveD.Version
        $URL = $MSOneDriveD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Power BI Desktop
    If ($MSPowerBIDesktop -eq 1) {
        $Product = "Microsoft Power BI Desktop"
        $PackageName = "PBIDesktopSetup_" + "$MSPowerBIDesktopArchitectureClear"
        $MSPowerBIDesktopD = Get-MicrosoftPowerBIDesktop | Where-Object { $_.Architecture -eq "$MSPowerBIDesktopArchitectureClear"}
        $Version = $MSPowerBIDesktopD.Version
        $URL = $MSPowerBIDesktopD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerBIDesktopArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CurrentPowerSplit = $CurrentVersion.split(".")
        $CurrentPowerStrings = ([regex]::Matches($CurrentVersion, "\." )).count
        $CurrentPowerStringSecond = ([regex]::Matches($CurrentPowerSplit[1], "." )).count
        $CurrentPowerStringThird = ([regex]::Matches($CurrentPowerSplit[2], "." )).count
        Switch ($CurrentPowerStringSecond) {
            2 {
                $CurrentPowerSplit[1] = "0" + $CurrentPowerSplit[1]
            }
        }
        Switch ($CurrentPowerStringThird) {
            3 {
                $CurrentPowerSplit[2] = "0" + $CurrentPowerSplit[2]
            }
        }
        Switch ($CurrentPowerStrings) {
            1 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1]
            }
            2 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1] + "." + $CurrentPowerSplit[2]
            }
            3 {
                $NewCurrentVersion = $CurrentPowerSplit[0] + "." + $CurrentPowerSplit[1] + "." + $CurrentPowerSplit[2] + "." + $CurrentPowerSplit[3]
            }
        }
        $PowerSplit = $Version.split(".")
        $PowerStrings = ([regex]::Matches($Version, "\." )).count
        $PowerStringSecond = ([regex]::Matches($PowerSplit[1], "." )).count
        $PowerStringThird = ([regex]::Matches($PowerSplit[2], "." )).count
        Switch ($PowerStringSecond) {
            2 {
                $PowerSplit[1] = "0" + $PowerSplit[1]
            }
        }
        Switch ($PowerStringThird) {
            3 {
                $PowerSplit[2] = "0" + $PowerSplit[2]
            }
        }
        Switch ($PowerStrings) {
            1 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1]
            }
            2 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1] + "." + $PowerSplit[2]
            }
            3 {
                $NewVersion = $PowerSplit[0] + "." + $PowerSplit[1] + "." + $PowerSplit[2] + "." + $PowerSplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSPowerBIDesktopArchitectureClear"
        Write-Host "Download Version: $NewVersion"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $NewVersion.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$NewVersion"
            }
            Write-Host "Starting download of $Product $MSPowerBIDesktopArchitectureClear version $NewVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $NewVersion finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Power BI Report Builder
    If ($MSPowerBIReportBuilder -eq 1) {
        $Product = "Microsoft Power BI Report Builder"
        $PackageName = "PBIReportBuilderSetup"
        $MSPowerBIReportBuilderD = Get-NevergreenApp -Name MicrosoftPowerBIReportBuilder
        $Version = $MSPowerBIReportBuilderD.Version
        $URL = $MSPowerBIReportBuilderD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $CurrentPowerBISplit = $CurrentVersion.split(".")
        $CurrentPowerBIStrings = ([regex]::Matches($CurrentVersion, "\." )).count
        $CurrentPowerBIStringSecond = ([regex]::Matches($CurrentPowerBISplit[2], "." )).count
        Switch ($CurrentPowerBIStringSecond) {
            4 {
                $CurrentPowerBISplit[2] = "0" + $CurrentPowerBISplit[2]
            }
        }
        Switch ($CurrentPowerBIStrings) {
            1 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1]
            }
            2 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1] + "." + $CurrentPowerBISplit[2]
            }
            3 {
                $NewCurrentVersion = $CurrentPowerBISplit[0] + "." + $CurrentPowerBISplit[1] + "." + $CurrentPowerBISplit[2] + "." + $CurrentPowerBISplit[3]
            }
        }
        $PowerBISplit = $Version.split(".")
        $PowerBIStrings = ([regex]::Matches($Version, "\." )).count
        $PowerBIStringSecond = ([regex]::Matches($PowerBISplit[2], "." )).count
        Switch ($PowerBIStringSecond) {
            4 {
                $PowerBISplit[2] = "0" + $PowerBISplit[2]
            }
        }
        Switch ($PowerBIStrings) {
            1 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1]
            }
            2 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1] + "." + $PowerBISplit[2]
            }
            3 {
                $NewVersion = $PowerBISplit[0] + "." + $PowerBISplit[1] + "." + $PowerBISplit[2] + "." + $PowerBISplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $NewVersion"
        Write-Host "Current Version:  $NewCurrentVersion"
        If ($NewCurrentVersion -lt $NewVersion) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $NewVersion.log"
                If ($Repository -eq '1') {
                    If ($NewCurrentVersion) {
                        Write-Host "Copy $Product installer version $NewCurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$NewCurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $NewCurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$NewVersion"
            }
            Write-Host "Starting download of $Product version $NewVersion"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $NewVersion finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft PowerShell
    If ($MSPowerShell -eq 1) {
        $Product = "Microsoft PowerShell"
        $PackageName = "PowerShell" + "$MSPowerShellArchitectureClear" + "_$MSPowerShellReleaseClear"
        $MSPowershellD = Get-EvergreenApp -Name MicrosoftPowerShell -WarningAction SilentlyContinue | Where-Object {$_.Architecture -eq "$MSPowerShellArchitectureClear" -and $_.Release -eq "$MSPowerShellReleaseClear"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!($MSPowershellD)) {
            $MSPowershellD = Get-EvergreenApp -Name MicrosoftPowerShell -WarningAction SilentlyContinue | Where-Object {$_.Architecture -eq "$MSPowerShellArchitectureClear" -and $_.Release -eq "Stable"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $Version = $MSPowershellD.Version
        $PSSplit = $Version.split(".")
        $PSStrings = ([regex]::Matches($Version, "\." )).count
        $PSStringLast = ([regex]::Matches($PSSplit[$PSStrings], "." )).count
        If ($PSStringLast -lt "2") {
            $PSSplit[$PSStrings] = "0" + $PSSplit[$PSStrings]
        }
        Switch ($PSStrings) {
            1 {
                $Version = $PSSplit[0] + "." + $PSSplit[1]
            }
            2 {
                $Version = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2]
            }
            3 {
                $Version = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2] + "." + $PSSplit[3]
            }
        }
        $URL = $MSPowershellD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerShellArchitectureClear" + "_$MSPowerShellReleaseClear" + ".txt"
        $CurrentVersion = Get-Content -Path $VersionPath -EA SilentlyContinue
        $PSCurrentSplit = $CurrentVersion.split(".")
        $PSCurrentStrings = ([regex]::Matches($CurrentVersion, "\." )).count
        $PSCurrentStringLast = ([regex]::Matches($PSCurrentSplit[$PSCurrentStrings], "." )).count
        If ($PSCurrentStringLast -lt "2") {
            $PSCurrentSplit[$PSCurrentStrings] = "0" + $PSCurrentSplit[$PSCurrentStrings]
        }
        Switch ($PSCurrentStrings) {
            1 {
                $CurrentVersion = $PSCurrentSplit[0] + "." + $PSCurrentSplit[1]
            }
            2 {
                $CurrentVersion = $PSCurrentSplit[0] + "." + $PSCurrentSplit[1] + "." + $PSCurrentSplit[2]
            }
            3 {
                $CurrentVersion = $PSCurrentSplit[0] + "." + $PSCurrentSplit[1] + "." + $PSCurrentSplit[2] + "." + $PSCurrentSplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSPowerShellReleaseClear Release $MSPowerShellArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSPowerShellReleaseClear Release $MSPowerShellArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft PowerToys
    If ($MSPowerToys -eq 1) {
        $Product = "Microsoft PowerToys"
        $PackageName = "PowerToysSetup-x64"
        $MSPowerToysD = Get-EvergreenApp -Name MicrosoftPowerToys| Where-Object {$_.Architecture -eq "x64" -and $_.URI -notlike "*User*"}
        $Version = $MSPowerToysD.Version
        $URL = $MSPowerToysD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft SQL Server Management Studio
    If ($MSSQLServerManagementStudio -eq 1) {
        $Product = "Microsoft SQL Server Management Studio"
        $PackageName = "SSMS-Setup_" + "$MSSQLServerManagementStudioLanguageClear"
        $MSSQLServerManagementStudioD = Get-EvergreenApp -Name MicrosoftSsms -ea silentlyContinue -WarningAction silentlyContinue | Where-Object { $_.Language -eq "$MSSQLServerManagementStudioLanguageClear" }
        $Version = $MSSQLServerManagementStudioD.Version
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionSplit2 = $VersionSplit[2].Substring(0,3)
            $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit2
        }
        $URL = $MSSQLServerManagementStudioD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSSQLServerManagementStudioLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($CurrentVersion) {
            $VersionSplit = $CurrentVersion.split(".")
            $VersionSplit2 = $VersionSplit[2].Substring(0,3)
            $CurrentVersion = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit2
        }
        Write-Host -ForegroundColor Magenta "Download $Product $MSSQLServerManagementStudioLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSSQLServerManagementStudioLanguageClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Sysinternals
    If ($MSSysinternals -eq 1) {
        $Product = "Microsoft Sysinternals"
        $PackageName = "SysinternalsSuite"
        $MSSysinternalsD = Get-NevergreenApp -Name MicrosoftSysinternals | Where-Object { $_.Type -eq "Zip" -and $_.Architecture -eq "Multi" -and $_.Name -eq "Microsoft Sysinternals Suite" }
        $Version = $MSSysinternalsD.Version
        If ($Version) {
            $CurrentWSASplit = $Version.split(".")
            $CurrentWSAStrings = ([regex]::Matches($Version, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $URL = $MSSysinternalsD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "zip"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        If ($CurrentVersion) {
            $CurrentWSASplit = $CurrentVersion.split(".")
            $CurrentWSAStrings = ([regex]::Matches($CurrentVersion, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $CurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $CurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $CurrentVersion = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Copy-Item -Path "$PSScriptRoot\$Product\*.chm" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product" $Source -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$Source" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$Source" -Force
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Teams
    If ($MSTeams -eq 1) {
        $PackageName = "Teams_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear"
        If ($MSTeamsInstallerClear -eq 'Machine Based') {
            $Product = "Microsoft Teams Machine Based"
            If ($MSTeamsRingClear -eq 'Continuous Deployment' -or $MSTeamsRingClear -eq 'Exploration') {
                $TeamsD = Get-EvergreenApp -Name MicrosoftTeamsClassic | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and  $_.Ring -eq "Preview" -and $_.Type -eq "MSI"}
            }
            Else {
                $TeamsD = Get-EvergreenApp -Name MicrosoftTeamsClassic | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and $_.Ring -eq "$MSTeamsRingClear" -and $_.Type -eq "MSI"}
            }
            $Version = $TeamsD.Version
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $NewVersion = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $URL = $TeamsD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            If ($CurrentVersion) {
                $CurrentTeamsSplit = $CurrentVersion.split(".")
                $CurrentTeamsStrings = ([regex]::Matches($CurrentVersion, "\." )).count
                $CurrentTeamsStringLast = ([regex]::Matches($CurrentTeamsSplit[$CurrentTeamsStrings], "." )).count
                If ($CurrentTeamsStringLast -lt "5") {
                    $CurrentTeamsSplit[$CurrentTeamsStrings] = "0" + $CurrentTeamsSplit[$CurrentTeamsStrings]
                }
                $NewCurrentVersionT = $CurrentTeamsSplit[0] + "." + $CurrentTeamsSplit[1] + "." + $CurrentTeamsSplit[2] + "." + $CurrentTeamsSplit[3]
            }
            Write-Host -ForegroundColor Magenta "Download $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
            Write-Host "Download Version: $NewVersion"
            Write-Host "Current Version:  $NewCurrentVersionT"
            If ($NewCurrentVersionT -ne $NewVersion) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
        If ($MSTeamsInstallerClear -eq 'User Based') {
            $Product = "Microsoft Teams User Based"
            $TeamsD = Get-MicrosoftTeamsUser | Where-Object { $_.Architecture -eq "$MSTeamsArchitectureClear" -and $_.Ring -eq "$MSTeamsRingClear"}
            $Version = $TeamsD.Version
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Version = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $URL = $TeamsD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "exe"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            If ($CurrentVersion) {
                $TeamsSplit = $CurrentVersion.split(".")
                $TeamsStrings = ([regex]::Matches($CurrentVersion, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $CurrentVersion = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            Write-Host -ForegroundColor Magenta "Download $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Microsoft Teams 2
    If ($MSTeamsNew -eq 1) {
        $PackageName = "Teams_" + "$MSTeamsNewArchitectureClear"
        $Product = "Microsoft Teams 2"
        $TeamsNewD = Get-EvergreenApp -Name MicrosoftTeams -WarningAction silentlyContinue | Where-Object { $_.Architecture -eq "$MSTeamsNewArchitectureClear" -and $_.Release -eq "Enterprise" -and $_.Type -eq "msix"}
        If (!(Test-Path -Path "$PSScriptRoot\$Product\teamsbootstrapper.exe")) {
            Write-Host -ForegroundColor Magenta "Download Microsoft Teams 2 Bootstrapper"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                Get-Download "https://go.microsoft.com/fwlink/?linkid=2243204&clcid=0x409" "$PSScriptRoot\$Product\" teamsbootstrapper.exe -includeStats
            }
            Write-Host -ForegroundColor Green "Download Microsoft Teams 2 Bootstrapper finished!"
            Write-Output ""
        }
        $Version = $TeamsNewD.Version
        $URL = $TeamsNewD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msix"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsNewArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSTeamsNewArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msix" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Exclude *.exe -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product release $MSTeamsNewArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Visual C++ Runtime
    If ($MSVisualCPlusPlusRuntime -eq 1) {
        $Product = "Microsoft Visual C++ Runtime"
        If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
            $MSVisualCPlusPlusRuntimeArchitectureClear = "x64"
            $MSVisualCPlusPlusRuntimeArchitecture2Clear = "x86"
        }
        If ($MSVisualCPlusPlusRuntimeRelease -ne 3) {
            $PackageName = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear"
            $MSVisualCPlusPlusRuntimeD = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "$MSVisualCPlusPlusRuntimeReleaseClear"}
            $Version = $MSVisualCPlusPlusRuntimeD.Version
            If ($PSVersion -eq "7") {
                $URL = $MSVisualCPlusPlusRuntimeD.download
            } else {
                $URL = $MSVisualCPlusPlusRuntimeD.uri
            }
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "exe"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $MSVisualCPlusPlusRuntimeArchitectureClear $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeArchitectureClear $CurrentVersion.log" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $PackageName = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $MSVisualCPlusPlusRuntimeD = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "$MSVisualCPlusPlusRuntimeReleaseClear"}
                $Version = $MSVisualCPlusPlusRuntimeD.Version
                If ($PSVersion -eq "7") {
                    $URL = $MSVisualCPlusPlusRuntimeD.download
                } else {
                    $URL = $MSVisualCPlusPlusRuntimeD.uri
                }
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "exe"
                $Source = "$PackageName" + "." + "$InstallerType"
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -lt $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $MSVisualCPlusPlusRuntimeArchitecture2Clear $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeArchitecture2Clear $CurrentVersion.log" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$VersionPath" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
        } Else {
            $PackageName2022 = "VS-Setup2022_" + "$MSVisualCPlusPlusRuntimeArchitectureClear"
            $PackageName2012 = "VS-Setup2012_" + "$MSVisualCPlusPlusRuntimeArchitectureClear"
            $PackageName2013 = "VS-Setup2013_" + "$MSVisualCPlusPlusRuntimeArchitectureClear"
            $MSVisualCPlusPlusRuntime2022D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2022"}
            $MSVisualCPlusPlusRuntime2012D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2012"}
            $MSVisualCPlusPlusRuntime2013D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitectureClear" -and $_.Release -eq "2013"}
            $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
            $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
            $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
            If ($PSVersion -eq "7") {
                $URL2022 = $MSVisualCPlusPlusRuntime2022D.download
                $URL2012 = $MSVisualCPlusPlusRuntime2012D.download
                $URL2013 = $MSVisualCPlusPlusRuntime2013D.download
            } else {
                $URL2022 = $MSVisualCPlusPlusRuntime2022D.uri
                $URL2012 = $MSVisualCPlusPlusRuntime2012D.uri
                $URL2013 = $MSVisualCPlusPlusRuntime2013D.uri
            }
            Add-Content -Path "$FWFile" -Value "$URL2022"
            Add-Content -Path "$FWFile" -Value "$URL2012"
            Add-Content -Path "$FWFile" -Value "$URL2013"
            $InstallerType = "exe"
            $Source2022 = "$PackageName2022" + "." + "$InstallerType"
            $Source2012 = "$PackageName2012" + "." + "$InstallerType"
            $Source2013 = "$PackageName2013" + "." + "$InstallerType"
            $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2022 = Get-Content -Path "$VersionPath2022" -EA SilentlyContinue
            $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2012 = Get-Content -Path "$VersionPath2012" -EA SilentlyContinue
            $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013_" + "$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $CurrentVersion2013 = Get-Content -Path "$VersionPath2013" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2012"
            Write-Host "Current Version:  $CurrentVersion2012"
            If ($CurrentVersion2012 -lt $Version2012) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS2012 = "$PSScriptRoot\$Product\" + "$Product 2012 $MSVisualCPlusPlusRuntimeArchitectureClear $Version2012.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion2012) {
                            Write-Host "Copy $Product installer version $CurrentVersion2012 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2012 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitectureClear*.txt" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2012 $MSVisualCPlusPlusRuntimeArchitectureClear*.log" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitectureClear.exe" -Recurse
                    Start-Transcript $LogPS2012 | Out-Null
                    Set-Content -Path "$VersionPath2012" -Value "$Version2012"
                }
                Write-Host "Starting download of $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version2012"
                If ($WhatIf -eq '0') {
                    Get-Download $URL2012 "$PSScriptRoot\$Product\" $Source2012 -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version2012 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            Write-Host -ForegroundColor Magenta "Download $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2013"
            Write-Host "Current Version:  $CurrentVersion2013"
            If ($CurrentVersion2013 -lt $Version2013) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS2013 = "$PSScriptRoot\$Product\" + "$Product 2013 $MSVisualCPlusPlusRuntimeArchitectureClear $Version2013.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion2013) {
                            Write-Host "Copy $Product installer version $CurrentVersion2013 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2013 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitectureClear*.txt" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2013 $MSVisualCPlusPlusRuntimeArchitectureClear*.log" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitectureClear.exe" -Recurse
                    Start-Transcript $LogPS2013 | Out-Null
                    Set-Content -Path "$VersionPath2013" -Value "$Version2013"
                }
                Write-Host "Starting download of $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version2013"
                If ($WhatIf -eq '0') {
                    Get-Download $URL2013 "$PSScriptRoot\$Product\" $Source2013 -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version2013 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            Write-Host -ForegroundColor Magenta "Download $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2022"
            Write-Host "Current Version:  $CurrentVersion2022"
            If ($CurrentVersion2022 -lt $Version2022) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS2022 = "$PSScriptRoot\$Product\" + "$Product 2022 $MSVisualCPlusPlusRuntimeArchitectureClear $Version2022.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion2022) {
                            Write-Host "Copy $Product installer version $CurrentVersion2022 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2022 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitectureClear*.txt" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2022 $MSVisualCPlusPlusRuntimeArchitectureClear*.log" -Recurse
                    Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitectureClear.exe" -Recurse
                    Start-Transcript $LogPS2022 | Out-Null
                    Set-Content -Path "$VersionPath2022" -Value "$Version2022"
                }
                Write-Host "Starting download of $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version2022"
                If ($WhatIf -eq '0') {
                    Get-Download $URL2022 "$PSScriptRoot\$Product\" $Source2022 -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version2022 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $PackageName2022 = "VS-Setup2022_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $PackageName2012 = "VS-Setup2012_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $PackageName2013 = "VS-Setup2013_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $MSVisualCPlusPlusRuntime2022D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2022"}
                $MSVisualCPlusPlusRuntime2012D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2012"}
                $MSVisualCPlusPlusRuntime2013D = Get-VcList | Where-Object { $_.Architecture -eq "$MSVisualCPlusPlusRuntimeArchitecture2Clear" -and $_.Release -eq "2013"}
                $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
                $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
                $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
                $URL2022 = $MSVisualCPlusPlusRuntime2022D.download
                $URL2012 = $MSVisualCPlusPlusRuntime2012D.download
                $URL2013 = $MSVisualCPlusPlusRuntime2013D.download
                Add-Content -Path "$FWFile" -Value "$URL2022"
                Add-Content -Path "$FWFile" -Value "$URL2012"
                Add-Content -Path "$FWFile" -Value "$URL2013"
                $InstallerType = "exe"
                $Source2022 = "$PackageName2022" + "." + "$InstallerType"
                $Source2012 = "$PackageName2012" + "." + "$InstallerType"
                $Source2013 = "$PackageName2013" + "." + "$InstallerType"
                $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2022 = Get-Content -Path "$VersionPath2022" -EA SilentlyContinue
                $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2012 = Get-Content -Path "$VersionPath2012" -EA SilentlyContinue
                $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013_" + "$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $CurrentVersion2013 = Get-Content -Path "$VersionPath2013" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2012"
                Write-Host "Current Version:  $CurrentVersion2012"
                If ($CurrentVersion2012 -lt $Version2012) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS2012 = "$PSScriptRoot\$Product\" + "$Product 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear $Version2012.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion2012) {
                                Write-Host "Copy $Product installer version $CurrentVersion2012 to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2012" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2012 finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitecture2Clear*.txt" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear*.log" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitecture2Clear.exe" -Recurse
                        Start-Transcript $LogPS2012 | Out-Null
                        Set-Content -Path "$VersionPath2012" -Value "$Version2012"
                    }
                    Write-Host "Starting download of $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version2012"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL2012 "$PSScriptRoot\$Product\" $Source2012 -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version2012 finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
                Write-Host -ForegroundColor Magenta "Download $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2013"
                Write-Host "Current Version:  $CurrentVersion2013"
                If ($CurrentVersion2013 -lt $Version2013) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS2013 = "$PSScriptRoot\$Product\" + "$Product 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear $Version2013.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion2013) {
                                Write-Host "Copy $Product installer version $CurrentVersion2013 to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2013" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2013 finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitecture2Clear*.txt" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear*.log" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitecture2Clear.exe" -Recurse
                        Start-Transcript $LogPS2013 | Out-Null
                        Set-Content -Path "$VersionPath2013" -Value "$Version2013"
                    }
                    Write-Host "Starting download of $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version2013"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL2013 "$PSScriptRoot\$Product\" $Source2013 -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version2013 finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
                Write-Host -ForegroundColor Magenta "Download $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2022"
                Write-Host "Current Version:  $CurrentVersion2022"
                If ($CurrentVersion2022 -lt $Version2022) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS2022 = "$PSScriptRoot\$Product\" + "$Product 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear $Version2022.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion2022) {
                                Write-Host "Copy $Product installer version $CurrentVersion2022 to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion2022" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2022 finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitecture2Clear*.txt" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear*.log" -Recurse
                        Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitecture2Clear.exe" -Recurse
                        Start-Transcript $LogPS2022 | Out-Null
                        Set-Content -Path "$VersionPath2022" -Value "$Version2022"
                    }
                    Write-Host "Starting download of $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version2022"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL2022 "$PSScriptRoot\$Product\" $Source2022 -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version2022 finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Download Microsoft Visual Studio 2019
    If ($MSVisualStudio -eq 1) {
        $Product = "Microsoft Visual Studio 2019"
        $PackageName = "VS-Setup"
        $MSVisualStudioD = Get-EvergreenApp -Name MicrosoftVisualStudio
        $Version = $MSVisualStudioD.Version
        $URL = $MSVisualStudioD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Microsoft Visual Studio Code
    If ($MSVisualStudioCode -eq 1) {
        $Product = "Microsoft Visual Studio Code"
        $PackageName = "VSCode-Setup-"
        $MSVisualStudioCodeD = Get-EvergreenApp -Name MicrosoftVisualStudioCode | Where-Object { $_.Architecture -eq "$MSVisualStudioCodeArchitectureClear" -and $_.Channel -eq "$MSVisualStudioCodeChannelClear" -and $_.Platform -eq "$MSVisualStudioCodePlatformClear"}
        $Version = $MSVisualStudioCodeD.Version
        $URL = $MSVisualStudioCodeD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download MindView
    If ($MindView7 -eq 1) {
        $Product = "MindView"
        $PackageName = "MindView-"
        $MindView7D = Get-MindView | Where-Object { $_.Language -eq "$MindView7LanguageClear"}
        $Version = $MindView7D.Version
        $URL = $MindView7D.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "$MindView7LanguageClear" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MindView7LanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MindView7LanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MindView7LanguageClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Mozilla Firefox
    If ($Firefox -eq 1) {
        $Product = "Mozilla Firefox"
        $PackageName = "Firefox_Setup_" + "$FirefoxChannelClear" + "$FirefoxArchitectureClear" + "_$FFLanguageClear"
        $FirefoxD = Get-EvergreenApp -Name MozillaFirefox -AppParams @{Language="$FFLanguageClear"} -WarningAction silentlyContinue -ErrorAction SilentlyContinue | Where-Object { $_.Type -eq "msi" -and $_.Architecture -eq "$FirefoxArchitectureClear" -and $_.Channel -like "*$FirefoxChannelClear*"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $FirefoxD.Version
        $URL = $FirefoxD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FirefoxChannelClear" + "$FirefoxArchitectureClear" + "$FFLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        $FirefoxSplit = $CurrentVersion.split(".")
        $FirefoxStrings = ([regex]::Matches($CurrentVersion, "\." )).count
        $FirefoxStringFirst = ([regex]::Matches($FirefoxSplit[0], "." )).count
        If ($FirefoxStringFirst -lt "3") {
            $FirefoxSplit[0] = "0" + $FirefoxSplit[0]
        }
        Switch ($FirefoxStrings) {
            1 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1]
            }
            2 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1] + "." + $FirefoxSplit[2]
            }
            3 {
                $NewCurrentVersion = $FirefoxSplit[0] + "." + $FirefoxSplit[1] + "." + $FirefoxSplit[2] + "." + $FirefoxSplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($NewCurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            $PackageNameP = "Firefox-Templates"
            $FirefoxDP = Get-MozillaFirefoxAdmx
            $VersionP = $FirefoxDP.version
            $URL = $FirefoxDP.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX files version $VersionP"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\windows\firefox.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\mozilla.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\firefox.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\mozilla.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\en-US\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\en-US\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\firefox.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\mozilla.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\de-DE\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\de-DE\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\firefox.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\es-ES\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\es-ES\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\firefox.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\fr-FR\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\fr-FR\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\firefox.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\it-IT\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\it-IT\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\firefox.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\ru-RU\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\ru-RU\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\firefox.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\firefox.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\windows\zh-CN\firefox.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\windows\zh-CN\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\mac" -Force -Recurse -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\README.md" -Force -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\LICENSE" -Force -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\windows" -Force -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Mozilla Thunderbird
    If ($MozillaThunderbird -eq 1) {
        $Product = "Mozilla Thunderbird"
        $PackageName = "Thunderbird_Setup_" + "$MozillaThunderbirdArchitectureClear" + "_$MozillaThunderbirdLanguageClear"
        $ThunderbirdD = Get-EvergreenApp -Name MozillaThunderbird -AppParams @{Language="$MozillaThunderbirdLanguageClear"} -WarningAction silentlyContinue -ErrorAction SilentlyContinue | Where-Object { $_.Type -eq "msi" -and $_.Architecture -eq "$MozillaThunderbirdArchitectureClear"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        $Version = $ThunderbirdD.Version
        $URL = $ThunderbirdD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MozillaThunderbirdArchitectureClear" + "_$MozillaThunderbirdLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
            $PackageNameP = "Thunderbird-Templates"
            $VersionP = $ThunderbirdD.version
            $URL = "https://github.com/thundernest/policy-templates/archive/refs/heads/master.zip"
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerTypeP = "zip"
            $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
            Write-Host "Starting download of $Product ADMX files version $VersionP"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\thunderbird.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\mozilla.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\thunderbird.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\mozilla.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\en-US\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\en-US\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\thunderbird.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\mozilla.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\de-DE\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\de-DE\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\thunderbird.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\es-ES\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\es-ES\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\thunderbird.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\fr-FR\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\fr-FR\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\thunderbird.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\it-IT\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\it-IT\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\thunderbird.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\ru-RU\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\ru-RU\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\thunderbird.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\mozilla.adml" -ErrorAction SilentlyContinue
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\thunderbird.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\zh-CN\thunderbird.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Move-Item -Path "$PSScriptRoot\$Product\policy-templates-master\templates\central\windows\zh-CN\mozilla.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
                Remove-Item -Path "$PSScriptRoot\$Product\policy-templates-master" -Force -Recurse -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download mRemoteNG
    If ($mRemoteNG -eq 1) {
        $Product = "mRemoteNG"
        $PackageName = "mRemoteNG"
        $mRemoteNGD = Get-EvergreenApp -Name mRemoteNG | Where-Object { $_.Type -eq "msi" }
        $Version = $mRemoteNGD.Version
        $URL = $mRemoteNGD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Nmap
    If ($Nmap -eq 1) {
        $Product = "Nmap"
        $PackageName = "Nmap-setup"
        $NMapD = Get-NevergreenApp -Name NMap | Where-Object { $_.Architecture -eq "x86" -and $_.Type -eq "exe" }
        $Version = $NMapD.Version
        $URL = $NMapD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Get-ChildItem "$PSScriptRoot\$Product\" -Exclude lang | Remove-Item -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Notepad ++
    If ($NotePadPlusPlus -eq 1) {
        $Product = "NotePadPlusPlus"
        $PackageName = "NotePadPlusPlus_" + "$NotepadPlusPlusArchitectureClear"
        $NotepadD = Get-EvergreenApp -Name NotepadPlusPlus | Where-Object { $_.Architecture -eq "$NotepadPlusPlusArchitectureClear" -and $_.Type -eq "exe" }
        $Version = $NotepadD.Version
        $URL = $NotepadD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$NotepadPlusPlusArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $NotepadPlusPlusArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Get-ChildItem "$PSScriptRoot\$Product\" -Exclude lang | Remove-Item -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $NotepadPlusPlusArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download OpenJDK
    If ($OpenJDK -eq 1) {
        $Product = "OpenJDK"
        If ($openJDK_Architecture -eq 3) {
            $openJDKArchitectureClear = "x64"
            $openJDKArchitecture2Clear = "x86"
        }
        $PackageName = "OpenJDK_" + "$openJDKArchitectureClear" + "_$OpenJDKPackageClear"
        If ($OpenJDKPackageClear -eq "8") {
            $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitectureClear" -and $_.Type -eq "msi" -and $_.Version -like "1.8*" -and $_.URI -notlike "*-jre-*"} | Sort-Object -Property Version -Descending | Select-Object -First 1
        } Else {
            $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitectureClear" -and $_.Type -eq "msi" -and $_.Version -like "$OpenJDKPackageClear*" -and $_.URI -notlike "*-jre-*" -and $_.URI -notlike "*.jre.*"} | Sort-Object -Property Size -Descending | Select-Object -First 4 | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $Version = $OpenJDKD.Version
        If ($openJDKArchitectureClear -eq "x86") {
            $x86Version = $Version.split("-x")
            $Version = $x86Version[0] + $x86Version[1]
        }
        If ($Version) {$Version = $Version -replace('-','.')}
        If ($Version) {$Version = $Version -replace('b0','')}
        If ($Version) {$Version = $Version -replace('8.0','8')}
        If ($OpenJDKPackageClear -eq "11") {
            $OpenJDKSplit = $Version.split(".")
            $OpenJDKStrings = ([regex]::Matches($Version, "\." )).count
            $OpenJDKStringsNotLast = $OpenJDKStrings
            $OpenJDKStringsNotLast --
            $OpenJDKStringPenultimate = ([regex]::Matches($OpenJDKSplit[$OpenJDKStringsNotLast], "." )).count
            Switch ($OpenJDKStrings) {
                1 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                4 {
                    $Version = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[4]
                }
            }
        }
        $URL = $OpenJDKD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$openJDKArchitectureClear" + "_$OpenJDKPackageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If ($CurrentVersion) {$CurrentVersion = $CurrentVersion -replace "-"}
        If ($CurrentVersion -like "*b0*") {$CurrentVersion = $CurrentVersion -replace "b0"}
        Write-Host -ForegroundColor Magenta "Download $Product release $OpenJDKPackageClear $openJDKArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $openJDKArchitectureClear $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*$openJDKArchitectureClear*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product release $OpenJDKPackageClear $openJDKArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
        If ($openJDK_Architecture -eq 3) {
            $PackageName = "OpenJDK_" + "$openJDKArchitecture2Clear" + "_$OpenJDKPackageClear"
            If ($OpenJDKPackageClear -eq "8") {
                $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitecture2Clear" -and $_.Type -eq "msi" -and $_.Version -like "1.8*" -and $_.URI -notlike "*-jre-*"} | Sort-Object -Property Version -Descending | Select-Object -First 1
            } Else {
                $OpenJDKD = Get-EvergreenApp -Name OpenJDK | Where-Object { $_.Architecture -eq "$openJDKArchitecture2Clear" -and $_.Type -eq "msi" -and $_.Version -like "$OpenJDKPackageClear*" -and $_.URI -notlike "*-jre-*" -and $_.URI -notlike "*.jre.*"} | Sort-Object -Property Size -Descending | Select-Object -First 4 | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $Version = $OpenJDKD.Version
            $x86Version = $Version.split("-x")
            $Version = $x86Version[0] + $x86Version[1]
            $URL = $OpenJDKD.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "msi"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$openJDKArchitecture2Clear" + "_$OpenJDKPackageClear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $openJDKArchitecture2Clear $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*$openJDKArchitectureClear*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Open-Shell Menu
    If ($OpenShellMenu -eq 1) {
        $Product = "Open-Shell Menu"
        $PackageName = "OpenShellSetup"
        $OpenShellMenuD = Get-EvergreenApp -Name OpenShellMenu
        $Version = $OpenShellMenuD.Version
        $URL = $OpenShellMenuD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download OpenWebStart
    If ($OpenWebStart -eq 1) {
        $Product = "OpenWebStart"
        $PackageName = "OpenWebStart_" + "$OpenWebStartArchitectureClear"
        $OpenWebStartD = Get-EvergreenApp -Name OpenWebStart | Where-Object { $_.Architecture -eq "$OpenWebStartArchitectureClear"}
        $Version = $OpenWebStartD.Version
        $URL = $OpenWebStartD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OpenWebStartArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $OpenWebStartArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $OpenWebStartArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Opera Browser
    If ($OperaBrowser -eq 1) {
        $Product = "Opera Browser"
        $PackageName = "OperaBrowser_" + "$OperaBrowserArchitectureClear" + "_$OperaBrowserChannelClear"
        $OperaBrowserD = Get-EvergreenApp -Name OperaBrowser | Where-Object { $_.Architecture -eq "$OperaBrowserArchitectureClear" -and $_.Channel -eq "$OperaBrowserChannelClear"}
        $Version = $OperaBrowserD.Version
        $URL = $OperaBrowserD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OperaBrowserArchitectureClear" + "_$OperaBrowserChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Oracle Java 8
    If ($OracleJava8 -eq 1) {
        $Product = "Oracle Java 8"
        If ($OracleJava8_Architecture -eq 3) {
            $OracleJava8ArchitectureClear = "x64"
            $OracleJava8Architecture2Clear = "x86"
        }
        $PackageName = "OracleJava8_" + "$OracleJava8ArchitectureClear"
        $OracleJava8D = Get-EvergreenApp -Name OracleJava8 | Where-Object { $_.Architecture -eq "$OracleJava8ArchitectureClear" }
        $Version = $OracleJava8D.Version
        $URL = $OracleJava8D.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OracleJava8ArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $OracleJava8ArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*$OracleJava8ArchitectureClear*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $OracleJava8ArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
        If ($OracleJava8_Architecture -eq 3) {
            $PackageName = "OracleJava8_" + "$OracleJava8Architecture2Clear"
            $OracleJava8D = Get-EvergreenApp -Name OracleJava8 | Where-Object { $_.Architecture -eq "$OracleJava8Architecture2Clear" }
            $Version = $OracleJava8D.Version
            $URL = $OracleJava8D.uri
            Add-Content -Path "$FWFile" -Value "$URL"
            $InstallerType = "exe"
            $Source = "$PackageName" + "." + "$InstallerType"
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OracleJava8Architecture2Clear" + ".txt"
            $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product $OracleJava8Architecture2Clear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CurrentVersion"
            If ($CurrentVersion -lt $Version) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                    $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion) {
                            Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\*$OracleJava8Architecture2Clear*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$VersionPath" -Value "$Version"
                }
                Write-Host "Starting download of $Product $OracleJava8Architecture2Clear version $Version"
                If ($WhatIf -eq '0') {
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }

    #// Mark: Download Paint.Net
    If ($PaintDotNet -eq 1) {
        $Product = "Paint.Net"
        $PackageName = "Paint.net"
        $PaintDotNetInstaller = "paint.net_" + "$PaintDotNetArchitectureClear" + ".msi"
        $PaintDotNetD = Get-EvergreenApp -Name PaintDotNetOfflineInstaller | Where-Object { $_.Architecture -eq "$PaintDotNetArchitectureClear" -and $_.URI -like "*winmsi*"}
        $Version = $PaintDotNetD.Version
        $URL = $PaintDotNetD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "zip"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PaintDotNetArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $PaintDotNetArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $PaintDotNetArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product" $Source -includeStats
                expand-archive -path "$PSScriptRoot\$Product\Paint.Net.zip" -destinationpath "$PSScriptRoot\$Product"
                Move-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\$Product\$PaintDotNetInstaller"
                Remove-Item -Path "$PSScriptRoot\$Product\Paint.Net.zip" -Force
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download PDF24 Creator
    If ($PDF24Creator -eq 1) {
        $Product = "PDF24 Creator"
        $PackageName = "PDF24Creator"
        $PDF24CreatorD = Get-evergreenApp -name GeekSoftwarePDF24Creator | Where-Object { $_.Type -eq "Msi"}
        $Version = $PDF24CreatorD.Version
        $PDF24Split = $Version.split(".")
        $PDF24Strings = ([regex]::Matches($Version, "\." )).count
        $PDF24Pen = $PDF24Strings-1
        $PDF24StringPen = ([regex]::Matches($PDF24Split[$PDF24Pen], "." )).count
        If ($PDF24StringPen -lt "2") {
            $PDF24Split[$PDF24Pen] = "0" + $PDF24Split[$PDF24Pen]
        }
        Switch ($PDF24Strings) {
            1 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1]
            }
            2 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1] + "." + $PDF24Split[2]
            }
            3 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1] + "." + $PDF24Split[2] + "." + $PDF24Split[3]
            }
        }
        $URL = $PDF24CreatorD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        $PDF24CurrentSplit = $CurrentVersion.split(".")
        $PDF24CurrentStrings = ([regex]::Matches($CurrentVersion, "\." )).count
        $PDF24CurrentPen = $PDF24CurrentStrings-1
        $PDF24CurrentStringPen = ([regex]::Matches($PDF24CurrentSplit[$PDF24CurrentPen], "." )).count
        If ($PDF24CurrentStringPen -lt "2") {
            $PDF24CurrentSplit[$PDF24Pen] = "0" + $PDF24CurrentSplit[$PDF24CurrentPen]
        }
        Switch ($PDF24CurrentStrings) {
            1 {
                $CurrentVersion = $PDF24CurrentSplit[0] + "." + $PDF24CurrentSplit[1]
            }
            2 {
                $CurrentVersion = $PDF24CurrentSplit[0] + "." + $PDF24CurrentSplit[1] + "." + $PDF24CurrentSplit[2]
            }
            3 {
                $CurrentVersion = $PDF24CurrentSplit[0] + "." + $PDF24CurrentSplit[1] + "." + $PDF24CurrentSplit[2] + "." + $PDF24CurrentSplit[3]
            }
        }
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download pdfforge PDFCreator
    If ($PDFForgeCreator -eq 1) {
        $Product = "pdfforge PDFCreator"
        $PackageName = "PDFForgeCreatorWebSetup_" + "$pdfforgePDFCreatorChannelClear"
        $PDFForgeCreatorD = Get-PDFForgePDFCreator | Where-Object { $_.Channel -eq "$pdfforgePDFCreatorChannelClear" }
        $Version = $PDFForgeCreatorD.Version
        $URL = $PDFForgeCreatorD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$pdfforgePDFCreatorChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $pdfforgePDFCreatorChannelClear edition"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $pdfforgePDFCreatorChannelClear edition version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download PDF Split & Merge
    If ($PDFsam -eq 1) {
        $Product = "PDF Split & Merge"
        $PackageName = "PDFsam"
        $PDFsamD = Get-PDFsam
        $Version = $PDFsamD.Version
        $URL = $PDFsamD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download PeaZip
    If ($PeaZip -eq 1) {
        $Product = "PeaZip"
        $PackageName = "PeaZip" + "$PeaZipArchitectureClear"
        $PeaZipD = Get-EvergreenApp -Name PeaZipPeaZip | Where-Object {$_.Architecture -eq "$PeaZipArchitectureClear" -and $_.Type -eq "exe"}
        $Version = $PeaZipD.Version
        $URL = $PeaZipD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PeaZipArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $PeaZipArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $PeaZipArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download PuTTY
    If ($Putty -eq 1) {
        $Product = "PuTTY"
        $PackageName = "PuTTY-" + "$PuTTYArchitectureClear" + "-$PuttyChannelClear"
        $PuTTYD = Get-Putty | Where-Object { $_.Architecture -eq "$PuTTYArchitectureClear" -and $_.Channel -eq "$PuttyChannelClear"}
        $Version = $PuTTYD.Version
        $URL = $PuTTYD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PuTTYArchitectureClear" + "_$PuttyChannelClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $PuttyChannelClear $PuTTYArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $PuttyChannelClear $PuTTYArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Remote Desktop Manager
    If ($RemoteDesktopManager -eq 1) {
        Switch ($RemoteDesktopManagerType) {
            0 {
                $Product = "Remote Desktop Manager Free"
                $PackageName = "Setup.RemoteDesktopManagerFree"
                $URLVersion = "https://devolutions.net/remote-desktop-manager/de/release-notes/free"
                $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($URLVersion) -SessionVariable websession
                $regexAppVersion = "\d\d\d\d\.\d\.\d\d\.\d+"
                $webVersion = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $Version = $webVersion.Trim("</td>").Trim("</td>")
                $RemoteDesktopManagerFreeD = $Version
                $URL = "https://cdn.devolutions.net/download/Setup.RemoteDesktopManagerFree.$Version.msi"
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "msi"
                $Source = "$PackageName" + "." + "$InstallerType"
                $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -ne $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
            1 {
                $Product = "Remote Desktop Manager Enterprise"
                $PackageName = "Setup.RemoteDesktopManagerEnterprise"
                $URLVersion = "https://devolutions.net/remote-desktop-manager/de/release-notes"
                $webRequest = Invoke-WebRequest -UseBasicParsing -Uri ($URLVersion) -SessionVariable websession
                $regexAppVersion = "\d\d\d\d\.\d\.\d\d\.\d+"
                $webVersionRDM = $webRequest.RawContent | Select-String -Pattern $regexAppVersion -AllMatches | ForEach-Object { $_.Matches.Value } | Select-Object -First 1
                $Version = $webVersionRDM.Trim("</td>").Trim("</td>")
                $RemoteDesktopManagerEnterpriseD = $Version
                $URL = "https://cdn.devolutions.net/download/Setup.RemoteDesktopManager.$Version.msi"
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "msi"
                $Source = "$PackageName" + "." + "$InstallerType"
                $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -ne $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Download Remote Display Analyzer
    If ($RDAnalyzer -eq 1) {
        $Product = "Remote Display Analyzer"
        $PackageName = "RDAnalyzer-setup"
        $RDAnalyzerD = Get-EvergreenApp -Name RDAnalyzer | Where-Object {$_.Type -eq "exe"}
        $Version = $RDAnalyzerD.Version
        $URL = $RDAnalyzerD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Screenpresso
    If ($Screenpresso -eq 1) {
        $Product = "Screenpresso"
        $PackageName = "Screenpresso.setup"
        $ScreenpressoD = Get-Screenpresso
        $Version = $ScreenpressoD.Version
        $URL = $ScreenpressoD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download ShareX
    If ($ShareX -eq 1) {
        $Product = "ShareX"
        $PackageName = "ShareX-setup"
        $ShareXD = Get-EvergreenApp -Name ShareX | Where-Object {$_.Type -eq "exe"}
        $Version = $ShareXD.Version
        $URL = $ShareXD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Slack
    If ($Slack -eq 1) {
        $Product = "Slack"
        $PackageName = "Slack.setup" + "_$SlackArchitectureClear" + "_$SlackPlatformClear"
        $SlackD = Get-EvergreenApp -Name Slack | Where-Object {$_.Architecture -eq "$SlackArchitectureClear" -and $_.Platform -eq "PerMachine" }
        $Version = $SlackD.Version
        $URL = $SlackD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SlackArchitectureClear" + "_$SlackPlatformClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $SlackArchitectureClear $SlackPlatformClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $SlackArchitectureClear $SlackPlatformClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Sumatra PDF
    If ($SumatraPDF -eq 1) {
        $Product = "Sumatra PDF"
        $PackageName = "SumatraPDF-Install-" + "$SumatraPDFArchitectureClear"
        $SumatraPDFD = Get-EvergreenApp -Name SumatraPDFReader | Where-Object {$_.Architecture -eq "$SumatraPDFArchitectureClear" }
        $Version = $SumatraPDFD.Version
        $URL = $SumatraPDFD.uri
        <#If ($SumatraPDFArchitectureClear -eq 'x86') {
            $URL = "https://kjkpubsf.sfo2.digitaloceanspaces.com/software/sumatrapdf/rel/SumatraPDF-" + "$Version" + "-install.exe"
        }
        If ($SumatraPDFArchitectureClear -eq 'x64') {
            $URL = "https://kjkpubsf.sfo2.digitaloceanspaces.com/software/sumatrapdf/rel/SumatraPDF-" + "$Version" + "-64-install.exe"
        }#>
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SumatraPDFArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $SumatraPDFArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $SumatraPDFArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download TeamViewer
    If ($TeamViewer -eq 1) {
        $Product = "TeamViewer"
        $PackageName = "TeamViewer-setup-" + "$TeamViewerArchitectureClear"
        $TeamViewerD = Get-EvergreenApp -Name TeamViewer
        $Version = $TeamViewerD.Version
        $URL = $TeamViewerD.uri
        If ($TeamViewerArchitectureClear -eq "x64") {
            $URL = $URL.Replace("TeamViewer_Setup", "TeamViewer_Setup_x64")
        }
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TeamViewerArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $TeamViewerArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $TeamViewerArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download TechSmith Camtasia
    If ($TechSmithCamtasia -eq 1) {
        $Product = "TechSmith Camtasia"
        $PackageName = "camtasia-setup"
        $TechSmithCamtasiaD = Get-EvergreenApp -Name TechSmithCamtasia | Where-Object { $_.Type -eq "msi" }
        $Version = $TechSmithCamtasiaD.Version
        $URL = $TechSmithCamtasiaD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download TechSmith Snagit
    If ($TechSmithSnagit -eq 1) {
        $Product = "TechSmith Snagit"
        $PackageName = "snagit-setup" + "_$TechSmithSnagItArchitectureClear"
        $TechSmithSnagitD = Get-EvergreenApp -Name TechSmithSnagit | Where-Object { $_.Architecture -eq "$TechSmithSnagItArchitectureClear" -and $_.Type -eq "msi" }
        $Version = $TechSmithSnagitD.Version
        $URL = $TechSmithSnagitD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TechSmithSnagItArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $TechSmithSnagItArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $TechSmithSnagItArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Total Commander
    If ($TotalCommander -eq 1) {
        $Product = "Total Commander"
        $PackageName = "TotalCommander_" + "$TotalCommanderArchitectureClear"
        $TotalCommanderD = Get-TotalCommander | Where-Object {$_.Architecture -eq "$TotalCommanderArchitectureClear"}
        $Version = $TotalCommanderD.Version
        $URL = $TotalCommanderD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TotalCommanderArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $TotalCommanderArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $TotalCommanderArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download TreeSize
    If ($TreeSize -eq 1) {
        Switch ($TreeSizeType) {
            0 {
                $Product = "TreeSize Free"
                $PackageName = "TreeSize_Free"
                $TreeSizeFreeD = Get-EvergreenApp -Name JamTreeSizeFree
                $Version = $TreeSizeFreeD.Version
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $URL = $TreeSizeFreeD.uri
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "exe"
                $Source = "$PackageName" + "." + "$InstallerType"
                $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $CurrentVersionC = ([regex]::Matches($CurrentVersion, "\." )).count
                If ($CurrentVersionC -ne 2){
                    $CurrentVersion = $CurrentVersion.Insert(3,'.')
                }
                Write-Host -ForegroundColor Magenta "Download $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -lt $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
            1 {
                $Product = "TreeSize Professional"
                $PackageName = "TreeSize_Professional"
                $TreeSizeProfD = Get-EvergreenApp -Name JamTreeSizeProfessional
                $Version = $TreeSizeProfD.Version
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $URL = $TreeSizeProfD.uri
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "exe"
                $Source = "$PackageName" + "." + "$InstallerType"
                $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
                $CurrentVersionC = ([regex]::Matches($CurrentVersion, "\." )).count
                If ($CurrentVersionC -ne 2){
                    $CurrentVersion = $CurrentVersion.Insert(3,'.')
                }
                Write-Host -ForegroundColor Magenta "Download $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -lt $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Download VLC Player
    If ($VLCPlayer -eq 1) {
        $Product = "VLC Player"
        $PackageName = "VLC-Player_" + "$VLCPlayerArchitectureClear"
        $VLCD = Get-EvergreenApp -Name VideoLanVlcPlayer | Where-Object { $_.Platform -eq "Windows" -and $_.Architecture -eq "$VLCPlayerArchitectureClear" -and $_.Type -eq "MSI" }
        $Version = $VLCD.Version
        $URL = $VLCD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VLCPlayerArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $VLCPlayerArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $VLCPlayerArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download VMwareTools
    If ($VMwareTools -eq 1) {
        $Product = "VMware Tools"
        $PackageName = "VMwareTools_" + "$VMwareToolsArchitectureClear"
        $VMwareToolsD = Get-VMwareTools | Where-Object { $_.Architecture -eq "$VMwareToolsArchitectureClear" }
        $Version = $VMwareToolsD.Version
        $URL = $VMwareToolsD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VMwareToolsArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $VMwareToolsArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $VMwareToolsArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download WinMerge
    If ($WinMerge -eq 1) {
        $Product = "WinMerge"
        $PackageName = "WinMerge_" + "$WinMergeArchitectureClear"
        $WinMergeD = Get-EvergreenApp -Name WinMerge | Where-Object {$_.Architecture -eq "$WinMergeArchitectureClear" -and $_.URI -notlike "*PerUser*"}
        $Version = $WinMergeD.Version
        $URL = $WinMergeD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinMergeArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $WinMergeArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $WinMergeArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download WinRAR
    If ($WinRAR -eq 1) {
        $Product = "WinRAR"
        $PackageName = "WinRAR_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear"
        $WinRARD = Get-WinRAR | Where-Object {$_.Architecture -eq "$WinRARArchitectureClear" -and $_.Channel -eq "$WinRARChannelClear" -and $_.Language -eq "$WinRARLanguageClear"}
        $Version = $WinRARD.Version
        $URL = $WinRARD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download WinSCP
    If ($WinSCP -eq 1) {
        $Product = "WinSCP"
        $PackageName = "WinSCP"
        $WinSCPD = Get-EvergreenApp -Name WinSCP | Where-Object {$_.URI -like "*Setup*"}
        $Version = $WinSCPD.Version
        $URL = $WinSCPD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $CurrentVersion = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Wireshark
    If ($Wireshark -eq 1) {
        $Product = "Wireshark"
        $PackageName = "Wireshark-" + "$WiresharkArchitectureClear"
        $WiresharkD = Get-EvergreenApp -Name Wireshark | Where-Object { $_.Architecture -eq "$WiresharkArchitectureClear" -and $_.Type -eq "exe"} | Sort-Object Version -Descending |Select-Object -First 1
        $Version = $WiresharkD.Version
        $URL = $WiresharkD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "exe"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WiresharkArchitectureClear" + ".txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product $WiresharkArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.exe" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product $WiresharkArchitectureClear version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download XCA
    If ($XCA -eq 1) {
        $Product = "XCA"
        $PackageName = "XCA"
        $XCAD = Get-XCA
        $Version = $XCAD.Version
        $URL = $XCAD.uri
        Add-Content -Path "$FWFile" -Value "$URL"
        $InstallerType = "msi"
        $Source = "$PackageName" + "." + "$InstallerType"
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        Write-Host -ForegroundColor Magenta "Download $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CurrentVersion"
        If ($CurrentVersion -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                If ($Repository -eq '1') {
                    If ($CurrentVersion) {
                        Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                        If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                        Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                    }
                }
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                Start-Transcript $LogPS | Out-Null
                Set-Content -Path "$VersionPath" -Value "$Version"
            }
            Write-Host "Starting download of $Product version $Version"
            If ($WhatIf -eq '0') {
                Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                Write-Verbose "Stop logging"
                Stop-Transcript | Out-Null
            }
            Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
            Write-Output ""
        }
        Else {
            Write-Host -ForegroundColor Cyan "No new version available"
            Write-Output ""
        }
    }

    #// Mark: Download Zoom
    If ($Zoom -eq 1) {
        If ($ZoomCitrixClient -eq 0) {
            If ($ZoomInstallerClear -eq 'User Based') {
                $Product = "Zoom"
                $PackageName = "ZoomInstallerFull" + "$ZoomArchitectureClear"
                $ZoomD = Get-NevergreenApp -Name Zoom -WarningAction:SilentlyContinue | Where-Object {$_.Name -eq "Zoom" -and $_.Architecture -eq "$ZoomArchitectureClear" -and $_.Type -eq "Msi"}
                $Version = $ZoomD.Version
                $VersionSplit = $Version.split(".")
                $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[3]
                $URL = $ZoomD.uri
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "msi"
                $Source = "$PackageName" + "." + "$InstallerType"
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ZoomArchitectureClear" + ".txt"
                $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product $ZoomArchitectureClear"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -lt $Version) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) { New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null }
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$VersionPath" -Value "$Version"
                    }
                    Write-Host "Starting download of $Product $ZoomArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($Source))
                        #Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version finished!"
                    Write-Output ""
                    $PackageNameP = "ZoomADMX"
                    $ZoomDP = Get-ZoomAdmx
                    $VersionP = $ZoomDP.version
                    $URL = $ZoomDP.uri
                    Add-Content -Path "$FWFile" -Value "$URL"
                    $InstallerTypeP = "zip"
                    $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
                    $FolderP = "Zoom_" + "$VersionP"
                    Write-Host "Starting download of $Product ADMX files version $VersionP"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                        expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                        Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                        If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                        If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetings_HKCU.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetings_HKLM.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetingsGlobalPolicy.reg" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                        If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKCU.adml" -PathType leaf)) {
                            Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKCU.adml" -ErrorAction SilentlyContinue
                            Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKLM.adml" -ErrorAction SilentlyContinue
                        }
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\en-US\ZoomMeetings_HKCU.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\en-US\ZoomMeetings_HKLM.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                        Remove-Item -Path "$PSScriptRoot\$Product\$FolderP" -Force -Recurse -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
            If ($ZoomInstallerClear -eq 'Machine Based') {
                $Product = "Zoom VDI"
                $PackageName = "ZoomInstallerVDI"
                $ZoomD = Get-ZoomVDI
                $Version = $ZoomD.Version
                $VersionApps = $ZoomD.VersionApps
                $URL = $ZoomD.uri
                Add-Content -Path "$FWFile" -Value "$URL"
                $InstallerType = "msi"
                $Source = "$PackageName" + "." + "$InstallerType"
                $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
                $CurrentVersion = Get-Content -Path "$VersionPath" -EA SilentlyContinue
                Write-Host -ForegroundColor Magenta "Download $Product"
                Write-Host "Download Version: $VersionApps"
                Write-Host "Current Version:  $CurrentVersion"
                If ($CurrentVersion -lt $VersionApps) {
                    Write-Host -ForegroundColor Green "Update available"
                    If ($WhatIf -eq '0') {
                        If (!(Test-Path -Path "$PSScriptRoot\$Product")) {New-Item -Path "$PSScriptRoot\$Product" -ItemType Directory | Out-Null}
                        $LogPS = "$PSScriptRoot\$Product\" + "$Product $Version.log"
                        If ($Repository -eq '1') {
                            If ($CurrentVersion) {
                                Write-Host "Copy $Product installer version $CurrentVersion to repository folder"
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product")) { New-Item -Path "$PSScriptRoot\_Repository\$Product" -ItemType Directory | Out-Null }
                                If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion")) { New-Item -Path "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ItemType Directory | Out-Null }
                                Copy-Item -Path "$PSScriptRoot\$Product\*.msi" -Destination "$PSScriptRoot\_Repository\$Product\$CurrentVersion" -ErrorAction SilentlyContinue
                                Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion finished!"
                            }
                        }
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                        Start-Transcript $LogPS | Out-Null
                        Set-Content -Path "$PSScriptRoot\$Product\Version.txt" -Value "$VersionApps"
                    }
                    Write-Host "Starting download of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Invoke-WebRequest -Uri $URL -OutFile ("$PSScriptRoot\$Product\" + ($Source))
                        #Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                        Write-Verbose "Stop logging"
                        Stop-Transcript | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Download of the new version $Version version finished!"
                    Write-Output ""
                    $PackageNameP = "ZoomADMX"
                    $ZoomDP = Get-ZoomAdmx
                    $VersionP = $ZoomDP.version
                    $URL = $ZoomDP.uri
                    Add-Content -Path "$FWFile" -Value "$URL"
                    $InstallerTypeP = "zip"
                    $SourceP = "$PackageNameP" + "." + "$InstallerTypeP"
                    $FolderP = "Zoom_" + "$VersionP"
                    Write-Host "Starting download of $Product ADMX files version $VersionP"
                    If ($WhatIf -eq '0') {
                        Get-Download $URL "$PSScriptRoot\$Product\" $SourceP -includeStats
                        expand-archive -path "$PSScriptRoot\$Product\$SourceP" -destinationpath "$PSScriptRoot\$Product"
                        Remove-Item -Path "$PSScriptRoot\$Product\$SourceP" -Force -ErrorAction SilentlyContinue
                        If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                        If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetings_HKCU.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetings_HKLM.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\ZoomMeetingsGlobalPolicy.reg" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                        If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                        If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKCU.adml" -PathType leaf)) {
                            Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKCU.adml" -ErrorAction SilentlyContinue
                            Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\ZoomMeetings_HKLM.adml" -ErrorAction SilentlyContinue
                        }
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\en-US\ZoomMeetings_HKCU.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                        Move-Item -Path "$PSScriptRoot\$Product\$FolderP\en-US\ZoomMeetings_HKLM.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                        Remove-Item -Path "$PSScriptRoot\$Product\$FolderP" -Force -Recurse -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Download of the new ADMX files version $VersionP finished!"
                    Write-Output ""
                }
                Else {
                    Write-Host -ForegroundColor Cyan "No new version available"
                    Write-Output ""
                }
            }
        }
        If ($ZoomCitrixClient -eq 1) {
            $Product2 = "Zoom Citrix HDX Media Plugin"
            $PackageName2 = "ZoomCitrixHDXMediaPlugin"
            $ZoomCitrix = Get-NevergreenApp -Name Zoom -EA SilentlyContinue -WarningAction:SilentlyContinue | Where-Object {$_.Name -like "*Citrix*"}
            $URL2 = $ZoomCitrix.uri
            $Version2 = $ZoomCitrix.version
            $InstallerType2 = "msi"
            Add-Content -Path "$FWFile" -Value "$URL2"
            $Source2 = "$PackageName2" + "." + "$InstallerType2"
            $CurrentVersion2 = Get-Content -Path "$PSScriptRoot\$Product2\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Download $Product2" -Verbose
            Write-Host "Download Version: $Version2"
            Write-Host "Current Version:  $CurrentVersion2"
            If ($CurrentVersion2 -lt $Version2) {
                Write-Host -ForegroundColor Green "Update available"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path "$PSScriptRoot\$Product2")) {New-Item -Path "$PSScriptRoot\$Product2" -ItemType Directory | Out-Null}
                    $LogPS = "$PSScriptRoot\$Product2\" + "$Product2 $Version2.log"
                    If ($Repository -eq '1') {
                        If ($CurrentVersion2) {
                            Write-Host "Copy $Product2 installer version $CurrentVersion2 to repository folder"
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product2")) { New-Item -Path "$PSScriptRoot\_Repository\$Product2" -ItemType Directory | Out-Null }
                            If (!(Test-Path -Path "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2")) { New-Item -Path "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2" -ItemType Directory | Out-Null }
                            Copy-Item -Path "$PSScriptRoot\$Product2\*.msi" -Destination "$PSScriptRoot\_Repository\$Product2\$CurrentVersion2" -ErrorAction SilentlyContinue
                            Write-Host -ForegroundColor Green "Copy of the current version $CurrentVersion2 finished!"
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product2\*" -Recurse
                    Start-Transcript $LogPS | Out-Null
                    Set-Content -Path "$PSScriptRoot\$Product2\Version.txt" -Value "$Version2"
                }
                Write-Host "Starting download of $Product2 version $Version2"
                If ($WhatIf -eq '0') {
                    Invoke-WebRequest -Uri $URL2 -OutFile ("$PSScriptRoot\$Product2\" + ($Source2))
                    #Get-Download $URL "$PSScriptRoot\$Product2\" $Source2 -includeStats
                    Write-Verbose "Stop logging"
                    Stop-Transcript | Out-Null
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version2 finished!"
                Write-Output ""
            }
            Else {
                Write-Host -ForegroundColor Cyan "No new version available"
                Write-Output ""
            }
        }
    }
}

If ($Install -eq "1") {

    If ($Installer -eq 0) {
        Write-Host "Change User Mode to Install."
        Write-Output ""
        Change User /Install | Out-Null
    }

    Write-Host -ForegroundColor DarkGray "Starting installs..."
    Write-Output ""

    # Logging
    # Global variables
    # $StartDir = $PSScriptRoot # the directory path of the script currently being executed
    $LogDir = "$PSScriptRoot\_Install Logs"
    $LogFileName = ("$ENV:COMPUTERNAME - $Date.log")
    $LogFile = Join-path $LogDir $LogFileName
    $FWFileName = ("Firewall - $Date.log")
    $FWFile = Join-path $LogDir $FWFileName
    $LogTemp = "$env:windir\Logs\Neverred"

    # Create the log directories if they don't exist
    If (!(Test-Path $LogDir)) { New-Item -Path $LogDir -ItemType directory | Out-Null }
    If (!(Test-Path $LogTemp)) { New-Item -Path $LogTemp -ItemType directory | Out-Null }

    # Create new log file (overwrite existing one)
    New-Item $LogFile -ItemType "file" -force | Out-Null
    DS_WriteLog "I" "START SCRIPT - " $LogFile
    DS_WriteLog "-" "" $LogFile

    # Install script part (AddScript)

    If ($WhatIf -eq '1') {
        Write-Host -BackgroundColor Magenta "WhatIf Mode, nothing will be installed !!!"
        Write-Host -BackgroundColor Green "The Install log will be created !!!"
        Write-Output ""
    }

    #// Mark: Install 1Password
    If ($1Password -eq 1) {
        $Product = "1Password"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $1PasswordD.Version
        }
        $1PasswordV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$1PasswordV) {
            $1PasswordV = (Get-ItemProperty HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* -ErrorAction SilentlyContinue | Where-Object {$_.DisplayName -like "*1Password*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $1PasswordInstaller = "1Password-Setup.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $1PasswordV"
        If ($1PasswordV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$1PasswordInstaller"
                }
                $p = Get-Process 1Password-Setup -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\1Password.lnk") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\1Password.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install 7 Zip
    If ($7ZIP -eq 1) {
        $Product = "7-Zip"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$7ZipArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $7ZipD.Version
        }
        $SevenZip = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*7-Zip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SevenZip) {
            $SevenZip = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*7-Zip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $7ZipInstaller = "7-Zip_" + "$7ZipArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $7ZipArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $SevenZip"
        If ($SevenZip -lt $Version) {
            DS_WriteLog "I" "Install $Product $7ZipArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $7ZipArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$7ZipInstaller" -ArgumentList /S
                }
                $p = Get-Process 7-Zip_$7ZipArchitectureClear -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $7ZipArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\7-Zip") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\7-Zip" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $7ZipArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $7ZipArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Adobe Pro DC
    If ($AdobeProDC -eq 1) {
        $Product = "Adobe Pro DC"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeProArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $AdobeProD.Version
        }
        $Adobe = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Adobe Acrobat DC"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Adobe) {
            $Adobe = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Adobe Acrobat DC"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $AdobeProLog = "$LogTemp\AdobePro.log"
        $InstallMSI = "$PSScriptRoot\$Product\AcroPro.msi"
        Write-Host -ForegroundColor Magenta "Install $Product $AdobeProArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $Adobe"
        If ($Adobe -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            If (!($Adobe)) {
                Try {
                    Write-Host "Starting install of $Product"
                    $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/quiet"
                    "/L*V $AdobeProLog"
                    "/qb IGNOREVCRT64=1 EULA_ACCEPT=YES UPDATE_MODE=0 DISABLE_ARM_SERVICE_INSTALL=1 ROAMIDENTITY=1 ROAMLICENSING=1"
                    )
                    If ($WhatIf -eq '0') {
                        $inst = $process = Start-Process -FilePath msiexec.exe -ArgumentList $Arguments -NoNewWindow -PassThru
                    }
                    If ($inst) {
                        Wait-Process -InputObject $inst
                    }
                    If ($process.ExitCode -eq 0) {
                        Write-Host -ForegroundColor Green "Install of $Product finished!"
                        DS_WriteLog "I" "Installation $Product finished!" $LogFile
                    }
                    Get-Content $AdobeProLog | Add-Content $LogFile -Encoding ASCII
                    Remove-Item $AdobeProLog
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                }
            }
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $AdobeProArchitectureClear version $Version"
                $UpdateMSP = "$PSScriptRoot\$Product\Adobe_Pro_DC_Update_" + "$AdobeProArchitectureClear" + ".msp"
                $mspArgs = @(
                    "/P"
                    "`"$UpdateMSP`""
                    "/quiet"
                    )
                If ($WhatIf -eq '0') {
                    $inst = $process = Start-Process -FilePath msiexec.exe -ArgumentList $mspArgs -NoNewWindow -PassThru
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                }
                If ($process.ExitCode -eq 0) {
                    DS_WriteLog "I" "Installation $Product $AdobeProArchitectureClear finished!" $LogFile
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $AdobeProArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $AdobeProArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Try {
                # Disable update service and scheduled task
                $Service = Get-Service -Name AdobeARMservice -ErrorAction SilentlyContinue
                If ($Service.Length -gt 0) {
                    Write-Host "Customize Service"
                    If ($WhatIf -eq '0') {
                        Stop-Service AdobeARMservice
                        Set-Service AdobeARMservice -StartupType Disabled
                    }
                    Write-Host -ForegroundColor Green "Stop and Disable Service $Product finished!"
                }
                Write-Host "Customize Scheduled Task"
                If ($WhatIf -eq '0') {
                    Get-ScheduledTask -TaskName Adobe* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                }
                Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                Write-Host -ForegroundColor Green "Customize scripts $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Adobe Reader DC
    If ($AdobeReaderDC -eq 1) {
        $Product = "Adobe Reader DC"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdobeArchitectureClear" + "_$AdobeLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $AdobeReaderD.Version
        }
        $Adobe = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Adobe Acrobat*" -and $_.DisplayName -notlike "*DC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Adobe) {
            $Adobe = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Adobe Acrobat*" -and $_.DisplayName -notlike "*DC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $AdobeReaderInstaller = "Adobe_Reader_DC_" + "$AdobeArchitectureClear" + "$AdobeLanguageClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $AdobeLanguageClear $AdobeArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $Adobe"
        If ($Adobe -lt $Version) {
            DS_WriteLog "I" "Install $Product $AdobeLanguageClear $AdobeArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/sAll"
                "/rs"
                "/msi EULA_ACCEPT=YES ENABLE_OPTIMIZATION=YES DISABLEDESKTOPSHORTCUT=1 UPDATE_MODE=0 DISABLE_ARM_SERVICE_INSTALL=1 DISABLE_CACHE=1 DISABLE_PDFMAKER=YES ALLUSERS=1"
            )
            Try {
                Write-Host "Starting install of $Product $AdobeLanguageClear $AdobeArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$AdobeReaderInstaller" -ArgumentList $Options
                }
                $p = Get-Process Adobe_Reader_DC_$AdobeArchitectureClear$AdobeLanguageClear -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Adobe Acrobat DC.lnk") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Adobe Acrobat DC.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $AdobeLanguageClear $AdobeArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $AdobeLanguageClear $AdobeArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Try {
                # Disable update service and scheduled task
                $Service = Get-Service -Name AdobeARMservice -ErrorAction SilentlyContinue
                If ($Service.Length -gt 0) {
                    Write-Host "Customize Service"
                    If ($WhatIf -eq '0') {
                        Stop-Service AdobeARMservice
                        Set-Service AdobeARMservice -StartupType Disabled
                    }
                    Write-Host -ForegroundColor Green "Stop and Disable Service $Product finished!"
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            Try {
                Write-Host "Customize Scheduled Task"
                If ($WhatIf -eq '0') {
                    Get-ScheduledTask -TaskName Adobe* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                }
                Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                Write-Host -ForegroundColor Green "Customize scripts $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Adopt Open JDK
    If ($AdoptOpenJDK -eq 1) {
        $Product = "Adopt Open JDK"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$AdoptOpenJDKVersionClear" + "_$AdoptOpenJDKArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $AdoptOpenJDKD.Version
        }
        Switch ($AdoptOpenJDKVersionClear) {
            8 { 
                $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt*8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$AdoptOpenJDKV) {
                    $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt*8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
             }
            11 { 
                $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$AdoptOpenJDKV) {
                    $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt*11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            16 {
                $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt*16*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$AdoptOpenJDKV) {
                    $AdoptOpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Adopt*16*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
        }
        $AdoptOpenJDKLog = "$LogTemp\AdoptOpenJDK.log"
        $PackageName = "AdoptOpenJDK_" + "$AdoptOpenJDKVersionClear" + "_$AdoptOpenJDKArchitectureClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$PackageName"
        Write-Host -ForegroundColor Magenta "Install $Product $AdoptOpenJDKVersionClear $AdoptOpenJDKArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $AdoptOpenJDKV"
        If ($AdoptOpenJDKV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $AdoptOpenJDKLog"
                "/norestart"
            )
            Try {
                Write-Host "Starting install of $Product $AdoptOpenJDKVersionClear $AdoptOpenJDKArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $AdoptOpenJDKLog | Add-Content $LogFile -Encoding ASCII
                Remove-Item $AdoptOpenJDKLog
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        #// Mark: Install Adopt Open JDK Iced Tea Web
        If ($AdoptOpenJDKIcedTeaWeb -eq 1) {
            $Product = "Adopt Open JDK Iced Tea Web"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version.txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $AdoptOpenJDKITWD.Version
            }
            $AdoptOpenJDKITWV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IcedTea-Web*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$AdoptOpenJDKITWV) {
                $AdoptOpenJDKITWV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IcedTea-Web*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $AdoptOpenJDKITWLog = "$LogTemp\AdoptOpenJDKITW.log"
            $PackageName = "AdoptOpenJDKIcedTeaWeb.msi"
            $InstallMSI = "$PSScriptRoot\$Product\$PackageName"
            Write-Host -ForegroundColor Magenta "Install $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $AdoptOpenJDKITWV"
            If ($AdoptOpenJDKITWV -lt $Version) {
                DS_WriteLog "I" "Install $Product" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/qn"
                    "/L*V $AdoptOpenJDKITWLog"
                    "/norestart"
                )
                Try {
                    Write-Host "Starting install of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                    }
                    Get-Content $AdoptOpenJDKITWLog | Add-Content $LogFile -Encoding ASCII
                    Remove-Item $AdoptOpenJDKITWLog
                } Catch {
                    DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Autodesk DWG TrueView
    If ($AutodeskDWGTrueView -eq 1) {
        $Product = "Autodesk DWG TrueView"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $AutodeskDWGTrueViewD.Version
        }
        $DWGTrueView = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*DWG TrueView*"}).DisplayName | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$DWGTrueView) {
            $DWGTrueView = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*DWG TrueView*"}).DisplayName | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($DWGTrueView) {$DWGTrueViewV = $DWGTrueView.split(" ")[2]}
        $AutodeskDWGTrueViewInstaller = "AutodeskDWGTrueView.exe"
        $InstallMSI = "$PSScriptRoot\$Product\DWGTrueView_2023_English_64bit_dlm\x64\dwgviewr\dwgviewr.msi"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $DWGTrueViewV"
        If ($DWGTrueViewV -lt $Version) {
            DS_WriteLog "I" "Unpacking $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "-suppresslaunch"
                "-d"
                "`"$PSScriptRoot\$Product`""
            )
            Try {
                Write-Host "Starting unpacking of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$AutodeskDWGTrueViewInstaller" -ArgumentList $Options
                }
                $p = Get-Process AutodeskDWGTrueView -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Unpacking of the new version $Version finished!"
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error unpacking $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error unpacking $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "I" "Install $Product" $LogFile
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qb ADSK_EULA_STATUS=#1 REBOOT=ReallySuppress ADSK_SETUP_EXE=1"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If (Test-Path -Path "$env:PUBLIC\Desktop\DWG TrueView*.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\DWG TrueView*.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\DWG TrueView*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\DWG TrueView*" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install BIS-F
    If ($BISF -eq 1) {
        $Product = "BIS-F"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $BISFD.Version
        }
        $BISFV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Base Image*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$BISFV) {
            $BISFV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Base Image*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($BISFV) {
            $BISFSplit = $BISFV.split(".")
            $BISFV = $BISFSplit[0] + "." + $BISFSplit[1] + "." + $BISFSplit[2]
        }
        $BISFLog = "$LogTemp\BISF.log"
        $InstallMSI = "$PSScriptRoot\$Product\setup-BIS-F.msi"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $BISFV"
        If ($BISFV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $BISFLog"
                "/norestart"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $BISFLog | Add-Content $LogFile -Encoding ASCII
                Remove-Item $BISFLog
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            # Customize scripts, it's best practise to enable Task Offload and RSS and to disable DEP
            $BISFDir = "C:\Program Files (x86)\Base Image Script Framework (BIS-F)\Framework\SubCall"
            If (Test-Path -Path "$BISFDir") {
                Try {
                    Write-Host "Customize scripts $Product"
                    If ($WhatIf -eq '0') {
                        ((Get-Content "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -Raw -ErrorAction SilentlyContinue) -replace "DisableTaskOffload' -Value '1'","DisableTaskOffload' -Value '0'") | Set-Content -Path "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -ErrorAction SilentlyContinue
                        ((Get-Content "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -Raw -ErrorAction SilentlyContinue) -replace 'nx AlwaysOff','nx OptOut') | Set-Content -Path "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -ErrorAction SilentlyContinue
                        ((Get-Content "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -Raw -ErrorAction SilentlyContinue) -replace 'rss=disable','rss=enable') | Set-Content -Path "$BISFDir\Preparation\97_PrepBISF_PRE_BaseImage.ps1" -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Customize scripts $Product finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error when customizing scripts (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error when customizing scripts (Error: $($Error[0]))" $LogFile
                }
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
            Write-Host "Starting copy of $Product ADMX files version $Version"
            $BISFInstallFolder = "${env:ProgramFiles(x86)}\Base Image Script Framework (BIS-F)\ADMX"
            If ($WhatIf -eq '0') {
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\BaseImageScriptFramework.admx" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse -ErrorAction SilentlyContinue
                }
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$BISFInstallFolder\BaseImageScriptFramework.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\BaseImageScriptFramework.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\BaseImageScriptFramework.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$BISFInstallFolder\en-US\BaseImageScriptFramework.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Copy of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        If ($BISF_Tools -eq 1) {
            $Product1 = "Citrix Optimizer"
            $Product2 = "SDelete"
            $Product3 = "DelProf2"
            # Check, if a new version is available
            $Version1 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product1\Version.txt" -EA SilentlyContinue
            If (!($Version1)) {
                $Version1 = $CitrixOptimizerD.Version
            }
            $CitrixOptimizerV = Get-Content -Path "C:\Program Files\$Product1\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Copy $Product1"
            Write-Host "Download Version: $Version1"
            Write-Host "Current Version:  $CitrixOptimizerV"
            If ($CitrixOptimizerV -lt $Version1) {
                DS_WriteLog "I" "Copy $Product1" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Write-Host "Starting copy of $Product1 version $Version1"
                If ($WhatIf -eq '0') {
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product1\$Product1\" -Destination "C:\Program Files\$Product1" -ErrorAction SilentlyContinue -Recurse -Force
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product1\Version.txt" -Destination "C:\Program Files\$Product1" -ErrorAction SilentlyContinue -Force
                }
                Write-Host -ForegroundColor Green "Copy of the new version $Version1 finished!"
                DS_WriteLog "I" "Copy $Product1 finished!" $LogFile
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product1"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\BIS-F\$Product1\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product1 install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            $Version2 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product2\Version.txt" -EA SilentlyContinue
            If (!($Version2)) {
                $Version2 = $SDeleteD.Version
            }
            $SDeleteV = Get-Content -Path "C:\Windows\System32\$Product2\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Copy $Product2"
            Write-Host "Download Version: $Version2"
            Write-Host "Current Version:  $SDeleteV"
            If ($SDeleteV -lt $Version2) {
                DS_WriteLog "I" "Copy $Product2" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Write-Host "Starting copy of $Product2 version $Version2"
                If ($WhatIf -eq '0') {
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product2\sdelete64.exe" -Destination "C:\Windows\System32\sdelete64.exe" -ErrorAction SilentlyContinue -Force
                    If (!(Test-Path -Path "C:\Windows\System32\$Product2")) { New-Item -Path "C:\Windows\System32\$Product2" -ItemType Directory | Out-Null }
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product2\Version.txt" -Destination "C:\Windows\System32\$Product2" -ErrorAction SilentlyContinue -Force
                }
                Write-Host -ForegroundColor Green "Copy of the new version $Version2 finished!"
                DS_WriteLog "I" "Copy $Product2 finished!" $LogFile
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product2"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\BIS-F\$Product2\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product2 install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            $Version3 = Get-Content -Path "$PSScriptRoot\BIS-F\$Product3\Version.txt" -EA SilentlyContinue
            If (!($Version3)) {
                $Version3 = $DelProf2D.Version
            }
            $DelProf2V = Get-Content -Path "C:\Windows\System32\$Product3\Version.txt" -EA SilentlyContinue
            Write-Host -ForegroundColor Magenta "Copy $Product3"
            Write-Host "Download Version: $Version3"
            Write-Host "Current Version:  $DelProf2V"
            If ($DelProf2V -lt $Version3) {
                DS_WriteLog "I" "Copy $Product3" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Write-Host "Starting copy of $Product3 version $Version3"
                If ($WhatIf -eq '0') {
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product3\DelProf2.exe" -Destination "C:\Windows\System32\DelProf2.exe" -ErrorAction SilentlyContinue -Force
                    If (!(Test-Path -Path "C:\Windows\System32\$Product3")) { New-Item -Path "C:\Windows\System32\$Product3" -ItemType Directory | Out-Null }
                    Copy-Item -Path "$PSScriptRoot\BIS-F\$Product3\Version.txt" -Destination "C:\Windows\System32\$Product3" -ErrorAction SilentlyContinue -Force
                }
                Write-Host -ForegroundColor Green "Copy of the new version $Version3 finished!"
                Write-Output ""
                DS_WriteLog "I" "Copy $Product3 finished!" $LogFile
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product3"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\BIS-F\$Product3\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product3 install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Bloomberg Terminal
    If ($Bloomberg -eq 1) {
        $Product = "Bloomberg Terminal"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $BloombergD.Version
        }
        $BloombergV = (Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Bloomberg L.P.\Components" | Where-Object {$_.sotr_version -ne ""}).sotr_version | Sort-Object -Property Version -Descending | Select-Object -First 1
        $BloombergInstaller = "sotr.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $BloombergV"
        If ($BloombergV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$BloombergInstaller" -ArgumentList /S
                }
                $p = Get-Process sotr -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Bloomberg") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Bloomberg" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Cisco Webex Teams
    If ($CiscoWebexTeams -eq 1) {
        If ($CiscoWebexTeamsClient -eq "0") {
            $Product = "Cisco Webex Teams"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $WebexTeamsD.Version
            }
            $CiscoSplit = $Version.split(".")
            $CiscoStringMiddle = ([regex]::Matches($CiscoSplit[1], "." )).count
            If ($CiscoStringMiddle -lt "2") {
                $CiscoSplit[1] = "0" + $CiscoSplit[1]
                $Version = $CiscoSplit[0] + "." + $CiscoSplit[1] + "." + $CiscoSplit[2] + "." + $CiscoSplit[3]
            }
            $CiscoWebexTeamsV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$CiscoWebexTeamsV) {
                $CiscoWebexTeamsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $CiscoDSplit = $CiscoWebexTeamsV.split(".")
            $CiscoDStringMiddle = ([regex]::Matches($CiscoDSplit[1], "." )).count
            If ($CiscoDStringMiddle -lt "2") {
                $CiscoDSplit[1] = "0" + $CiscoDSplit[1]
                $CiscoWebexTeamsV = $CiscoDSplit[0] + "." + $CiscoDSplit[1] + "." + $CiscoDSplit[2] + "." + $CiscoDSplit[3]
            }
            $WebexLog = "$LogTemp\WebexTeams.log"
            $InstallMSI = "$PSScriptRoot\$Product\webexteams-" + "$CiscoWebexTeamsArchitectureClear" + ".msi"
            Write-Host -ForegroundColor Magenta "Install $Product $CiscoWebexTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $CiscoWebexTeamsV"
            If ($CiscoWebexTeamsV -lt $Version) {
                DS_WriteLog "I" "Install $Product $CiscoWebexTeamsArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/quiet"
                    "/L*V $WebexLog"
                    "ACCEPT_EULA=TRUE ALLUSERS=1 AUTOSTART_WITH_WINDOWS=false"
                )
                Try {
                    Write-Host "Starting install of $Product $CiscoWebexTeamsArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Webex") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Webex" -Recurse -Force}
                        }
                    }
                    Get-Content $WebexLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $WebexLog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product $CiscoWebexTeamsArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
        If ($CiscoWebexTeamsClient -eq "1") {
            $Product = "Cisco Webex Teams VDI Plugin"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$CiscoWebexTeamsArchitectureClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $WebexTeamsVDID.Version
            }
            $WebexTeamsVDIV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex VDI Plugin"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$WebexTeamsVDIV) {
                $WebexTeamsVDIV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Webex VDI Plugin"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $WebexTeamsVDILog = "$LogTemp\WebexTeamsVDI.log"
            $InstallMSI = "$PSScriptRoot\$Product\webexteamsvdiplugin-" + "$CiscoWebexTeamsArchitectureClear" + ".msi"
            Write-Host -ForegroundColor Magenta "Install $Product $CiscoWebexTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $WebexTeamsVDIV"
            If ($WebexTeamsVDIV -lt $Version) {
                DS_WriteLog "I" "Install $Product $CiscoWebexTeamsArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/quiet"
                    "/L*V $WebexTeamsVDILog"
                    "ACCEPT_EULA=TRUE ALLUSERS=1 AUTOSTART_WITH_WINDOWS=false"
                )
                Try {
                    Write-Host "Starting install of $Product $CiscoWebexTeamsArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Webex") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Webex" -Recurse -Force}
                        }
                    }
                    Get-Content $WebexTeamsVDILog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $WebexTeamsVDILog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product $CiscoWebexTeamsArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }
    
    #// Mark: Install Citrix Files
    If ($CitrixFiles -eq 1) {
        $Product = "Citrix Files"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $CitrixFilesD.Version
        }
        $CitrixFilesV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Files*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $CitrixFilesLog = "$LogTemp\CitrixFiles.log"
        $CitrixFilesInstaller = "CitrixFilesForWindows.msi"
        $InstallMSI = "$PSScriptRoot\Citrix\$Product\$CitrixFilesInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        If (!$CitrixFilesV) {
            $CitrixFilesV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Files*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CitrixFilesV"
        If ($CitrixFilesV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/quiet"
                "/norestart"
                "/L*V $CitrixFilesLog"
                )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Citrix") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Citrix" -Recurse -Force}
                    }
                }
                Get-Content $CitrixFilesLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $CitrixFilesLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Citrix Hypervisor Tools
    If ($Citrix_Hypervisor_Tools -eq 1) {
        $Product = "Citrix Hypervisor Tools"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\Citrix\$Product\Version_" + "$CitrixHypervisorToolsArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $CitrixHypervisor.Version
        }
        $HypTools = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Hypervisor*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $CitrixHypLog = "$LogTemp\CitrixHypervisor.log"
        $HypToolsInstaller = "managementagent" + "$CitrixHypervisorToolsArchitectureClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\Citrix\$Product\$HypToolsInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $CitrixHypervisorToolsArchitectureClear"
        If (!$HypTools) {
            $HypTools = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Hypervisor*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($HypTools) {$HypTools = $HypTools.Insert(3,'.0')}
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $HypTools"
        If ($HypTools -lt $Version) {
            DS_WriteLog "I" "Install $Product $CitrixHypervisorToolsArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/quiet"
                "/norestart"
                "/L*V $CitrixHypLog"
                )
            Try {
                Write-Host "Starting install of $Product $CitrixHypervisorToolsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $CitrixHypLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $CitrixHypLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $CitrixHypervisorToolsArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Citrix WorkspaceApp
    If ($Citrix_WorkspaceApp -eq 1) {
        $Product = "Citrix WorkspaceApp $CitrixWorkspaceAppReleaseClear"
        # Check, if a new version is available
        Switch ($CitrixWorkspaceAppRelease) {
            0 {$CWAInstaller = "CitrixWorkspaceApp.exe"}
            1 {$CWAInstaller = "CitrixWorkspaceApp.exe"}
            2 {$CWAInstaller = "CitrixWorkspaceAppWeb.exe"}
            3 {$CWAInstaller = "CitrixWorkspaceAppWeb.exe"}
        }
        $Version = Get-Content -Path "$PSScriptRoot\Citrix\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $WSACD.Version
        }
        If ($Version) {
            $CurrentWSASplit = $Version.split(".")
            $CurrentWSAStrings = ([regex]::Matches($Version, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            $CurrentWSAStringLast = ([regex]::Matches($CurrentWSASplit[3], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            If ($CurrentWSAStringLast -lt "3") {
                $CurrentWSASplit[3] = "0" + $CurrentWSASplit[3]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $Version = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $WSA = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*Trolley*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*Trolley*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*CWAInstaller*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*CWAInstaller*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*bootstrapperhelper*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$WSA) {
            $WSA = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Citrix Workspace*" -and $_.UninstallString -like "*bootstrapperhelper*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($WSA) {
            $CurrentWSASplit = $WSA.split(".")
            $CurrentWSAStrings = ([regex]::Matches($WSA, "\." )).count
            $CurrentWSAStringTwo = ([regex]::Matches($CurrentWSASplit[1], "." )).count
            $CurrentWSAStringLast = ([regex]::Matches($CurrentWSASplit[3], "." )).count
            If ($CurrentWSAStringTwo -lt "2") {
                $CurrentWSASplit[1] = "0" + $CurrentWSASplit[1]
            }
            If ($CurrentWSAStringLast -lt "3") {
                $CurrentWSASplit[3] = "0" + $CurrentWSASplit[3]
            }
            Switch ($CurrentWSAStrings) {
                1 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1]
                }
                2 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2]
                }
                3 {
                    $WSA = $CurrentWSASplit[0] + "." + $CurrentWSASplit[1] + "." + $CurrentWSASplit[2] + "." + $CurrentWSASplit[3]
                }
            }
        }
        $UninstallWSACR = "$PSScriptRoot\Citrix\ReceiverCleanupUtility\ReceiverCleanupUtility.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $WSA"
        If ($WSA -ne $Version) {
            DS_WriteLog "I" "Uninstall $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            # Citrix WSA Uninstallation
            Write-Host "Uninstall Citrix Workspace App / Receiver"
            DS_WriteLog "I" "Uninstall Citrix Workspace App / Receiver" $LogFile
            Try {
                If ($WhatIf -eq '0') {
                    Start-process $UninstallWSACR -ArgumentList '/silent /disableCEIP' -NoNewWindow -Wait
                }
                Write-Host -ForegroundColor Green "Uninstall Citrix Workspace App / Receiver finished!"
                DS_WriteLog "I" "Uninstallation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error uninstalling Citrix Workspace App / Receiver (Error: $($Error[0]))"
                DS_WriteLog "E" "Error Uninstalling Citrix Workspace App / Receiver (Error: $($Error[0]))" $LogFile
            }
            # Citrix WSA Installation
            $Options = @(
                "/forceinstall"
                "/silent"
                "/EnableCEIP=false"
                "/FORCE_LAA=1"
                "/AutoUpdateCheck=disabled"
                "/ALLOWADDSTORE=S"
                "/ALLOWSAVEPWD=S"
                "/includeSSON"
                "/ENABLE_SSON=Yes"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\Citrix\$Product\$CWAInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                Write-Host "Customize $Product"
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Citrix Workspace.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Citrix Workspace.lnk" -Force}
                    }
                    reg add "HKLM\SOFTWARE\Wow6432Node\Policies\Citrix" /v EnableX1FTU /t REG_DWORD /d 0 /f | Out-Null
                    reg add "HKCU\Software\Citrix\Splashscreen" /v SplashscreenShown /d 1 /f | Out-Null
                    reg add "HKLM\SOFTWARE\Policies\Citrix" /f /v EnableFTU /t REG_DWORD /d 0 | Out-Null
                }
                Write-Host -ForegroundColor Green "Customizing $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Host -ForegroundColor Yellow "System needs to reboot after installation!"
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\Citrix\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install ControlUp Agent
    If ($ControlUpAgent -eq 1) {
        $Product = "ControlUp Agent"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpAgentArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ControlUpAgentD.Version
        }
        $ControlUpAgentV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUpAgent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ControlUpAgentV) {
            $ControlUpAgentV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUpAgent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $CUAVSplit = $ControlUpAgentV.split(".")
        $CUCount = ([regex]::Matches($CUAVSplit[3], "." )).count
        If ($CUCount -lt "3") {
            $CUAVSplit[3] = "0" + $CUAVSplit[3]
            $ControlUpAgentV = $CUAVSplit[0] + "." + $CUAVSplit[1] + "." + $CUAVSplit[2] + "." + $CUAVSplit[3]
        }
        $ControlUpAgentLog = "$LogTemp\ControlUpAgent.log"
        $ControlUpAgentInstaller = "ControlUpAgent-" + "$ControlUpAgentArchitectureClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$ControlUpAgentInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $ControlUpAgentArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $ControlUpAgentV"
        If ($ControlUpAgentV -lt $Version) {
            DS_WriteLog "I" "Install $Product $ControlUpAgentArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "AUTHKEY=$ControlUpAgentAuthKey"
                "/qn"
                "/L*V $ControlUpAgentLog"
                )
            Try {
                Write-Host "Starting install of $Product $ControlUpAgentArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $ControlUpAgentLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $ControlUpAgentLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $ControlUpAgentArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install ControlUp Edge DX
    If ($ControlUpEdgeDX -eq 1) {
        $Product = "ControlUp Edge DX Agent Manager"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ControlUpEdgeDXD.Version
        }
        $ControlUpEdgeDXV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUp Edge DX - SIP Agent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ControlUpEdgeDXV) {
            $ControlUpEdgeDXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ControlUp Edge DX - SIP Agent"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $ControlUpEdgeDXLog = "$LogTemp\ControlUpEdgeDX.log"
        $ControlUpEdgeDXInstaller = "ControlUpEdgeDX-AgentManagerSetup.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$ControlUpEdgeDXInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $ControlUpEdgeDXInstallerClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $ControlUpEdgeDXV"
        If ($ControlUpEdgeDXV -lt $Version) {
            DS_WriteLog "I" "Install $Product $ControlUpEdgeDXInstallerClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            If ($ControlUpEdgeDXInstallerClear -eq "Machine Based"){
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "DEVREGCODE=$ControlUpEdgeDXDevRegCode"
                    "TENANT=$ControlUpEdgeDXTenantName"
                    "ONLYSTARTONBOOT=1"
                    "ALLUSERS=1"
                    "/qn"
                    "/L*V $ControlUpEdgeDXLog"
                    )
            } else {
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "DEVREGCODE=$ControlUpEdgeDXDevRegCode"
                    "TENANT=$ControlUpEdgeDXTenantName"
                    "ALLUSERS=1"
                    "/qn"
                    "/L*V $ControlUpEdgeDXLog"
                    )
            }
            Try {
                Write-Host "Starting install of $Product $ControlUpEdgeDXInstallerClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $ControlUpEdgeDXLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $ControlUpEdgeDXLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $ControlUpEdgeDXInstallerClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install ControlUp Remote DX
    If ($ControlUpRemoteDX -eq 1) {
        $Product = "ControlUp Remote DX"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ControlUpRemoteDXEUCClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        $ControlUpRemoteDXInstaller = "CURDX_Windows_" + "$ControlUpRemoteDXEUCDLClear" + ".exe"
        If (!($Version)) {
            $Version = $CURDXD.Version
        }
        $CURDXV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "ControlUp Remote DX - $ControlUpRemoteDXEUCDLClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$CURDXV) {
            $CURDXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "ControlUp Remote DX - $ControlUpRemoteDXEUCDLClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product for $ControlUpRemoteDXEUCClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $CURDXV"
        If ($CURDXV -lt $Version) {
            $Options = @(
                "/VERYSILENT"
            )
            DS_WriteLog "I" "Install $Product for $ControlUpRemoteDXEUCClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product for $ControlUpRemoteDXEUCClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$ControlUpRemoteDXInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product for $ControlUpRemoteDXEUCClear finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product for $ControlUpRemoteDXEUCClear finished!" $LogFile
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product for $ControlUpRemoteDXEUCClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product for $ControlUpRemoteDXEUCClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product for $ControlUpRemoteDXEUCClear"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product for $ControlUpRemoteDXEUCClear install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install deviceTRUST
    If ($deviceTRUST -eq 1) {
        $Product = "deviceTRUST"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version" + "_$deviceTRUSTArchitectureClear"+ ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $deviceTRUSTD.Version
        }
        $deviceTRUSTClientV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Client*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTClientV) {
            $deviceTRUSTClientV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Client*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        #If ($deviceTRUSTClientV.length -ne "8") {$deviceTRUSTClientV = $deviceTRUSTClientV -replace ".{2}$"}
        $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Host*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTHostV) {
            $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Host*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Agent*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTHostV) {
            $deviceTRUSTHostV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Agent*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        #If ($deviceTRUSTHostV.length -ne "8") {$deviceTRUSTHostV = $deviceTRUSTHostV -replace ".{2}$"}
        $deviceTRUSTConsoleV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Console*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$deviceTRUSTConsoleV) {
            $deviceTRUSTConsoleV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*deviceTRUST Console*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        #If ($deviceTRUSTConsoleV.length -ne "8") {$deviceTRUSTConsoleV = $deviceTRUSTConsoleV -replace ".{2}$"}
        $deviceTRUSTLog = "$LogTemp\deviceTRUST.log"
        $deviceTRUSTClientLog = "$LogTemp\deviceTRUST.txt"
        $deviceTRUSTClientInstaller = "dtclient-extension-release.exe"
        $deviceTRUSTHostInstaller = "dtagent-" + "$deviceTRUSTArchitectureClear" + "-release.msi"
        $deviceTRUSTConsoleInstaller = "dtconsole-" + "$deviceTRUSTArchitectureClear" + "-release.msi"
        If ($deviceTRUSTClient -eq $True) {
            Write-Host -ForegroundColor Magenta "Install $Product Client Extension"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $deviceTRUSTClientV"
            If ($deviceTRUSTClientV -lt $Version) {
                # deviceTRUST Client
                DS_WriteLog "I" "Install $Product Client Extension" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    $Options = @(
                        "/INSTALL"
                        "/QUIET"
                        "/NORESTART"
                        "/LOG $deviceTRUSTClientLog"
                    )
                    Write-Host "Starting install of $Product Client Extension version $Version"
                    If ($WhatIf -eq '0') {
                        Start-Process -FilePath "$PSScriptRoot\$Product\$deviceTRUSTClientInstaller" -ArgumentList $Options -PassThru -Wait -ErrorAction Stop | Out-Null
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\deviceTRUST*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\deviceTRUST*" -Recurse -Force}
                        }
                    }
                    Get-Content $deviceTRUSTClientLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $deviceTRUSTClientLog -ErrorAction SilentlyContinue
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product Client Extension (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product Client Extension (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product Client Extension"
                Write-Output ""
            }
        }
        If ($deviceTRUSTHost -eq $True) {
            Write-Host -ForegroundColor Magenta "Install $Product Agent $deviceTRUSTArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $deviceTRUSTHostV"
            If ($deviceTRUSTHostV -lt $Version) {
                # deviceTRUST Agent
                $Arguments = @(
                "/i"
                "`"$PSScriptRoot\$Product\$deviceTRUSTHostInstaller`""
                "/passive"
                "/quiet"
                "/norestart"
                "/L*V $deviceTRUSTLog"
                )
                DS_WriteLog "I" "Install $Product Agent $deviceTRUSTArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    Write-Host "Starting install of $Product Agent $deviceTRUSTArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $inst = Start-Process -FilePath msiexec.exe -ArgumentList $Arguments -PassThru -Wait -ErrorAction Stop | Out-Null
                        If ($inst) {
                            Wait-Process -InputObject $inst
                        }
                    }
                    Get-Content $deviceTRUSTLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $deviceTRUSTLog -ErrorAction SilentlyContinue
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product Agent $deviceTRUSTArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product Agent $deviceTRUSTArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product Host"
                Write-Output ""
            }
        }
        If ($deviceTRUSTConsole -eq $True) {
            Write-Host -ForegroundColor Magenta "Install $Product Console $deviceTRUSTArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $deviceTRUSTConsoleV"
            If ($deviceTRUSTConsoleV -lt $Version) {
                # deviceTRUST Console
                $Arguments = @(
                "/i"
                "`"$PSScriptRoot\$Product\$deviceTRUSTConsoleInstaller`""
                "/passive"
                "/quiet"
                "/norestart"
                "/L*V $deviceTRUSTLog"
                )
                DS_WriteLog "I" "Install $Product Console $deviceTRUSTArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $InstallMSI = "$PSScriptRoot\$Product\$deviceTRUSTConsoleInstaller"
                Try {
                    Write-Host "Starting install of $Product Console $deviceTRUSTArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $inst = Start-Process -FilePath msiexec.exe -ArgumentList $Arguments -PassThru -Wait -ErrorAction Stop | Out-Null
                        If ($inst) {
                            Wait-Process -InputObject $inst
                        }
                    }
                    Get-Content $deviceTRUSTLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $deviceTRUSTLog -ErrorAction SilentlyContinue
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product Console $deviceTRUSTArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product Console $deviceTRUSTArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product Console"
                Write-Output ""
            }
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Ditto
    If ($Ditto -eq 1) {
        $Product = "Ditto"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$DittoArchitectureClear" + "_$DittoChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $DittoD.Version
        }
        $DittoV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Ditto*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$DittoV) {
            $DittoV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Ditto*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $DittoInstaller = "Ditto-Setup-" + "$DittoArchitectureClear" + "-$DittoChannelClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $DittoChannelClear channel $DittoArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $DittoV"
        If ($DittoV -lt $Version) {
            $Options = @(
                "/VERYSILENT"
                "/NORESTART"
                "/MERGETASKS=addfirewallexception"
            )
            DS_WriteLog "I" "Install $Product $DittoChannelClear channel $DittoArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $DittoChannelClear channel $DittoArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$DittoInstaller" -ArgumentList $Options -ErrorAction Stop
                }
                $p = Get-Process Ditto-Setup-$DittoArchitectureClear-$DittoChannelClear -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $DittoChannelClear channel $DittoArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Ditto") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Ditto" -Recurse -Force}
                    }
                    If (!(Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1")) {
                        New-Item -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -ErrorAction SilentlyContinue | Out-Null
                        New-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -Name DisplayVersion -Value $Version -PropertyType REG_SZ -ErrorAction SilentlyContinue | Out-Null
                    }
                    Else {
                        If ((Test-RegistryValue2 -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -Value "DisplayVersion") -ne $true) {
                            New-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -Name DisplayVersion -Value $Version -PropertyType REG_SZ -ErrorAction SilentlyContinue | Out-Null
                        } Else {
                            New-Item -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -ErrorAction SilentlyContinue | Out-Null
                            New-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\Ditto_is1" -Name DisplayVersion -Value $Version -PropertyType REG_SZ -ErrorAction SilentlyContinue | Out-Null
                        }
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $DittoChannelClear channel $DittoArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $DittoChannelClear channel $DittoArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Filezilla
    If ($Filezilla -eq 1) {
        $Product = "Filezilla"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $FilezillaD.Version
        }
        $FilezillaV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Filezilla*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FilezillaV) {
            $FilezillaV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Filezilla*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $FilezillaV"
        If ($FilezillaV -lt $Version) {
            $Options = @(
                "/S"
                "/user=all"
            )
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\Filezilla-win64.exe" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\FileZilla FTP Client") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\FileZilla FTP Client" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Foxit PDF Editor
    If ($FoxitPDFEditor -eq 1) {
        $Product = "Foxit PDF Editor"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitPDFEditorLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $FoxitPDFEditorD.Version
        }
        $FoxitPDFEditorV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Foxit PDF Editor"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FoxitPDFEditorV) {
            $FoxitPDFEditorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Foxit PDF Editor"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $FoxitPDFEditorLog = "$LogTemp\FoxitPDFEditor.log"
        $FoxitPDFEditorInstaller = "FoxitPDFEditor-Setup-" + "$FoxitPDFEditorLanguageClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$FoxitPDFEditorInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $FoxitPDFEditorLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $FoxitPDFEditorV"
        If ($FoxitPDFEditorV -lt $Version) {
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/quiet"
                "/L*V $FoxitPDFEditorLog"
                "/NORESTART"
                "AUTO_UPDATE=0 LAUNCHCHECKDEFAULT=0 DESKTOP_SHORTCUT=0"
            )
            DS_WriteLog "I" "Install $Product $FoxitPDFEditorLanguageClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $FoxitPDFEditorLanguageClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $FoxitPDFEditorLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $FoxitPDFEditorLog -ErrorAction SilentlyContinue
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Foxit Reader.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Foxit Reader.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Foxit PDF Editor") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Foxit PDF Editor" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Foxit Reader
    If ($Foxit_Reader -eq 1) {
        $Product = "Foxit Reader"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FoxitReaderLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $Foxit_ReaderD.Version
        }
        $FReader = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$FReader) {
            $FReader = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}) {
            $UninstallFReader = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Foxit PDF Reader*"}).UninstallString.replace("/uninstall","")
        } else {
            $UninstallFReader = ""
        }
        $FoxitLog = "$LogTemp\FoxitReader.log"
        $FoxitReaderInstaller = "FoxitReader-Setup-" + "$FoxitReaderLanguageClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$FoxitReaderInstaller"
        If ($UninstallFReader) {
            $UninstallMSI = $UninstallFReader.split("I")[1]
        } else {
            $UninstallMSI = ""
        }
        Write-Host -ForegroundColor Magenta "Install $Product $FoxitReaderLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $FReader"
        If ($FReader -lt $Version) {
            # Foxit Reader Uninstall
            If ($UninstallMSI) {
                Write-Host "Uninstall $Product"
                DS_WriteLog "I" "Uninstall $Product" $LogFile
                Try {
                    If ($WhatIf -eq '0') {
                        msiexec.exe /x $UninstallMSI /quiet
                        Start-Sleep -s 60
                    }
                    Write-Host -ForegroundColor Green "Uninstall $Product finished!"
                    DS_WriteLog "I" "Uninstallation $Product finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error uninstalling $Product (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error uninstalling $Product (Error: $($Error[0]))" $LogFile
                }
            }
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $FoxitLog"
                "/NORESTART"
                "AUTO_UPDATE=0 LAUNCHCHECKDEFAULT=0 DESKTOP_SHORTCUT=0"
            )
            DS_WriteLog "I" "Install $Product $FoxitReaderLanguageClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $FoxitReaderLanguageClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $FoxitLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $FoxitLog -ErrorAction SilentlyContinue
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Foxit Reader.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Foxit Reader.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Foxit PDF Reader") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Foxit PDF Reader" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product $FoxitReaderLanguageClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install GIMP
    If ($GIMP -eq 1) {
        $Product = "GIMP"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $GIMPD.Version
        }
        $GIMPV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GIMP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GIMPV) {
            $GIMPV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GIMP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $GIMPV"
        If ($GIMPV -ne $Version) {
            $Options = @(
                "/VERYSILENT"
                "/NORESTART"
                "/ALLUSERS"
            )
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\gimp-setup.exe" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\GIMP*.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\GIMP*.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Git for Windows
    If ($GitForWindows -eq 1) {
        $Product = "Git for Windows"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GitForWindowsArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $GitForWindowsD.Version
        }
        $GitForWindowsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Git"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GitForWindowsV) {
            $GitForWindowsV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Git"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $GitForWindowsInstaller = "GitForWindows_" + "$GitForWindowsArchitectureClear" +".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $GitForWindowsArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $GitForWindowsV"
        If ($GitForWindowsV -lt $Version) {
            $Options = @(
                "/suppressmsgboxes"
                "/norestart"
                "/noicons"
                "/verysilent"
            )
            DS_WriteLog "I" "Install $Product $GitForWindowsArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $GitForWindowsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$GitForWindowsInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Git for Windows.lnk") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Git for Windows.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $GitForWindowsArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $GitForWindowsArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Google Chrome
    If ($GoogleChrome -eq 1) {
        $Product = "Google Chrome"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$GoogleChromeArchitectureClear" + "_$GoogleChromeChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ChromeD.Version
        }
        $ChromeSplit1 = $Version.split(".")
        $ChromeStrings1 = ([regex]::Matches($Version, "\." )).count
        $ChromeStringLast1 = ([regex]::Matches($ChromeSplit1[$ChromeStrings1], "." )).count
        $ChromeStringFirst1 = ([regex]::Matches($ChromeSplit1[0], "." )).count
        If ($ChromeStringLast1 -lt "3") {
            $ChromeSplit1[$ChromeStrings1] = "0" + $ChromeSplit1[$ChromeStrings1]
        }
        If ($ChromeStringFirst1 -lt "3") {
            $ChromeSplit1[0] = "0" + $ChromeSplit1[0]
        }
        Switch ($ChromeStrings1) {
            1 {
                $NewVersion1 = $ChromeSplit1[0] + "." + $ChromeSplit1[1]
            }
            2 {
                $NewVersion1 = $ChromeSplit1[0] + "." + $ChromeSplit1[1] + "." + $ChromeSplit1[2]
            }
            3 {
                $NewVersion1 = $ChromeSplit1[0] + "." + $ChromeSplit1[1] + "." + $ChromeSplit1[2] + "." + $ChromeSplit1[3]
            }
        }
        $Version = $NewVersion1
        If ($GoogleChromeChannelClear -eq "stable") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($GoogleChromeChannelClear -eq "dev") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($GoogleChromeChannelClear -eq "beta") {
            $Chrome = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Chrome) {
                $Chrome = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Google Chrome Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($Chrome) {
            $CurrentChromeSplit1 = $Chrome.split(".")
            $CurrentChromeStrings1 = ([regex]::Matches($Chrome, "\." )).count
            $CurrentChromeStringLast1 = ([regex]::Matches($CurrentChromeSplit1[$CurrentChromeStrings1], "." )).count
            $CurrentChromeStringFirst1 = ([regex]::Matches($CurrentChromeSplit1[0], "." )).count
            If ($CurrentChromeStringLast1 -lt "3") {
                $CurrentChromeSplit1[$CurrentChromeStrings1] = "0" + $CurrentChromeSplit1[$CurrentChromeStrings1]
            }
            If ($CurrentChromeStringFirst1 -lt "3") {
                $CurrentChromeSplit1[0] = "0" + $CurrentChromeSplit1[0]
            }
            Switch ($CurrentChromeStrings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1] + "." + $CurrentChromeSplit1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentChromeSplit1[0] + "." + $CurrentChromeSplit1[1] + "." + $CurrentChromeSplit1[2] + "." + $CurrentChromeSplit1[3]
                }
            }
        }
        $ChromeLog = "$LogTemp\GoogleChrome.log"
        $ChromeInstaller = "googlechromestandaloneenterprise_" + "$GoogleChromeArchitectureClear" + "_$GoogleChromeChannelClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$ChromeInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear"
        Write-Host "Download Version: $NewVersion1"
        Write-Host "Current Version:  $NewCurrentVersion1"
        If ($NewCurrentVersion1 -ne $NewVersion1) {
            DS_WriteLog "I" "Install $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $ChromeLog"
            )
            Try {
                Write-Host "Starting install of $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear version $NewVersion1"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $ChromeLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $ChromeLog -ErrorAction SilentlyContinue
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Google Chrome.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Google Chrome.lnk" -Force}
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Google Chrome Dev.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Google Chrome Dev.lnk" -Force}
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Google Chrome Beta.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Google Chrome Beta.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome.lnk" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome Dev.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome Dev.
                        lnk" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome Beta.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Google Chrome Beta.lnk" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product $GoogleChromeChannelClear channel $GoogleChromeArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Write-Host "Customize $Product"
            Try {
                # Disable Google Chrome auto update
                Write-Host "Customize $Product registry"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path HKLM:SOFTWARE\Policies\Google\Update)) {
                        New-Item -Path HKLM:SOFTWARE\Policies\Google\Update -ErrorAction SilentlyContinue | Out-Null
                        New-ItemProperty -Path HKLM:SOFTWARE\Policies\Google\Update -Name UpdateDefault -Value 0 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                    }
                    Else {
                        $ChromeUpdateState = Get-ItemProperty -path "HKLM:SOFTWARE\Policies\Google\Update" | Select-Object -Expandproperty "UpdateDefault"
                        If ($ChromeUpdateState -ne "0") {Set-ItemProperty -Path HKLM:SOFTWARE\Policies\Google\Update -Name UpdateDefault -Value 0 | Out-Null}
                    }
                }
                Write-Host -ForegroundColor Green "Customize $Product registry finished!"
                # Disable update service and scheduled task
                $Service = Get-Service -Name gupdate -ErrorAction SilentlyContinue
                If ($Service.Length -gt 0) {
                    Write-Host "Customize Service"
                    If ($WhatIf -eq '0') {
                        Stop-Service gupdate
                        Set-Service gupdate -StartupType Disabled
                        Stop-Service gupdatem
                        Set-Service gupdatem -StartupType Disabled
                    }
                    Write-Host -ForegroundColor Green "Stop and Disable Service $Product finished!"
                }
                Write-Host "Customize Scheduled Task"
                If ($WhatIf -eq '0') {
                    Get-ScheduledTask -TaskName GoogleUpdateTaskMachine* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                    Get-ScheduledTask -TaskName GPUpdate* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                }
                Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                Write-Host -ForegroundColor Green "Customize scripts $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Google Drive
    If ($GoogleDrive -eq 1) {
        $Product = "Google Drive"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $GoogleDriveD.Version
        }
        $GoogleDriveV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Google Drive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GoogleDriveV) {
            $GoogleDriveV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Google Drive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $GoogleDriveInstaller = "GoogleDrive.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $GoogleDriveV"
        If ($GoogleDriveV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$GoogleDriveInstaller" -ArgumentList --silent
                }
                $p = Get-Process GoogleDrive -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                    Stop-Process -Name "GoogleDriveFS" -Force -ErrorAction SilentlyContinue
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Google Drive") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Google Drive" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Greenshot
    If ($Greenshot -eq 1) {
        $Product = "Greenshot"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $GreenshotD.Version
        }
        $GreenshotV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Greenshot*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$GreenshotV) {
            $GreenshotV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Greenshot*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $GreenshotV"
        If ($GreenshotV -lt $Version) {
            $Options = @(
                "/VERYSILENT"
                "/NORESTART"
                "/NORESTARTAPPLICATIONS"
                "/SUPPRESSMSGBOXES"
                "/CLOSEAPPLICATIONS"
            )
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\Greenshot-INSTALLER-x86.exe" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Stop-Process -Name "$DefaultBrowser" -Force -ErrorAction SilentlyContinue
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Stop-Process -Name "$DefaultBrowser" -Force -ErrorAction SilentlyContinue
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Greenshot") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Greenshot" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install ImageGlass
    If ($ImageGlass -eq 1) {
        $Product = "ImageGlass"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ImageGlassArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ImageGlassD.Version
        }
        $ImageGlassV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ImageGlass"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $ChromeLog = "$LogTemp\ImageGlass.log"
        If (!$ImageGlassV) {
            $ImageGlassV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "ImageGlass"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $ImageGlassInstaller = "ImageGlass_" + "$ImageGlassArchitectureClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$ImageGlassInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $ImageGlassArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $ImageGlassV"
        If ($ImageGlassV -lt $Version) {
            DS_WriteLog "I" "Install $Product $ImageGlassArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/QUIET"
                "/L* $ImageGlassLog"
                "/NORESTART"
            )
            Try {
                Write-Host "Starting install of $Product $ImageGlassArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $ImageGlassLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $ImageGlassLog -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 10
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\ImageGlass.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\ImageGlass.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\ImageGlass") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\ImageGlass" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install IrfanView
    If ($IrfanView -eq 1) {
        $Product = "IrfanView"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$IrfanViewArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $IrfanViewD.Version
        }
        $IrfanViewV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IrfanView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$IrfanViewV) {
            $IrfanViewV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*IrfanView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $IrfanViewInstaller = "IrfanView" + "$IrfanViewArchitectureClear" +".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $IrfanViewLanguageLongClear $IrfanViewArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $IrfanViewV"
        If ($IrfanViewV -lt $Version) {
            $Options = @(
                "/assoc=1"
                "/group=1"
                "/ini=%APPDATA%\IrfanView"
                "/silent"
                "/allusers=1"
            )
            DS_WriteLog "I" "Install $Product $IrfanViewLanguageLongClear $IrfanViewArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $IrfanViewArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$IrfanViewInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else {
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\IrfanView") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\IrfanView" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $IrfanViewArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            If ($IrfanViewLanguageLongClear -ne "English") {
                Write-Host "Copy $Product language pack $IrfanViewLanguageLongClear"
                If ($WhatIf -eq '0') {
                    Switch ($IrfanViewArchitectureClear) {
                        x64 { 
                            If (Test-Path -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\Languages\*.lng") {
                                Move-Item -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\Languages\*" -Destination "$Env:ProgramFiles\IrfanView\Languages" -ErrorAction SilentlyContinue
                            }
                            If (Test-Path -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\*.lng") {
                                Move-Item -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\*" -Destination "$Env:ProgramFiles\IrfanView\Languages" -ErrorAction SilentlyContinue
                            }
                        }
                        x86 {
                            If (Test-Path -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\Languages\*.lng") {
                                Move-Item -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\Languages\*" -Destination "${Env:ProgramFiles(x86)}\IrfanView\Languages" -ErrorAction SilentlyContinue
                            }
                            If (Test-Path -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\*.lng") {
                                Move-Item -Path "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear\*" -Destination "${Env:ProgramFiles(x86)}\IrfanView\Languages" -ErrorAction SilentlyContinue
                            }
                        }
                    }
                    Remove-Item "$PSScriptRoot\$Product\$IrfanViewLanguageLongClear" -Recurse
                }
                Write-Host -ForegroundColor Green "Copy $Product language pack $IrfanViewLanguageLongClear finished!"
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Jabra Direct
    If ($JabraDirect -eq 1) {
        $Product = "Jabra Direct"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $JabraDirectD.Version
        }
        $JabraDirectV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Jabra Direct*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$JabraDirectV) {
            $JabraDirectV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Jabra Direct*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $JabraDirectInstaller = "JabraDirect.exe"
        $Options = @(
                "/install"
                "/quiet"
                "/norestart"
            )
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $JabraDirectV"
        If ($JabraDirectV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$JabraDirectInstaller" -ArgumentList $Options
                }
                $p = Get-Process JabraDirect -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Jabra Direct") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Jabra Direct" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install KeePass
    If ($KeePass -eq 1) {
        $Product = "KeePass"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $KeePassD.Version
        }
        $KeePassV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*KeePass*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$KeePassV) {
            $KeePassV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*KeePass*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($KeePassV) {
            $KeePassVSplit = $KeePassV.split(".")
            $KeePassV = $KeePassVSplit[0] + "." + $KeePassVSplit[1]
        }
        $KeePassLog = "$LogTemp\KeePass.log"
        $InstallMSI = "$PSScriptRoot\$Product\KeePass.msi"
        Write-Host -ForegroundColor Magenta "Install $Product $KeePassLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $KeePassV"
        If ($KeePassV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/quiet"
                "/L*V $KeePassLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $KeePassLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $KeePassLog -ErrorAction SilentlyContinue
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\KeePass.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\KeePass.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\KeePass") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\KeePass" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            Write-Host "Copy $Product language pack $KeePassLanguageClear"
            If ($WhatIf -eq '0') {
                Move-Item -Path "$PSScriptRoot\$Product\$KeePassLanguageClear.lngx" -Destination "${Env:ProgramFiles(x86)}\KeePass2x\Languages" -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Copy $Product language pack $KeePassLanguageClear finished!"
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install LogMeIn GoToMeeting
    If ($LogMeInGoToMeeting -eq 1) {
        If ($LogMeInGoToMeetingInstallerClear -eq "Machine Based") {
            $Product = "LogMeIn GoToMeeting XenApp"
            # Check, if a new version is available
            $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $LogMeInGoToMeetingD.Version
            }
            $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$LogMeInGoToMeetingV) {
                $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $LogMeInGoToMeetingLog = "$LogTemp\LogMeInGoToMeeting.log"
            $InstallMSI = "$PSScriptRoot\$Product\GoToMeeting-Setup.msi"
            Write-Host -ForegroundColor Magenta "Install $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $LogMeInGoToMeetingV"
            If ($LogMeInGoToMeetingV -lt $Version) {
                DS_WriteLog "I" "Install $Product" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/quiet"
                    "/L*V $LogMeInGoToMeetingLog"
                )
                Try {
                    Write-Host "Starting install of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                    }
                    Get-Content $LogMeInGoToMeetingLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $LogMeInGoToMeetingLog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                }
                Try {
                    Write-Host "Customize Scheduled Task"
                    If ($WhatIf -eq '0') {
                        Get-ScheduledTask -TaskName G2M* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
        If ($LogMeInGoToMeetingInstallerClear -eq "User Based") {
            $Product = "LogMeIn GoToMeeting"
            # Check, if a new version is available
            $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $LogMeInGoToMeetingD.Version
            }
            $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$LogMeInGoToMeetingV) {
                $LogMeInGoToMeetingV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*GoToMeeting*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $LogMeInGoToMeetingLog = "$LogTemp\LogMeInGoToMeeting.log"
            $InstallMSI = "$PSScriptRoot\$Product\GoToMeeting-Setup.msi"
            Write-Host -ForegroundColor Magenta "Install $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $LogMeInGoToMeetingV"
            If ($LogMeInGoToMeetingV -lt $Version) {
                DS_WriteLog "I" "Install $Product" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/quiet"
                    "/L*V $LogMeInGoToMeetingLog"
                )
                Try {
                    Write-Host "Starting install of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                    }
                    Get-Content $LogMeInGoToMeetingLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $LogMeInGoToMeetingLog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Microsoft .Net Framework
    If ($MSDotNetFramework -eq 1) {
        $Product = "Microsoft Dot Net Framework"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSDotNetFrameworkArchitectureClear" + "_$MSDotNetFrameworkChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSDotNetFrameworkD.Version
        }
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionStrings = ([regex]::Matches($Version, "\." )).count
            $VersionStringTwo = ([regex]::Matches($VersionSplit[2], "." )).count
            If ($VersionStringTwo -lt "2") {
                $VersionSplit[2] = "0" + $VersionSplit[2]
            }
            Switch ($VersionStrings) {
                1 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1]
                }
                2 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2]
                }
                3 {
                    $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit[2] + "." + $VersionSplit[3]
                }
            }
        }
        If ($MSDotNetFrameworkChannelClear -eq "LTS") {
            $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime - 8*" -and $_.DisplayName -notlike "*Windows Desktop Runtime - 6*(x64)" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$MSDotNetFrameworkV) {
                $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime - 8*" -and $_.DisplayName -notlike "*Windows Desktop Runtime - 6*(x64)" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        } else {
            $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime*" -and $_.DisplayName -notlike "*Windows Desktop Runtime - 6*(x64)" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$MSDotNetFrameworkV) {
                $MSDotNetFrameworkV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Windows Desktop Runtime*" -and $_.DisplayName -notlike "*Windows Desktop Runtime - 6*(x64)" -and $_.URLInfoAbout -like "https://dot.net/core"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($MSDotNetFrameworkV) {
            $CurrentSplit = $MSDotNetFrameworkV.split(".")
            $CurrentStrings = ([regex]::Matches($MSDotNetFrameworkV, "\." )).count
            $CurrentStringTwo = ([regex]::Matches($CurrentSplit[2], "." )).count
            If ($CurrentStringTwo -lt "2") {
                $CurrentSplit[2] = "0" + $CurrentSplit[2]
            }
            If ($CurrentStrings -lt "3") {
                $CurrentSplit[3] = ""
            }
            Switch ($CurrentStrings) {
                1 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1]
                }
                2 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
                3 {
                    $MSDotNetFrameworkV = $CurrentSplit[0] + "." + $CurrentSplit[1] + "." + $CurrentSplit[2]
                }
            }
        }
        $MSDotNetFrameworkInstaller = "NetFramework-runtime_" + "$MSDotNetFrameworkArchitectureClear" + "_$MSDotNetFrameworkChannelClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSDotNetFrameworkV"
        If ($MSDotNetFrameworkV -ne $Version) {
            $Options = @(
                "/install"
                "/quiet"
                "/norestart"
            )
            DS_WriteLog "I" "Install $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear " $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$MSDotNetFrameworkInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSDotNetFrameworkChannelClear channel $MSDotNetFrameworkArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft 365 Apps
    If ($MS365Apps -eq 1) {
        $Product = "Microsoft 365 Apps"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MS365AppsD.Version
        }
        $MS365AppsV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft 365*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MS365AppsV) {
            $MS365AppsV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft 365*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MS365AppsInstaller = "setup_" + "$MS365AppsChannelClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $MS365AppsChannelClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MS365AppsV"
        If ($MS365AppsV -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            # Download Apps 365 install files
            If (!(Test-Path -Path "$PSScriptRoot\$Product\$MS365AppsChannelClear\Office\Data\$Version")) {
                Write-Host "Starting download of $Product install files"
                $DApps365 = @(
                    "/download install.xml"
                )
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product\$MS365AppsChannelClear
                    Start-Process ".\$MS365AppsInstaller" -ArgumentList $DApps365 -wait -NoNewWindow
                    set-location $PSScriptRoot
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version install files finished!"
            }
            # MS365Apps Uninstallation
            $Options = @(
                "/configure remove.xml"
            )
            Write-Host "Uninstall Microsoft Office or Microsoft 365 Apps"
            DS_WriteLog "I" "Uninstall Microsoft Office or Microsoft 365 Apps" $LogFile
            Try {
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product\$MS365AppsChannelClear
                    Start-Process -FilePath ".\$MS365AppsInstaller" -ArgumentList $Options -NoNewWindow -wait
                    set-location $PSScriptRoot
                }
                Write-Host -ForegroundColor Green "Uninstall Microsoft Office or Microsoft 365 Apps finished!"
                DS_WriteLog "I" "Uninstallation Microsoft Office or Microsoft 365 Apps finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error uninstalling Microsoft Office or Microsoft 365 Apps (Error: $($Error[0]))"
                DS_WriteLog "E" "Error uninstalling Microsoft Office or Microsoft 365 Apps (Error: $($Error[0]))" $LogFile
            }
            # MS365Apps Installation
            $Options = @(
                "/configure install.xml"
            )
            Try {
                DS_WriteLog "I" "Install $Product" $LogFile
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product\$MS365AppsChannelClear
                    Start-Process -FilePath ".\$MS365AppsInstaller" -ArgumentList $Options -NoNewWindow -wait
                    set-location $PSScriptRoot
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Office Tools") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Office Tools" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Access.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Access.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Excel.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Excel.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\OneNote.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\OneNote.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Outlook.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Outlook.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerPoint.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerPoint.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Publisher.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Publisher.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Project.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Project.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visio.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visio.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Word.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Word.lnk" -Force}
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Outlook.lnk") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Outlook.lnk" -Force}
                    }
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft AVD Remote Desktop
    If ($MSAVDRemoteDesktop -eq 1) {
        $Product = "Microsoft AVD Remote Desktop"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAVDRemoteDesktopChannelClear" + "$MSAVDRemoteDesktopArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSAVDRemoteDesktopD.Version
        }
        $MSAVDRemoteDesktopV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Remotedesktop"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $MSAVDRemoteDesktopLog = "$LogTemp\MSAVDRemoteDesktop.log"
        If (!$MSAVDRemoteDesktopV) {
            $MSAVDRemoteDesktopV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Remotedesktop"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSAVDRemoteDesktopInstaller = "RemoteDesktop_" + "$MSAVDRemoteDesktopArchitectureClear" + "_$MSAVDRemoteDesktopChannelClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$MSAVDRemoteDesktopInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSAVDRemoteDesktopV"
        If ($MSAVDRemoteDesktopV -ne $Version) {
            DS_WriteLog "I" "Install $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $MSAVDRemoteDesktopLog"
            )
            try {
                Write-Host "Starting install of $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Remote Desktop.lnk") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Remote Desktop.lnk" -Force}
                    }
                }
                Get-Content $MSAVDRemoteDesktopLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $MSAVDRemoteDesktopLog -ErrorAction SilentlyContinue
            } catch {
                DS_WriteLog "E" "Error installing $Product $MSAVDRemoteDesktopChannelClear release $MSAVDRemoteDesktopArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Azure CLI
    If ($MSAzureCLI -eq 1) {
        $Product = "Microsoft Azure CLI"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSAzureCLID.Version
        }
        $MSAzureCLIV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Azure CLI"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $MSAzureCLILog = "$LogTemp\MSAzureCLI.log"
        If (!$MSAzureCLIV) {
            $MSAzureCLIV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Azure CLI"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSAzureCLIInstaller = "AzureCLI.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$MSAzureCLIInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSAzureCLIV"
        If ($MSAzureCLIV -ne $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $MSAzureCLILog"
            )
            try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $MSAzureCLILog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $MSAzureCLILog -ErrorAction SilentlyContinue
            } catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Azure Data Studio
    If ($MSAzureDataStudio -eq 1) {
        $Product = "Microsoft Azure Data Studio"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSAzureDataStudioD.Version
        }
        $MSAzureDataStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSAzureDataStudioV) {
            $MSAzureDataStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSAzureDataStudioV) {
            $MSAzureDataStudioV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Azure Data Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSAzureDataStudioInstaller = "AzureDataStudio-Setup-" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear" + "." + "exe"
        $MSAzureDataStudioProcess = "AzureDataStudio-Setup-" + "$MSAzureDataStudioChannelClear" + "-$MSAzureDataStudioPlatformClear"
        Write-Host -ForegroundColor Magenta "Install $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSAzureDataStudioV"
        If ($MSAzureDataStudioV -ne $Version) {
            Write-Host -ForegroundColor Green "Update available"
            DS_WriteLog "I" "Install $Product $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear" $LogFile
            $Options = @(
                "/VERYSILENT"
                "/NORESTART"
                "/MERGETASKS=!runcode"
            )
            Try {
                Write-Host "Starting install of $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear version $Version"
                If ($WhatIf -eq '0') {
                    $null = Start-Process "$PSScriptRoot\$Product\$MSAzureDataStudioInstaller" -ArgumentList $Options -NoNewWindow -PassThru
                    while (Get-Process -Name $MSAzureDataStudioProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Azure Data Studio") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Azure Data Studio" -Recurse -Force}
                    }
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSAzureDataStudioChannelClear $MSAzureDataStudioArchitectureClear $MSAzureDataStudioModeClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Edge
    If ($MSEdge -eq 1) {
        $Product = "Microsoft Edge"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeArchitectureClear" + "_$MSEdgeChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $EdgeD.Version
        }
        $EdgeSplit1 = $Version.split(".")
        $EdgeStrings1 = ([regex]::Matches($Version, "\." )).count
        $EdgeStringLast1 = ([regex]::Matches($EdgeSplit1[$EdgeStrings1], "." )).count
        $EdgeStringFirst1 = ([regex]::Matches($EdgeSplit1[0], "." )).count
        If ($EdgeStringLast1 -lt "3") {
            $EdgeSplit1[$EdgeStrings1] = "0" + $EdgeSplit1[$EdgeStrings1]
        }
        If ($EdgeStringFirst1 -lt "3") {
            $EdgeSplit1[0] = "0" + $EdgeSplit1[0]
        }
        Switch ($EdgeStrings1) {
            1 {
                $NewVersion1 = $EdgeSplit1[0] + "." + $EdgeSplit1[1]
            }
            2 {
                $NewVersion1 = $EdgeSplit1[0] + "." + $EdgeSplit1[1] + "." + $EdgeSplit1[2]
            }
            3 {
                $NewVersion1 = $EdgeSplit1[0] + "." + $EdgeSplit1[1] + "." + $EdgeSplit1[2] + "." + $EdgeSplit1[3]
            }
        }
        $Version = $NewVersion1
        If ($MSEdgeChannelClear -eq "Stable") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($MSEdgeChannelClear -eq "Dev") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Dev"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($MSEdgeChannelClear -eq "Beta") {
            $Edge = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$Edge) {
                $Edge = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft Edge Beta"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
        }
        If ($Edge) {
            $CurrentEdgeSplit1 = $Edge.split(".")
            $CurrentEdgeStrings1 = ([regex]::Matches($Edge, "\." )).count
            $CurrentEdgeStringLast1 = ([regex]::Matches($CurrentEdgeSplit1[$CurrentEdgeStrings1], "." )).count
            $CurrentEdgeStringFirst1 = ([regex]::Matches($CurrentEdgeSplit1[0], "." )).count
            If ($CurrentEdgeStringLast1 -lt "3") {
                $CurrentEdgeSplit1[$CurrentEdgeStrings1] = "0" + $CurrentEdgeSplit1[$CurrentEdgeStrings1]
            }
            If ($CurrentEdgeStringFirst1 -lt "3") {
                $CurrentEdgeSplit1[0] = "0" + $CurrentEdgeSplit1[0]
            }
            Switch ($CurrentEdgeStrings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1] + "." + $CurrentEdgeSplit1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentEdgeSplit1[0] + "." + $CurrentEdgeSplit1[1] + "." + $CurrentEdgeSplit1[2] + "." + $CurrentEdgeSplit1[3]
                }
            }
        }
        $EdgeLog = "$LogTemp\MSEdge.log"
        $EdgeInstaller = "MicrosoftEdgeEnterprise_" + "$MSEdgeArchitectureClear" + "_$MSEdgeChannelClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$EdgeInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear"
        Write-Host "Download Version: $NewVersion1"
        Write-Host "Current Version:  $NewCurrentVersion1"
        If ($NewCurrentVersion1 -ne $NewVersion1) {
            DS_WriteLog "I" "Install $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear" $LogFile
            If ($WhatIf -eq '0') {
                If (!(Test-Path -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate)) {
                    New-Item -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -ErrorAction SilentlyContinue | Out-Null
                    New-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -Name Allowsxs -Value 1 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                }
                Else {
                    If ((Test-RegistryValue2 -Path "HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate" -Value "Allowsxs") -ne $true) {
                        New-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -Name Allowsxs -Value 1 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                    } Else {
                        $EdgeInstallState = Get-ItemProperty -path "HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate" | Select-Object -Expandproperty "Allowsxs"
                        If ($EdgeInstallState -ne "1") {Set-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -Name Allowsxs -Value 1 | Out-Null}
                    }
                }
            }
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "REBOOT=ReallySuppress"
                "DONOTCREATEDESKTOPSHORTCUT=TRUE"
                "DONOTCREATETASKBARSHORTCUT=true"
                "/L*V $EdgeLog"
            )
            try {
                Write-Host "Starting install of $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear version $NewVersion1"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge Dev.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge Dev.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge Beta.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Edge Beta.lnk" -Force}
                    }
                }
                Get-Content $EdgeLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $EdgeLog -ErrorAction SilentlyContinue
            } catch {
                DS_WriteLog "E" "Error installing $Product $MSEdgeChannelClear channel $MSEdgeArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Write-Host "Customize $Product"
            Try {
                # Disable Microsoft Edge auto update
                Write-Host "Customize $Product registry"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate)) {
                        New-Item -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -ErrorAction SilentlyContinue | Out-Null
                        New-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -Name UpdateDefault -Value 0 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                    }
                    Else {
                        $EdgeUpdateState = Get-ItemProperty -path "HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate" | Select-Object -Expandproperty "UpdateDefault"
                        If ($EdgeUpdateState -ne "0") {Set-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\EdgeUpdate -Name UpdateDefault -Value 0 | Out-Null}
                    }
                    # Disable Citrix API Hooks (MS Edge) on Citrix VDA
                    $(
                        $RegPath = "HKLM:SYSTEM\CurrentControlSet\services\CtxUvi"
                        If (Test-Path $RegPath) {
                            $RegName = "UviProcessExcludes"
                            # Get current values in UviProcessExcludes
                            $CurrentValues = Get-ItemProperty -Path $RegPath -ErrorAction SilentlyContinue | Select-Object -ExpandProperty $RegName
                            If ($CurrentValues -like "*msedge.exe*") {
                                $NewValues = $CurrentValues.replace("msedge.exe;","")
                                Set-ItemProperty -Path $RegPath -Name $RegName -Value "$NewValues" -ErrorAction SilentlyContinue
                            }
                            # Add the msedge.exe value to existing values in UviProcessExcludes
                        }
                    ) | Out-Null
                }
                Write-Host -ForegroundColor Green "Customize $Product registry finished!"
                $Service = Get-Service -Name edgeupdate -ErrorAction SilentlyContinue
                If ($Service.Length -gt 0) {
                    Write-Host "Customize Service"
                    If ($WhatIf -eq '0') {
                        Stop-Service edgeupdate
                        Set-Service -Name edgeupdate -StartupType Manual
                        Stop-Service edgeupdatem
                        Set-Service -Name edgeupdatem -StartupType Manual
                    }
                    Write-Host -ForegroundColor Green "Stop and Disable Service $Product finished!"
                }
                Write-Host "Customize Scheduled Task"
                If ($WhatIf -eq '0') {
                    Start-Sleep -s 5
                    Get-ScheduledTask -TaskName MicrosoftEdgeUpdate* -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                }
                Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                Write-Host -ForegroundColor Green "Customize $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Edge WebView2
    If ($MSEdgeWebView2 -eq 1) {
        $Product = "Microsoft Edge WebView2"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSEdgeWebView2ArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $EdgeWebView2D.Version
        }
        $EdgeWebView2Split1 = $Version.split(".")
        $EdgeWebView2Strings1 = ([regex]::Matches($Version, "\." )).count
        $EdgeWebView2StringLast1 = ([regex]::Matches($EdgeWebView2Split1[$EdgeWebView2Strings1], "." )).count
        $EdgeWebView2StringFirst1 = ([regex]::Matches($EdgeWebView2Split1[0], "." )).count
        If ($EdgeWebView2StringLast1 -lt "3") {
            $EdgeWebView2Split1[$EdgeWebView2Strings1] = "0" + $EdgeWebView2Split1[$EdgeWebView2Strings1]
        }
        If ($EdgeWebView2StringFirst1 -lt "3") {
            $EdgeWebView2Split1[0] = "0" + $EdgeWebView2Split1[0]
        }
        Switch ($EdgeWebView2Strings1) {
            1 {
                $NewVersion1 = $EdgeWebView2Split1[0] + "." + $EdgeWebView2Split1[1]
            }
            2 {
                $NewVersion1 = $EdgeWebView2Split1[0] + "." + $EdgeWebView2Split1[1] + "." + $EdgeWebView2Split1[2]
            }
            3 {
                $NewVersion1 = $EdgeWebView2Split1[0] + "." + $EdgeWebView2Split1[1] + "." + $EdgeWebView2Split1[2] + "." + $EdgeWebView2Split1[3]
            }
        }
        $Version = $NewVersion1
        $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$EdgeWebView2) {
            $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($EdgeWebView2) {
            $CurrentEdgeWebView2Split1 = $EdgeWebView2.split(".")
            $CurrentEdgeWebView2Strings1 = ([regex]::Matches($EdgeWebView2, "\." )).count
            $CurrentEdgeWebView2StringLast1 = ([regex]::Matches($CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1], "." )).count
            $CurrentEdgeWebView2StringFirst1 = ([regex]::Matches($CurrentEdgeWebView2Split1[0], "." )).count
            If ($CurrentEdgeWebView2StringLast1 -lt "3") {
                $CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1] = "0" + $CurrentEdgeWebView2Split1[$CurrentEdgeWebView2Strings1]
            }
            If ($CurrentEdgeWebView2StringFirst1 -lt "3") {
                $CurrentEdgeWebView2Split1[0] = "0" + $CurrentEdgeWebView2Split1[0]
            }
            Switch ($CurrentEdgeWebView2Strings1) {
                1 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1]
                }
                2 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1] + "." + $CurrentEdgeWebView2Split1[2]
                }
                3 {
                    $NewCurrentVersion1 = $CurrentEdgeWebView2Split1[0] + "." + $CurrentEdgeWebView2Split1[1] + "." + $CurrentEdgeWebView2Split1[2] + "." + $CurrentEdgeWebView2Split1[3]
                }
            }
        }
        $EdgeWebView2Installer = "MicrosoftEdgeWebView2_" + "$MSEdgeWebView2ArchitectureClear" + ".exe"
        $EdgeWebView2Process = "MicrosoftEdgeWebView2_" + "$MSEdgeWebView2ArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product $MSEdgeWebView2ArchitectureClear"
        Write-Host "Download Version: $NewVersion1"
        Write-Host "Current Version:  $NewCurrentVersion1"
        If ($NewCurrentVersion1 -ne $NewVersion1) {
            DS_WriteLog "I" "Install $Product $MSEdgeWebView2ArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/SILENT"
                "/INSTALL"
            )
            Try {
                Write-Host "Starting install of $Product $MSEdgeWebView2ArchitectureClear version $NewVersion1"
                If ($WhatIf -eq '0') {
                    $null = Start-Process "$PSScriptRoot\$Product\$EdgeWebView2Installer" -ArgumentList $Options -NoNewWindow -PassThru
                    while (Get-Process -Name $EdgeWebView2Process -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                }
                Write-Host -ForegroundColor Green "Install of the new version $NewVersion1 finished!"
                DS_WriteLog "I" "Installation $Product $MSEdgeWebView2ArchitectureClear finished!" $LogFile
            } catch {
                DS_WriteLog "E" "Error installing $Product $MSEdgeWebView2ArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft FSLogix
    If ($MSFSLogix -eq 1) {
        $Product = "Microsoft FSLogix"
        $OS = (Get-CimInstance win32_OperatingSystem).caption
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\$MSFSLogixChannelClear\Version_" + "$MSFSLogixChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSFSLogixD.Version
        }
        $MSFSLogixV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSFSLogixV) {
            $MSFSLogixV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}) {
            $UninstallFSL = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps"}).UninstallString.replace("/uninstall","")
        }
        If (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps RuleEditor"}) {
            $UninstallFSLRE = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Microsoft FSLogix Apps RuleEditor"}).UninstallString.replace("/uninstall","")
        }
        $FSLCheck = $UninstallFSL.replace("""","")
        $FSLRECheck = $UninstallFSLRE.replace("""","")
        Write-Host -ForegroundColor Magenta "Install $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSFSLogixV"
        If ($MSFSLogixV -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            # FSLogix Uninstall
            If ($MSFSLogixV) {
                Write-Host "Uninstall $Product"
                DS_WriteLog "I" "Uninstall $Product" $LogFile
                Try {
                    If ($WhatIf -eq '0') {
                        If (Test-Path -Path "$FSLCheck" -PathType Leaf) {
                            Start-process $UninstallFSL -ArgumentList '/uninstall /quiet /norestart' -NoNewWindow -Wait
                        }
                        If (Test-Path -Path "$FSLRECheck" -PathType Leaf) {
                            Start-process $UninstallFSLRE -ArgumentList '/uninstall /quiet /norestart' -NoNewWindow -Wait
                        }
                    }
                    Write-Host -ForegroundColor Green "Uninstall $Product finished!"
                    DS_WriteLog "I" "Uninstallation $Product finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error uninstalling $Product (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error uninstalling $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
                Write-Host -ForegroundColor Red "Server needs to reboot, start script again after reboot"
                If ($WhatIf -eq '0') {
                    Write-Output ""
                    Write-Host -ForegroundColor Red "Hit any key to reboot server"
                    Read-Host
                    Restart-Computer
                }
            }
            # FSLogix Install
            Try {
                Write-Host "Starting install of $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear version $Version"
                DS_WriteLog "I" "Install $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear" $LogFile
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$MSFSLogixChannelClear\FSLogixAppsSetup.exe" -ArgumentList '/install /norestart /quiet' -NoNewWindow -Wait
                }
                Write-Host -ForegroundColor Green "Install $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear finished!"
                Write-Host "Starting install of $Product Rule Editor $MSFSLogixChannelClear release $MSFSLogixArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$MSFSLogixChannelClear\FSLogixAppsRuleEditorSetup.exe" -ArgumentList '/install /norestart /quiet' -NoNewWindow -Wait
                }
                Write-Host -ForegroundColor Green "Install $Product Rule Editor $MSFSLogixChannelClear release $MSFSLogixArchitectureClear finished!"
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSFSLogixChannelClear release $MSFSLogixArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Try {
                Start-Sleep -s 20
                # Application post deployment tasks (Thx to Kasper https://github.com/kaspersmjohansen)
                Write-Host "Applying $Product post setup customizations"
                Write-Host "Post setup customizations for $OS"
                If ($OS -Like "*Windows Server 2019*" -or $OS -eq "Microsoft Windows 10 Enterprise for Virtual Desktops" -or $OS -Like "*Windows Server 2022*") {
                    If ((Test-RegistryValue2 -Path "HKLM:SOFTWARE\FSLogix\Apps" -Value "RoamSearch") -ne $true) {
                        Write-Host "Deactivate FSLogix RoamSearch"
                        If ($WhatIf -eq '0') {
                            New-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" -Name "RoamSearch" -Value "0" -Type DWORD -ErrorAction SilentlyContinue | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Deactivate FSLogix RoamSearch finished!"
                    }
                    If ((Get-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" | Select-Object -ExpandProperty "RoamSearch" -ErrorAction SilentlyContinue) -ne "0") {
                        Write-Host "Deactivate FSLogix RoamSearch"
                        If ($WhatIf -eq '0') {
                            Set-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" -Name "RoamSearch" -Value "0" -Type DWORD -ErrorAction SilentlyContinue
                        }
                        Write-Host -ForegroundColor Green "Deactivate FSLogix RoamSearch finished!"
                    }
                }
                If ($OS -Like "*Windows 10*" -and $OS -ne "Microsoft Windows 10 Enterprise for Virtual Desktops") {
                    If ((Test-RegistryValue2 -Path "HKLM:SOFTWARE\FSLogix\Apps" -Value "RoamSearch") -ne $true) {
                        Write-Host "Deactivate FSLogix RoamSearch"
                        If ($WhatIf -eq '0') {
                            New-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" -Name "RoamSearch" -Value "1" -Type DWORD -ErrorAction SilentlyContinue | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Deactivate FSLogix RoamSearch finished!"
                    }
                    If ((Get-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" | Select-Object -ExpandProperty "RoamSearch" -ErrorAction SilentlyContinue) -ne "1") {
                        Write-Host "Deactivate FSLogix RoamSearch"
                        If ($WhatIf -eq '0') {
                            Set-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Apps" -Name "RoamSearch" -Value "1" -Type DWORD -ErrorAction SilentlyContinue
                        }
                        Write-Host -ForegroundColor Green "Deactivate FSLogix RoamSearch finished!"
                    }
                }
                Write-Host -ForegroundColor Green "Post setup customizations for $OS finished!"
                # Implement user based group policy processing fix
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path HKLM:SOFTWARE\FSLogix\Profiles)) {
                        New-Item -Path "HKLM:SOFTWARE\FSLogix" -Name Profiles -ErrorAction SilentlyContinue | Out-Null
                    }
                }
                If ((Test-RegistryValue -Path "HKLM:SOFTWARE\FSLogix\Profiles" -Value "GroupPolicyState") -ne $true) {
                    Write-Host "Deactivate FSLogix GroupPolicy"
                    If ($WhatIf -eq '0') {
                        New-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Profiles" -Name "GroupPolicyState" -Value "0" -Type DWORD -ErrorAction SilentlyContinue | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Deactivate FSLogix GroupPolicy finished!"
                }
                If ((Get-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Profiles" | Select-Object -ExpandProperty "GroupPolicyState" -ErrorAction SilentlyContinue) -ne "0") {
                    Write-Host "Deactivate FSLogix GroupPolicy"
                    If ($WhatIf -eq '0') {
                        Set-ItemProperty -Path "HKLM:SOFTWARE\FSLogix\Profiles" -Name "GroupPolicyState" -Value "0" -Type DWORD -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Deactivate FSLogix GroupPolicy finished!"
                }
                If (!(Get-ScheduledTask -TaskName "Restart Windows Search Service on Event ID 2" -ErrorAction SilentlyContinue)) {
                    Write-Host "Implement scheduled task to restart Windows Search service on Event ID 2"
                    # Implement scheduled task to restart Windows Search service on Event ID 2
                    # Define CIM object variables
                    # This is needed for accessing the non-default trigger settings when creating a schedule task using Powershell
                    $Class = Get-CimClass MSFT_TaskEventTrigger root/Microsoft/Windows/TaskScheduler
                    $Trigger = $class | New-CimInstance -ClientOnly
                    $Trigger.Enabled = $true
                    $Trigger.Subscription = "<QueryList><Query Id=`"0`" Path=`"Application`"><Select Path=`"Application`">*[System[Provider[@Name='Microsoft-Windows-Search-ProfileNotify'] and EventID=2]]</Select></Query></QueryList>"
                    # Define additional variables containing scheduled task action and scheduled task principal
                    $A = New-ScheduledTaskAction -Execute powershell.exe -Argument "Restart-Service Wsearch"
                    $P = New-ScheduledTaskPrincipal -UserId "NT AUTHORITY\SYSTEM" -LogonType ServiceAccount
                    $S = New-ScheduledTaskSettingsSet
                    # Cook it all up and create the scheduled task
                    $RegSchTaskParameters = @{
                        TaskName    = "Restart Windows Search Service on Event ID 2"
                        Description = "Restarts the Windows Search service on event ID 2 - Workaround described here - https://virtualwarlock.net/how-to-install-the-fslogix-apps-agent/#Windows_Search_Roaming_workaround_1"
                        TaskPath    = "\"
                        Action      = $A
                        Principal   = $P
                        Settings    = $S
                        Trigger     = $Trigger
                    }
                    If ($WhatIf -eq '0') {
                        Register-ScheduledTask @RegSchTaskParameters -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Implement scheduled task to restart Windows Search service on Event ID 2 finished!"
                }
                Write-Host -ForegroundColor Green "Applying $Product post setup customizations finished!"
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSFSLogixChannelClear $MSFSLogixArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSFSLogixChannelClear $MSFSLogixArchitectureClear (Error: $($Error[0]))" $LogFile
            }
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Office
    If ($MSOffice -eq 1) {
        $Product = "Microsoft Office " + $MSOfficeChannelClear
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSOfficeD.Version
        }
        $MSOfficeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Office*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSOfficeV) {
            $MSOfficeV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Office*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSOfficeV"
        If ($MSOfficeV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            # Download MS Office install files
            If (!(Test-Path -Path "$PSScriptRoot\$Product\Office\Data\$Version")) {
                Write-Host "Starting download of $Product install files"
                $DOffice = @(
                    "/download install.xml"
                )
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product
                    Start-Process ".\setup.exe" -ArgumentList $DOffice -wait -NoNewWindow
                    set-location $PSScriptRoot
                }
                Write-Host -ForegroundColor Green "Download of the new version $Version install files finished!"
            }
            # MS Office Uninstallation
            $Options = @(
                "/configure remove.xml"
            )
            Write-Host "Uninstall Microsoft Office or Microsoft 365 Apps"
            DS_WriteLog "I" "Uninstall Microsoft Office or Microsoft 365 Apps" $LogFile
            Try {
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product
                    Start-Process -FilePath ".\setup.exe" -ArgumentList $Options -NoNewWindow -wait
                    set-location $PSScriptRoot
                }
                Write-Host -ForegroundColor Green "Uninstall Microsoft Office or Microsoft 365 Apps finished!"
                DS_WriteLog "I" "Uninstallation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error uninstalling Microsoft Office or Microsoft 365 Apps (Error: $($Error[0]))"
                DS_WriteLog "E" "Error uninstalling Microsoft Office or Microsoft 365 Apps (Error: $($Error[0]))" $LogFile
            }
            # MS Office Installation
            $Options = @(
                "/configure install.xml"
            )
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host "Starting install of $Product version $Version"
            Try {
                If ($WhatIf -eq '0') {
                    set-location $PSScriptRoot\$Product
                    Start-Process -FilePath ".\setup.exe" -ArgumentList $Options -NoNewWindow -wait
                    set-location $PSScriptRoot
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft OneDrive
    If ($MSOneDrive -eq 1) {
        $Product = "Microsoft OneDrive"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSOneDriveD.Version
        }
        $MSOneDriveV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSOneDriveV) {
            $MSOneDriveV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSOneDriveV) {
            $MSOneDriveV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OneDrive*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $OneDriveInstaller = "OneDriveSetup-" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear" + ".exe"
        $OneDriveProcess = "OneDriveSetup-" + "$MSOneDriveRingClear" + "_$MSOneDriveArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSOneDriveV"
        If ($MSOneDriveV -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            DS_WriteLog "I" "Install $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear" $LogFile
            If ($MSOneDriveInstallerClear -eq 'Machine Based') {
                $Options = @(
                    "/allusers"
                    "/SILENT"
                )
            }
            If ($MSOneDriveInstallerClear -eq 'User Based') {
                $Options = @(
                    "/SILENT"
                )
            }
            Try {
                Write-Host "Starting install of $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $null = Start-Process "$PSScriptRoot\$Product\$OneDriveInstaller" -ArgumentList $Options -NoNewWindow -PassThru
                    while (Get-Process -Name $OneDriveProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\OneDrive.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\OneDrive.lnk" -Force}
                    }
                }
                # OneDrive starts automatically after setup. kill!
                Stop-Process -Name "OneDrive" -Force -ErrorAction SilentlyContinue
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSOneDriveRingClear ring $MSOneDriveArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Write-Host "Customize $Product"
            Try {
                # Disable Microsoft OneDrive auto update
                If ($WhatIf -eq '0') {
                    Write-Host "Customize Scheduled Task"
                    Start-Sleep -s 5
                    Get-ScheduledTask -TaskName "OneDrive Per*" -ErrorAction SilentlyContinue | Disable-ScheduledTask -ErrorAction SilentlyContinue | Out-Null
                    Write-Host -ForegroundColor Green "Disable Scheduled Task $Product finished!"
                    $Service = Get-Service -Name "OneDrive*" -ErrorAction SilentlyContinue
                    If ($Service.Length -gt 0) {
                        Write-Host "Customize Service"
                        Stop-Service $Service.Name
                        Set-Service -Name $Service.Name -StartupType Manual
                    }
                    Write-Host -ForegroundColor Green "Stop and Disable Service $Product finished!"
                    Write-Host "Customize update registry"
                    If (!(Test-Path -Path HKLM:SOFTWARE\Policies\Microsoft\OneDrive)) {
                        New-Item -Path HKLM:SOFTWARE\Policies\Microsoft\OneDrive -ErrorAction SilentlyContinue | Out-Null
                        New-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\OneDrive -Name GPOSetUpdateRing -Value 0 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                    }
                    Else {
                        $OneDriveUpdateState = Get-ItemProperty -path "HKLM:SOFTWARE\Policies\Microsoft\OneDrive" | Select-Object -Expandproperty "GPOSetUpdateRing"
                        If ($OneDriveUpdateState -ne "0") {Set-ItemProperty -Path HKLM:SOFTWARE\Policies\Microsoft\OneDrive -Name GPOSetUpdateRing -Value 0 | Out-Null}
                    }
                }
                Write-Host -ForegroundColor Green "Customize $Product update registry finished!"
                Write-Host -ForegroundColor Green "Customize $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
            Write-Host "Starting copy of $Product $MSOneDriveRingClear ADMX files version $Version"
            If ($WhatIf -eq '0') {
                $OneDriveUninstall = (Get-ItemProperty -Path 'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*' | Where-Object {$_.DisplayIcon -like "*OneDriveSetup.exe*"})
                If (!$OneDriveUninstall) {
                    $OneDriveUninstall = (Get-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*' | Where-Object {$_.DisplayIcon -like "*OneDriveSetup.exe*"})
                }
                If (!$OneDriveUninstall) {
                    $OneDriveUninstall = (Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*' | Where-Object {$_.DisplayIcon -like "*OneDriveSetup.exe*"})
                }
                $OneDriveInstallFolder = $OneDriveUninstall.DisplayIcon.Substring(0, $OneDriveUninstall.DisplayIcon.IndexOf("\OneDriveSetup.exe"))
                $sourceadmx = "$($OneDriveInstallFolder)\adm"
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\OneDrive.admx" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse -ErrorAction SilentlyContinue
                }
                If (Test-Path -Path "$PSScriptRoot\_ADMX\$Product") {Remove-Item -Path "$PSScriptRoot\_ADMX\$Product" -Force -Recurse}
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product" -ItemType Directory | Out-Null }
                Move-Item -Path "$sourceadmx\OneDrive.admx" -Destination "$PSScriptRoot\_ADMX\$Product" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\en-US")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\en-US\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\en-US\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\en-US" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\de-DE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\de-DE\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\de-DE\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\de\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\de-DE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\es-ES")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\es-ES\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\es-ES\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\es\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\es-ES" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\fr-FR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\fr-FR\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\fr-FR\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\fr\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\fr-FR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\it-IT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\it-IT\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\it-IT\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\it\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\it-IT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ja-JP")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ja-JP\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ja-JP\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\ja\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ja-JP" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ko-KR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ko-KR\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ko-KR\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\ko\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ko-KR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\nl-NL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\nl-NL\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\nl-NL\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\nl\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\nl-NL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pl-PL")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pl-PL\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pl-PL\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\pl\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pl-PL" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-BR")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-BR\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-BR\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\pt-BR\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-BR" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\pt-PT")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\pt-PT\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\pt-PT\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\pt-PT\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\pt-PT" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\ru-RU")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\ru-RU\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\ru-RU\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\ru\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\ru-RU" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\sv-SE")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\sv-SE\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\sv-SE\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\sv\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\sv-SE" -ErrorAction SilentlyContinue
                If (!(Test-Path -Path "$PSScriptRoot\_ADMX\$Product\zh-CN")) { New-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN" -ItemType Directory | Out-Null }
                If ((Test-Path "$PSScriptRoot\_ADMX\$Product\zh-CN\OneDrive.adml" -PathType leaf)) {
                    Remove-Item -Path "$PSScriptRoot\_ADMX\$Product\zh-CN\OneDrive.adml" -ErrorAction SilentlyContinue
                }
                Move-Item -Path "$sourceadmx\zh-CN\OneDrive.adml" -Destination "$PSScriptRoot\_ADMX\$Product\zh-CN" -ErrorAction SilentlyContinue
            }
            Write-Host -ForegroundColor Green "Copy of the new ADMX files version $Version finished!"
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Power BI Desktop
    If ($MSPowerBIDesktop -eq 1) {
        $Product = "Microsoft Power BI Desktop"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerBIDesktopArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSPowerBIDesktopD.Version
        }
        $MSPowerBIDesktopV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft PowerBI Desktop*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerBIDesktopV) {
            $MSPowerBIDesktopV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft PowerBI Desktop*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSPBISplit = $MSPowerBIDesktopV.split(".")
        $MSPBIString = ([regex]::Matches($MSPBISplit[2], "." )).count
        If ($MSPBIString -lt "4") {
            $MSPBISplit[2] = "0" + $MSPBISplit[2]
        }
        Switch ($MSPBIString) {
            1 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1]
            }
            2 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1] + "." + $MSPBISplit[2]
            }
            3 {
                $MSPowerBIDesktopV = $MSPBISplit[0] + "." + $MSPBISplit[1] + "." + $MSPBISplit[2] + "." + $MSPBISplit[3]
            }
        }
        $MSPowerBIDesktopInstaller = "PBIDesktopSetup_" + "$MSPowerBIDesktopArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product  $MSPowerBIDesktopArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSPowerBIDesktopV"
        If ($MSPowerBIDesktopV -ne $Version) {
            DS_WriteLog "I" "Install $Product $MSPowerBIDesktopArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "-quiet"
                "-norestart"
                "ACCEPT_EULA=1 INSTALLDESKTOPSHORTCUT=0 ENABLECXP=0"
            )
            Try {
                Write-Host "Starting install of $Product $MSPowerBIDesktopArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$MSPowerBIDesktopInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Power BI Desktop") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Power BI Desktop" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSPowerBIDesktopArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSPowerBIDesktopArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Power BI Report Builder
    If ($MSPowerBIReportBuilder -eq 1) {
        $Product = "Microsoft Power BI Report Builder"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSPowerBIReportBuilderD.Version
        }
        If ($Version) {
            $VersionSplit = $Version.split("0")
            $Version = $VersionSplit[0] + $VersionSplit[1] + $VersionSplit[2] + $VersionSplit[3] + $VersionSplit[4] + $VersionSplit[5] + $VersionSplit[6]
        }
        $MSPowerBIReportBuilderV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Power BI Report Builder*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerBIReportBuilderV) {
            $MSPowerBIReportBuilderV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Power BI Report Builder*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSPowerBIReportBuilderLog = "$LogTemp\MSPowerBIReportBuilder.log"
        $MSPowerBIReportBuilderInstaller = "PBIReportBuilderSetup.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$MSPowerBIReportBuilderInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSPowerBIReportBuilderV"
        If ($MSPowerBIReportBuilderV -ne $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/norestart"
                "/L*V $MSPowerBIReportBuilderLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Power BI Report Builder") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Power BI Report Builder" -Recurse -Force}
                    }
                }
                Get-Content $MSPowerBIReportBuilderLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $MSPowerBIReportBuilderLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft PowerShell
    If ($MSPowerShell -eq 1) {
        $Product = "Microsoft PowerShell"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSPowerShellArchitectureClear" + "_$MSPowerShellReleaseClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSPowershellD.Version
        }
        $PSSplit = $Version.split(".")
        $PSStrings = ([regex]::Matches($Version, "\." )).count
        $PSStringLast = ([regex]::Matches($PSSplit[$PSStrings], "." )).count
        If ($PSStringLast -lt "2") {
            $PSSplit[$PSStrings] = "0" + $PSSplit[$PSStrings]
        }
        Switch ($PSStrings) {
            1 {
                $Version = $PSSplit[0] + "." + $PSSplit[1]
            }
            2 {
                $Version = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2]
            }
            3 {
                $Version = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2] + "." + $PSSplit[3]
            }
        }
        $MSPowerShellV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerShell*" -and $_.Publisher -like "Microsoft Corporation"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerShellV) {
            $MSPowerShellV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerShell*" -and $_.Publisher -like "Microsoft Corporation"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($MSPowerShellV) {$MSPowerShellV = $MSPowerShellV -replace ".{2}$"}
        $PSSplit = $MSPowerShellV.split(".")
        $PSStrings = ([regex]::Matches($MSPowerShellV, "\." )).count
        $PSStringLast = ([regex]::Matches($PSSplit[$PSStrings], "." )).count
        If ($PSStringLast -lt "2") {
            $PSSplit[$PSStrings] = "0" + $PSSplit[$PSStrings]
        }
        Switch ($PSStrings) {
            1 {
                $MSPowerShellV = $PSSplit[0] + "." + $PSSplit[1]
            }
            2 {
                $MSPowerShellV = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2]
            }
            3 {
                $MSPowerShellV = $PSSplit[0] + "." + $PSSplit[1] + "." + $PSSplit[2] + "." + $PSSplit[3]
            }
        }
        $MSPowerShellLog = "$LogTemp\MSPowerShell.log"
        $MSPowerShellInstaller = "PowerShell" + "$MSPowerShellArchitectureClear" + "_$MSPowerShellReleaseClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$MSPowerShellInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $MSPowerShellReleaseClear Release $MSPowerShellArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSPowerShellV"
        If ($MSPowerShellV -lt $Version) {
            DS_WriteLog "I" "Install $Product $MSPowerShellReleaseClear Release  $MSPowerShellArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/norestart"
                "/L*V $MSPowerShellLog"
            )
            Try {
                Write-Host "Starting install of $Product  $MSPowerShellReleaseClear Release  $MSPowerShellArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerShell") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerShell" -Recurse -Force}
                    }
                }
                Get-Content $MSPowerShellLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $MSPowerShellLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $MSPowerShellReleaseClear Release  $MSPowerShellArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft PowerToys
    If ($MSPowerToys -eq 1) {
        $Product = "Microsoft PowerToys"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSPowerToysD.Version
        }
        $MSPowerToysV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerToys*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSPowerToysV) {
            $MSPowerToysV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PowerToys*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSPowerToysV"
        If ($MSPowerToysV -lt $Version) {
            $Options = @(
                "/install /quiet /norestart"
            )
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\PowerToysSetup-x64.exe" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    TaskKill /IM PowerToys.Settings.exe /F
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerToys*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PowerToys*" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft SQL Server Management Studio
    If ($MSSQLServerManagementStudio -eq 1) {
        $Product = "Microsoft SQL Server Management Studio"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSSQLServerManagementStudioLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSSQLServerManagementStudioD.Version
        }
        If ($Version) {
            $VersionSplit = $Version.split(".")
            $VersionSplit2 = $VersionSplit[2].Substring(0,3)
            $Version = $VersionSplit[0] + "." + $VersionSplit[1] + "." + $VersionSplit2
        }
        $MSSQLServerManagementStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*SQL Server Management Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSSQLServerManagementStudioV) {
            $MSSQLServerManagementStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*SQL Server Management Studio*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($MSSQLServerManagementStudioV) {
            $MSSQLServerManagementStudioVSplit = $MSSQLServerManagementStudioV.split(".")
            $MSSQLServerManagementStudioVSplit2 = $MSSQLServerManagementStudioVSplit[2].Substring(0,3)
            $MSSQLServerManagementStudioV = $MSSQLServerManagementStudioVSplit[0] + "." + $MSSQLServerManagementStudioVSplit[1] + "." + $MSSQLServerManagementStudioVSplit2
        }
        $MSSQLServerManagementStudioInstaller = "SSMS-Setup_" + "$MSSQLServerManagementStudioLanguageClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $MSSQLServerManagementStudioLanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSSQLServerManagementStudioV"
        If ($MSSQLServerManagementStudioV -ne $Version) {
            DS_WriteLog "I" "Install $Product $MSSQLServerManagementStudioLanguageClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/install"
                "/quiet"
                "/norestart"
            )
            Try {
                Write-Host "Starting install of $Product $MSSQLServerManagementStudioLanguageClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$MSSQLServerManagementStudioInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $MSSQLServerManagementStudioLanguageClear finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $MSSQLServerManagementStudioLanguageClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft SQL Server Tools*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft SQL Server Tools*" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSSQLServerManagementStudioLanguageClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSSQLServerManagementStudioLanguageClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Teams
    If ($MSTeams -eq 1) {
        If ($MSTeamsInstallerClear -eq 'Machine Based') {
            $Product = "Microsoft Teams Machine Based"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Version = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            If (!($Version)) {
                $Version = $TeamsD.Version
            }
            If (Test-Path -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                $Teams = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If (!$Teams) {
                If (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                    $Teams = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            If ($Teams) {
                $TeamsSplit = $Teams.split(".")
                $TeamsStrings = ([regex]::Matches($Teams, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Teams = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $TeamsInstaller = "Teams_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".msi"
            $TeamsLog = "$LogTemp\MSTeams.log"
            $InstallMSI = "$PSScriptRoot\$Product\$TeamsInstaller"
            If ($Teams) {$Teams = $Teams.Insert(5,'0')}
            Write-Host -ForegroundColor Magenta "Install $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $Teams"
            If ($Teams -ne $Version) {
                Write-Host -ForegroundColor Green "Update available"
                #Uninstalling MS Teams
                If ($Teams) {
                    Write-Host "Uninstall $Product"
                    DS_WriteLog "I" "Uninstall $Product" $LogFile
                    Try {
                        If (Test-Path -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                            $UninstallTeams = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).UninstallString
                        }
                        If (!$UninstallTeams) {
                            If (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                                $UninstallTeams = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).UninstallString
                            }
                        }
                        $UninstallTeams = $UninstallTeams -Replace("MsiExec.exe /I","")
                        If ($WhatIf -eq '0') {
                            Start-Process -FilePath msiexec.exe -ArgumentList "/X $UninstallTeams /qn /L*V $TeamsLog"
                            Start-Sleep 20
                        }
                        Get-Content $TeamsLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                        Remove-Item $TeamsLog -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Uninstall $Product finished!" -Verbose
                        DS_WriteLog "I" "Uninstall $Product finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error uninstalling $Product (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error uninstalling $Product (Error: $($Error[0]))" $LogFile       
                    }
                }
                DS_WriteLog "-" "" $LogFile
                #MS Teams Installation
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "REBOOT=ReallySuppress"
                    "ALLUSER=1"
                    "ALLUSERS=1"
                    "OPTIONS='noAutoStart=true'"
                    "/qn"
                    "/L*V $TeamsLog"
                )
                If (!($MSTeamsAVD)){
                    #Registry key for Teams machine-based install with Citrix VDA (Thx to Kasper https://github.com/kaspersmjohansen)
                    If (!(Test-Path 'HKLM:\Software\Citrix\PortICA\')) {
                        Write-Host "Customize System for $Product Machine Based Install"
                        If ($WhatIf -eq '0') {
                            If (!(Test-Path 'HKLM:\Software\Citrix\')) {New-Item -Path "HKLM:Software\Citrix" | Out-Null}
                            New-Item -Path "HKLM:Software\Citrix\PortICA" | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Customize System for $Product Machine Based Install finished!"
                    }
                } else {
                    #Registry key for Teams machine-based install with AVD
                    If (!(Test-Path 'HKLM:\SOFTWARE\Microsoft\Teams\')) {
                        Write-Host "Customize System for $Product Machine Based Install"
                        If ($WhatIf -eq '0') {
                            If (!(Test-Path 'HKLM:\SOFTWARE\Microsoft\Teams\')) {New-Item -Path "HKLM:SOFTWARE\Microsoft\Teams" | Out-Null}
                            New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Teams" -Name IsWVDEnvironment -PropertyType DWORD -Value 1 -Force | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Customize System for $Product Machine Based Install finished!"
                    }
                }
                Try {
                    Write-Host "Starting install of $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear version $Version"
                    DS_WriteLog "I" "Install $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear" $LogFile
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                        Start-Sleep 5
                    }
                    Get-Content $TeamsLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $TeamsLog -ErrorAction SilentlyContinue
                    If ($WhatIf -eq '0') {
                        If (Test-Path "$env:PUBLIC\Desktop\Microsoft Teams.lnk") { Remove-Item -Path "$env:PUBLIC\Desktop\Microsoft Teams.lnk" -Force }
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk" -Force}
                        }
                    }
                } Catch {
                    DS_WriteLog "E" "Error installing $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                Try {
                    Write-Host "Customize $Product"
                    #reg add "HKLM\SOFTWARE\Citrix\CtxHook\AppInit_Dlls\SfrHook" /v Teams.exe /t REG_DWORD /d 204 /f | Out-Null
                    If ($MSTeamsNoAutoStart -eq 1) {
                        #Prevents MS Teams from starting at logon, better do this with WEM or similar
                        Write-Host "Customize $Product Autorun"
                        If ($WhatIf -eq '0') {
                            If (Test-Path -Path "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run") {
                                If (Test-RegistryValue2 -Path "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run" -Value "Teams") {
                                    Remove-ItemProperty -Path "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run" -Name "Teams" -Force
                                }
                            }
                        }
                        Write-Host -ForegroundColor Green "Customize $Product Autorun finished!"
                    }
                    Write-Host "Register $Product Add-In for Outlook"
                    # Register Teams add-in for Outlook - https://microsoftteams.uservoice.com/forums/555103-public/suggestions/38846044-fix-the-teams-meeting-addin-for-outlook
                    If ($WhatIf -eq '0') {
                        $appDLLs = (Get-ChildItem -Path "${Env:ProgramFiles(x86)}\Microsoft\TeamsMeetingAddin" -Include "Microsoft.Teams.AddinLoader.dll" -Recurse).FullName
                        $appX64DLL = $appDLLs[0]
                        $appX86DLL = $appDLLs[1]
                        Start-Process -FilePath "$env:WinDir\SysWOW64\regsvr32.exe" -ArgumentList "/s /n /i:user `"$appX64DLL`"" -ErrorAction SilentlyContinue
                        Start-Process -FilePath "$env:WinDir\SysWOW64\regsvr32.exe" -ArgumentList "/s /n /i:user `"$appX86DLL`"" -ErrorAction SilentlyContinue
                    }
                    Write-Host -ForegroundColor Green "Register $Product Add-In for Outlook finished!"
                    Write-Host -ForegroundColor Green "Customize $Product finished!"
                } Catch {
                    Write-Host -ForegroundColor Red "Error when customizing $Product (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error when customizing $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
        If ($MSTeamsInstallerClear -eq 'User Based') {
            $Product = "Microsoft Teams User Based"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $TeamsD.Version
            }
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Version = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            If (Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                $Teams = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If (!$Teams) {
                If (Test-Path -Path "HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                    $Teams = (Get-ItemProperty HKCU:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            If ($Teams) {
                $TeamsSplit = $Teams.split(".")
                $TeamsStrings = ([regex]::Matches($Teams, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Teams = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $TeamsInstaller = "Teams_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear" + ".exe"
            $TeamsProcess = "Teams_" + "$MSTeamsArchitectureClear" + "_$MSTeamsRingClear"
            Write-Host -ForegroundColor Magenta "Install $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $Teams"
            If ($Teams -lt $Version) {
                DS_WriteLog "I" "Install $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Options = @(
                    "/s"
                )
                Try {
                    Write-Host "Starting install of $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $null = Start-Process -FilePath "$PSScriptRoot\$Product\$TeamsInstaller" -ArgumentList $Options -PassThru -NoNewWindow
                        while (Get-Process -Name $TeamsProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear finished!" $LogFile
                    If ($WhatIf -eq '0') {
                        If (Test-Path "$Desktop\Microsoft Teams.lnk") {Remove-Item -Path "$Desktop\Microsoft Teams.lnk" -Force}
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk" -Force}
                        }
                    }
                } Catch {
                    DS_WriteLog "E" "Error installing $Product $MSTeamsRingClear ring $MSTeamsArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                Try {
                    Write-Host "Customize $Product"
                    If ($MSTeamsNoAutoStart -eq 1) {
                        #Prevents MS Teams from starting at logon, better do this with WEM or similar
                        Write-Host "Customize $Product Autorun"
                        If ($WhatIf -eq '0') {
                             
                        }
                        Write-Host -ForegroundColor Green "Customize $Product Autorun finished!"
                    }
                } Catch {
                    Write-Host -ForegroundColor Red "Error when customizing $Product (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error when customizing $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Microsoft Teams 2
    If ($MSTeamsNew -eq 1) {
            $Product = "Microsoft Teams 2"
            $OS = (Get-CimInstance win32_OperatingSystem).caption
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSTeamsArchitectureClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If ($Version) {
                $TeamsSplit = $Version.split(".")
                $TeamsStrings = ([regex]::Matches($Version, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $Version = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            If (!($Version)) {
                $Version = $TeamsNewD.Version
            }
            $TeamsNew = (Get-AppxPackage *MSTeams*).Version
            If ($TeamsNew) {
                $TeamsSplit = $TeamsNew.split(".")
                $TeamsStrings = ([regex]::Matches($TeamsNew, "\." )).count
                $TeamsStringLast = ([regex]::Matches($TeamsSplit[$TeamsStrings], "." )).count
                If ($TeamsStringLast -lt "5") {
                    $TeamsSplit[$TeamsStrings] = "0" + $TeamsSplit[$TeamsStrings]
                }
                $TeamsNew = $TeamsSplit[0] + "." + $TeamsSplit[1] + "." + $TeamsSplit[2] + "." + $TeamsSplit[3]
            }
            $TeamsNewInstaller = "Teams_" + "$MSTeamsArchitectureClear" + ".msix"
            $TeamsLog = "$LogTemp\MSTeams2.log"
            Write-Host -ForegroundColor Magenta "Install $Product $MSTeamsArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $TeamsNew"
            If ($TeamsNew -ne $Version) {
                Write-Host -ForegroundColor Green "Update available"
                #Uninstalling MS Teams
                #Write-Host "Uninstall old Teams"
                    DS_WriteLog "I" "Uninstall old Teams" $LogFile
                    Try {
                        If (Test-Path -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                            $UninstallTeams = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).UninstallString
                        }
                        If (!$UninstallTeams) {
                            If (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                                $UninstallTeams = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Teams Machine*"}).UninstallString
                            }
                        }
                        $UninstallTeams = $UninstallTeams -Replace("MsiExec.exe /I","")
                        If (Test-Path -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\") {
                            $UninstallTeamsMeeting = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams Meeting*"}).UninstallString
                        }
                        If (!$UninstallTeamsMeeting) {
                            If (Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\") {
                                $UninstallTeamsMeeting = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Microsoft Teams Meeting*"}).UninstallString
                            }
                        }
                        $UninstallTeamsMeeting = $UninstallTeamsMeeting -Replace("MsiExec.exe /I","")
                        If ($WhatIf -eq '0') {
                            Start-Process -FilePath msiexec.exe -ArgumentList "/X $UninstallTeamsMeeting /qn /L*V $TeamsLog"
                            Start-Sleep 20
                        }
                        Get-Content $TeamsLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                        Remove-Item $TeamsLog -ErrorAction SilentlyContinue
                        #Write-Host -ForegroundColor Green "Uninstall old Teams finished!" -Verbose
                        DS_WriteLog "I" "Uninstall old Teams finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error uninstalling old Teams (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error uninstalling old Teams (Error: $($Error[0]))" $LogFile       
                    }
                If ($TeamsNew) {
                    #Write-Host "Uninstall $Product"
                    DS_WriteLog "I" "Uninstall $Product" $LogFile
                    Try {
                        If ($WhatIf -eq '0') {
                            Start-Process -FilePath "$PSScriptRoot\$Product\teamsbootstrapper.exe" -ArgumentList "-x"
                            Get-AppxPackage *MSTeams* -AllUsers | Remove-AppxPackage -AllUsers | Out-Null
                            Start-Sleep 20
                        }
                        Get-Content $TeamsLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                        Remove-Item $TeamsLog -ErrorAction SilentlyContinue
                        Write-Host -ForegroundColor Green "Uninstall $Product finished!" -Verbose
                        DS_WriteLog "I" "Uninstall $Product finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error uninstalling $Product (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error uninstalling $Product (Error: $($Error[0]))" $LogFile       
                    }
                }
                DS_WriteLog "-" "" $LogFile
                #MS Teams Installation
                If (!($MSTeamsNewAVD)){
                    #Registry key for Teams machine-based install with Citrix VDA
                    If (!(Test-Path 'HKLM:\Software\Citrix\PortICA\')) {
                        Write-Host "Customize Citrix System for $Product"
                        If ($WhatIf -eq '0') {
                            If (!(Test-Path 'HKLM:\Software\Citrix\')) {New-Item -Path "HKLM:Software\Citrix" | Out-Null}
                            New-Item -Path "HKLM:Software\Citrix\PortICA" | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Customize System for $Product finished!"
                    }
                } else {
                    #Registry key for Teams machine-based install with AVD
                    If (!(Test-Path 'HKLM:\SOFTWARE\Microsoft\Teams\')) {
                        Write-Host "Customize AVD System for $Product"
                        If ($WhatIf -eq '0') {
                            If (!(Test-Path 'HKLM:\SOFTWARE\Microsoft\Teams\')) {New-Item -Path "HKLM:SOFTWARE\Microsoft\Teams" | Out-Null}
                            New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Teams" -Name IsWVDEnvironment -PropertyType DWORD -Value 1 -Force | Out-Null
                        }
                        Write-Host -ForegroundColor Green "Customize System for $Product finished!"
                    }
                }
                $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$EdgeWebView2) {
                    $EdgeWebView2 = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Edge WebView2*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                If (!$EdgeWebView2) {
                    Write-Host -ForegroundColor Red "Microsoft Edge WebView2 is not installed."
                    Write-Host -ForegroundColor Red "No Installation of $Product possible."
                    Write-Host -ForegroundColor Red "Please install Microsoft Edge WebView2."
                    Write-Host ""
                    Write-Host -ForegroundColor Red "Press Enter to exit."
                    Read-Host
                    return
                }
                $DotNetVersion = (Get-ItemProperty "HKLM:Software\Microsoft\NET Framework Setup\NDP\v4\Full").Version
                if ($DotNetVersion -lt 4.8){
                    $URL = "https://go.microsoft.com/fwlink/?linkid=2088631"
                    $PackageName = "DotNetFramework4.8"
                    $InstallerType = "exe"
                    $Source = "$PackageName" + "." + "$InstallerType"
                    Get-Download $URL "$PSScriptRoot\$Product\" $Source -includeStats
                    $Options = @(
                        "/q"
                        "/norestart"
                        "/ChainingPackage ADMINDEPLOYMENT"
                    )
                    $null = Start-Process "$PSScriptRoot\$Product\$Source" -ArgumentList $Options -NoNewWindow -PassThru
                }
                Try {
                    Write-Host "Starting install of $Product $MSTeamsArchitectureClear version $Version"
                    DS_WriteLog "I" "Install $Product $MSTeamsArchitectureClear" $LogFile
                    New-ItemProperty -Path HKLM:\Software\Policies\Microsoft\Windows\Appx -Name AllowAllTrustedApps -Value 1 -PropertyType DWORD -Force | Out-Null
                    New-ItemProperty -Path HKLM:\Software\Policies\Microsoft\Windows\Appx -Name AllowDevelopmentWithoutDevLicense -Value 1 -PropertyType DWORD -Force | Out-Null
                    New-ItemProperty -Path HKLM:\Software\Policies\Microsoft\Windows\Appx -Name BlockNonAdminUserInstall -Value 0 -PropertyType DWORD -Force | Out-Null
                    If ($WhatIf -eq '0') {
                        If ($OS -Like "*Windows Server 2016*") {
                            Write-Host -ForegroundColor Red "Windows Server 2016 detected. No installation possible!"
                        } 
                        If ($OS -Like "*Windows Server 2019*") {
                            Write-Host "Windows Server 2019 detected. Installation without teamsbootstrapper.exe"
                            Start-Process -wait -NoNewWindow -FilePath DISM.exe -Args "/Online /Add-ProvisionedAppxPackage /PackagePath:""$PSScriptRoot\$Product\$TeamsNewInstaller"" /SkipLicense"
                        } else {
                            If ($OS -Like "*Windows Server 2022*") {
                                Write-Host "Windows Server 2022 detected. Installation with teamsbootstrapper.exe"
                                $Teams_bootstraper_exe = "$PSScriptRoot\$Product\teamsbootstrapper.exe"
                                $New_Teams_MSIX = "$PSScriptRoot\$Product\$TeamsNewInstaller"
                                & $Teams_bootstraper_exe -p -o $New_Teams_MSIX
                            }
                            If ($OS -Like "*Windows 10*") {
                                Write-Host "Windows 10 detected. Installation without teamsbootstrapper.exe"
                                Start-Process -wait -NoNewWindow -FilePath DISM.exe -Args "/Online /Add-ProvisionedAppxPackage /PackagePath:""$PSScriptRoot\$Product\$TeamsNewInstaller"" /SkipLicense"
                            }
                            If ($OS -Like "*Windows 11*") {
                                Write-Host "Windows 11 detected. Installation with teamsbootstrapper.exe"
                                $Teams_bootstraper_exe = "$PSScriptRoot\$Product\teamsbootstrapper.exe"
                                $New_Teams_MSIX = "$PSScriptRoot\$Product\$TeamsNewInstaller"
                                & $Teams_bootstraper_exe -p -o $New_Teams_MSIX
                            }
                            
                            #& "'$PSScriptRoot\$Product\teamsbootstrapper.exe' -p -o '$PSScriptRoot\$Product\$TeamsNewInstaller'"
                            #Add-AppProvisionedPackage -online -packagepath "$PSScriptRoot\$Product\$TeamsNewInstaller" -skiplicense | Out-Null
                            Start-Sleep 5
                        }
                    }
                    Get-Content $TeamsLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $TeamsLog -ErrorAction SilentlyContinue
                    If ($WhatIf -eq '0') {
                        If (Test-Path "$env:PUBLIC\Desktop\Microsoft Teams.lnk") { Remove-Item -Path "$env:PUBLIC\Desktop\Microsoft Teams.lnk" -Force }
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Microsoft Teams.lnk" -Force}
                        }
                    }
                } Catch {
                    DS_WriteLog "E" "Error installing $Product $MSTeamsArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                Write-Host "Customize $Product"
                reg add "HKLM\SOFTWARE\WOW6432Node\Citrix\WebSocketService" /v ProcessWhitelist /t REG_Multi_SZ /d msedgewebview2.exe /f | Out-Null
                reg add "HKLM\SOFTWARE\Microsoft\Teams" /v disableAutoUpdate /t REG_DWORD /d 1 /f | Out-Null
                #New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Teams" -Name disableAutoUpdate -PropertyType DWORD -Value 1 -Force | Out-Null
                #New-Item -ItemType File -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Teams\settings.json"
                Write-Host "Install $Product Add-In for Outlook"
                msiexec.exe /i "$((Get-ChildItem -Path 'C:\Program Files\WindowsApps' -Filter 'MSTeams*').FullName)\MicrosoftTeamsMeetingAddinInstaller.msi" Reboot=ReallySuppress ALLUSERS=1 TARGETDIR="C:\Windows\Microsoft\TeamsMeetingAddin" /qn
                Write-Host -ForegroundColor Green "Install $Product Add-In for Outlook finished!"
                Write-Host "Register $Product Add-In for Outlook"
                If ($WhatIf -eq '0') {
                    $appX64DLL = (Get-ChildItem -Path "C:\Windows\Microsoft\TeamsMeetingAddin\x64" -Include "Microsoft.Teams.AddinLoader.dll" -Recurse).FullName
                    $appX86DLL = (Get-ChildItem -Path "C:\Windows\Microsoft\TeamsMeetingAddin\x86" -Include "Microsoft.Teams.AddinLoader.dll" -Recurse).FullName
                    Start-Process -FilePath "$env:WinDir\SysWOW64\regsvr32.exe" -ArgumentList "/s /n /i:user `"$appX64DLL`"" -ErrorAction SilentlyContinue
                    Start-Process -FilePath "$env:WinDir\SysWOW64\regsvr32.exe" -ArgumentList "/s /n /i:user `"$appX86DLL`"" -ErrorAction SilentlyContinue
                    #Add Registry Keys for loading the Add-in
                    If (!(Test-Path 'HKLM:\Software\Microsoft\Office\Outlook\Addins\')) {New-Item -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins\" | Out-Null}
                    New-Item -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins" -Name "TeamsAddin.FastConnect" -Force -ErrorAction Ignore | Out-Null
                    New-ItemProperty -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins\TeamsAddin.FastConnect" -Type "DWord" -Name "LoadBehavior" -Value 3 -force | Out-Null
                    New-ItemProperty -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins\TeamsAddin.FastConnect" -Type "String" -Name "Description" -Value "Microsoft Teams Meeting Add-in for Microsoft Office" -force | Out-Null
                    New-ItemProperty -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins\TeamsAddin.FastConnect" -Type "String" -Name "FriendlyName" -Value "Microsoft Teams Meeting Add-in for Microsoft Office" -force | Out-Null
                    If (!(Test-Path 'HKLM:\Software\Microsoft\Office\Outlook\Addins\')) {New-Item -Path "HKLM:\Software\Microsoft\Office\Outlook\Addins\" | Out-Null}
                }
                Write-Host -ForegroundColor Green "Register $Product Add-In for Outlook finished!"
                <#If (!(Get-ScheduledTask -TaskName "Teams Meeting AddIn for Microsoft Outlook" -ErrorAction SilentlyContinue)) {
                    Write-Host "Implement scheduled task to create settings.json file in the User Profile"
                    $UsersSID = New-Object System.Security.Principal.SecurityIdentifier("S-1-5-32-545")
                    $Users = $UsersSID.Translate([System.Security.Principal.NTAccount])
                    $UsersName = $Users.Value
                    $Class = Get-CimClass MSFT_TaskEventTrigger root/Microsoft/Windows/TaskScheduler
                    $Trigger = New-ScheduledTaskTrigger -AtLogOn
                    $A = New-ScheduledTaskAction -Execute powershell.exe -Argument 'If (!(Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Teams")) { New-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Teams" -ItemType Directory | Out-Null } New-Item -ItemType File -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Teams\settings.json"'
                    $P = New-ScheduledTaskPrincipal -GroupId "$UsersName" -RunLevel Highest
                    $S = New-ScheduledTaskSettingsSet
                    # Cook it all up and create the scheduled task    
                    $RegSchTaskParameters = @{
                        TaskName    = "Teams Meeting AddIn for Microsoft Outlook"
                        Description = "Create settings.json file in the User Profile"
                        TaskPath    = "\"
                        Action      = $A
                        Principal   = $P
                        Settings    = $S
                        Trigger     = $Trigger
                    }

                    If ($WhatIf -eq '0') {
                        Register-ScheduledTask @RegSchTaskParameters -ErrorAction SilentlyContinue | Out-Null
                    }
                    Write-Host -ForegroundColor Green "Implement scheduled task to create settings.json file in the User Profile finished!"
                }#>
                Write-Host -ForegroundColor Green "Customize $Product finished!"
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }

    #// Mark: Install Microsoft Visual C++ Runtime
    If ($MSVisualCPlusPlusRuntime -eq 1) {
        $Product = "Microsoft Visual C++ Runtime"
        If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
            $MSVisualCPlusPlusRuntimeArchitectureClear = "x64"
            $MSVisualCPlusPlusRuntimeArchitecture2Clear = "x86"
        }
        # Check, if a new version is available
        If ($MSVisualCPlusPlusRuntimeRelease -ne 3) {
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $MSVisualCPlusPlusRuntimeD.Version
            }
            $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntimeV) {
                $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            If (!$MSVisualCPlusPlusRuntimeV) {
                $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
            }
            If (!$MSVisualCPlusPlusRuntimeV) {
                $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntimeInstall = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + "." + "exe"
            $MSVisualCPlusPlusRuntimeProcess = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host -ForegroundColor Magenta "Install $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $MSVisualCPlusPlusRuntimeV"
            If ($MSVisualCPlusPlusRuntimeV -ne $Version) {
                $Options = @(
                    "/install"
                    "/quiet"
                    "/norestart"
                )
                DS_WriteLog "I" "Install $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    Write-Host "Starting install of $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall" -ArgumentList $Options -PassThru -NoNewWindow
                        while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Start-Sleep -Seconds 20
                    Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitectureClear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $MSVisualCPlusPlusRuntimeD.Version
                }
                $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                }
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
                }
                If (!$MSVisualCPlusPlusRuntimeV) {
                    $MSVisualCPlusPlusRuntimeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).DisplayVersion | Sort-Object -Property DisplayVersion -Descending | Select-Object -First 1
                }
                $MSVisualCPlusPlusRuntimeInstall = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + "." + "exe"
                $MSVisualCPlusPlusRuntimeProcess = "VS-Setup" + "$MSVisualCPlusPlusRuntimeReleaseClear" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host -ForegroundColor Magenta "Install $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $MSVisualCPlusPlusRuntimeV"
                If ($MSVisualCPlusPlusRuntimeV -ne $Version) {
                    $Options = @(
                        "/install"
                        "/quiet"
                        "/norestart"
                    )
                    DS_WriteLog "I" "Install $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version"
                        If ($WhatIf -eq '0') {
                            $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall" -ArgumentList $Options -PassThru -NoNewWindow
                            while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                        }
                        Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                        DS_WriteLog "I" "Installation $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product release $MSVisualCPlusPlusRuntimeReleaseClear $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Start-Sleep -Seconds 20
                        Remove-Item "$PSScriptRoot\$Product\*$MSVisualCPlusPlusRuntimeReleaseClear*$MSVisualCPlusPlusRuntimeArchitecture2Clear*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
        } Else {
            $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $Version2012 = Get-Content -Path "$VersionPath2012" -ErrorAction SilentlyContinue
            If (!($Version2012)) {
                $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
            }
            $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $Version2013 = Get-Content -Path "$VersionPath2013" -ErrorAction SilentlyContinue
            If (!($Version2013)) {
                $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
            }
            $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + ".txt"
            $Version2022 = Get-Content -Path "$VersionPath2022" -ErrorAction SilentlyContinue
            If (!($Version2022)) {
                $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
            }
            $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2012V) {
                $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2013V) {
                $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            If (!$MSVisualCPlusPlusRuntime2022V) {
                $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitectureClear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
            }
            $MSVisualCPlusPlusRuntimeInstall2012 = "VS-Setup2012" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + "." + "exe"
            $MSVisualCPlusPlusRuntimeProcess2012 = "VS-Setup2012" + "_$MSVisualCPlusPlusRuntimeArchitectureClear"
            $MSVisualCPlusPlusRuntimeInstall2013 = "VS-Setup2013" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + "." + "exe"
            $MSVisualCPlusPlusRuntimeProcess2013 = "VS-Setup2013" + "_$MSVisualCPlusPlusRuntimeArchitectureClear"
            $MSVisualCPlusPlusRuntimeInstall2022 = "VS-Setup2022" + "_$MSVisualCPlusPlusRuntimeArchitectureClear" + "." + "exe"
            $MSVisualCPlusPlusRuntimeProcess2022 = "VS-Setup2022" + "_$MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host -ForegroundColor Magenta "Install $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2012"
            Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2012V"
            If ($MSVisualCPlusPlusRuntime2012V -ne $Version2012) {
                $Options = @(
                    "/install"
                    "/quiet"
                    "/norestart"
                )
                DS_WriteLog "I" "Install $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    Write-Host "Starting install of $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2012" -ArgumentList $Options -PassThru -NoNewWindow
                        while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2012 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version2012 finished!"
                    DS_WriteLog "I" "Installation $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product release 2012 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Start-Sleep -Seconds 20
                    Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitectureClear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            Write-Host -ForegroundColor Magenta "Install $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2013"
            Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2013V"
            If ($MSVisualCPlusPlusRuntime2013V -ne $Version2013) {
                $Options = @(
                    "/install"
                    "/quiet"
                    "/norestart"
                )
                DS_WriteLog "I" "Install $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    Write-Host "Starting install of $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2013" -ArgumentList $Options -PassThru -NoNewWindow
                        while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2013 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version2013 finished!"
                    DS_WriteLog "I" "Installation $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product release 2013 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Start-Sleep -Seconds 20
                    Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitectureClear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            Write-Host -ForegroundColor Magenta "Install $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear"
            Write-Host "Download Version: $Version2022"
            Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2022V"
            If ($MSVisualCPlusPlusRuntime2022V -ne $Version2022) {
                $Options = @(
                    "/install"
                    "/quiet"
                    "/norestart"
                )
                DS_WriteLog "I" "Install $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                Try {
                    Write-Host "Starting install of $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear version $Version"
                    If ($WhatIf -eq '0') {
                        $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2022" -ArgumentList $Options -PassThru -NoNewWindow
                        while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2022 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version2022 finished!"
                    DS_WriteLog "I" "Installation $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear finished!" $LogFile
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product release 2022 $MSVisualCPlusPlusRuntimeArchitectureClear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Start-Sleep -Seconds 20
                    Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitectureClear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            If ($MSVisualCPlusPlusRuntime_Architecture -eq 3) {
                $VersionPath2012 = "$PSScriptRoot\$Product\Version_2012" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $Version2012 = Get-Content -Path "$VersionPath2012" -ErrorAction SilentlyContinue
                If (!($Version2012)) {
                    $Version2012 = $MSVisualCPlusPlusRuntime2012D.Version
                }
                $VersionPath2013 = "$PSScriptRoot\$Product\Version_2013" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $Version2013 = Get-Content -Path "$VersionPath2013" -ErrorAction SilentlyContinue
                If (!($Version2013)) {
                    $Version2013 = $MSVisualCPlusPlusRuntime2013D.Version
                }
                $VersionPath2022 = "$PSScriptRoot\$Product\Version_2022" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + ".txt"
                $Version2022 = Get-Content -Path "$VersionPath2022" -ErrorAction SilentlyContinue
                If (!($Version2022)) {
                    $Version2022 = $MSVisualCPlusPlusRuntime2022D.Version
                }
                $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                If (!$MSVisualCPlusPlusRuntime2012V) {
                    $MSVisualCPlusPlusRuntime2012V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2012*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                }
                $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                If (!$MSVisualCPlusPlusRuntime2013V) {
                    $MSVisualCPlusPlusRuntime2013V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2013*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                }
                $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                If (!$MSVisualCPlusPlusRuntime2022V) {
                    $MSVisualCPlusPlusRuntime2022V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Microsoft Visual C++ *2015*$MSVisualCPlusPlusRuntimeArchitecture2Clear*"}).BundleVersion | Sort-Object -Property BundleVersion -Descending | Select-Object -First 1
                }
                $MSVisualCPlusPlusRuntimeInstall2012 = "VS-Setup2012" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + "." + "exe"
                $MSVisualCPlusPlusRuntimeProcess2012 = "VS-Setup2012" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $MSVisualCPlusPlusRuntimeInstall2013 = "VS-Setup2013" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + "." + "exe"
                $MSVisualCPlusPlusRuntimeProcess2013 = "VS-Setup2013" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                $MSVisualCPlusPlusRuntimeInstall2022 = "VS-Setup2022" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear" + "." + "exe"
                $MSVisualCPlusPlusRuntimeProcess2022 = "VS-Setup2022" + "_$MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host -ForegroundColor Magenta "Install $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2012"
                Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2012V"
                If ($MSVisualCPlusPlusRuntime2012V -ne $Version2012) {
                    $Options = @(
                        "/install"
                        "/quiet"
                        "/norestart"
                    )
                    DS_WriteLog "I" "Install $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version"
                        If ($WhatIf -eq '0') {
                            $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2012" -ArgumentList $Options -PassThru -NoNewWindow
                            while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2012 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                        }
                        Write-Host -ForegroundColor Green "Install of the new version $Version2012 finished!"
                        DS_WriteLog "I" "Installation $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product release 2012 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Start-Sleep -Seconds 20
                        Remove-Item "$PSScriptRoot\$Product\*2012_$MSVisualCPlusPlusRuntimeArchitecture2Clear*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                Write-Host -ForegroundColor Magenta "Install $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2013"
                Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2013V"
                If ($MSVisualCPlusPlusRuntime2013V -ne $Version2013) {
                    $Options = @(
                        "/install"
                        "/quiet"
                        "/norestart"
                    )
                    DS_WriteLog "I" "Install $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version"
                        If ($WhatIf -eq '0') {
                            $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2013" -ArgumentList $Options -PassThru -NoNewWindow
                            while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2013 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                        }
                        Write-Host -ForegroundColor Green "Install of the new version $Version2013 finished!"
                        DS_WriteLog "I" "Installation $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product release 2013 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Start-Sleep -Seconds 20
                        Remove-Item "$PSScriptRoot\$Product\*2013_$MSVisualCPlusPlusRuntimeArchitecture2Clear*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                Write-Host -ForegroundColor Magenta "Install $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear"
                Write-Host "Download Version: $Version2022"
                Write-Host "Current Version:  $MSVisualCPlusPlusRuntime2022V"
                If ($MSVisualCPlusPlusRuntime2022V -ne $Version2022) {
                    $Options = @(
                        "/install"
                        "/quiet"
                        "/norestart"
                    )
                    DS_WriteLog "I" "Install $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear version $Version"
                        If ($WhatIf -eq '0') {
                            $null = Start-Process -FilePath "$PSScriptRoot\$Product\$MSVisualCPlusPlusRuntimeInstall2022" -ArgumentList $Options -PassThru -NoNewWindow
                            while (Get-Process -Name $MSVisualCPlusPlusRuntimeProcess2022 -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                        }
                        Write-Host -ForegroundColor Green "Install of the new version $Version2022 finished!"
                        DS_WriteLog "I" "Installation $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear finished!" $LogFile
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product release 2022 $MSVisualCPlusPlusRuntimeArchitecture2Clear (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Start-Sleep -Seconds 20
                        Remove-Item "$PSScriptRoot\$Product\*2022_$MSVisualCPlusPlusRuntimeArchitecture2Clear*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Install Microsoft Visual Studio 2019
    If ($MSVisualStudio -eq 1) {
        $Product = "Microsoft Visual Studio 2019"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSVisualStudioD.Version
        }
        $MSVisualStudioV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio $MSVisualStudioEditionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSVisualStudioV) {
            $MSVisualStudioV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio $MSVisualStudioEditionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        Write-Host -ForegroundColor Magenta "Install $Product $MSVisualStudioEditionClear edition"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSVisualStudioV"
        If ($MSVisualStudioV -ne $Version) {
            $MSVisualStudioEditionInstall = "Microsoft.VisualStudio.Product." + "$MSVisualStudioEditionClear"
            If ($MSVisualStudioV) {
                $Options = @(
                    "update"
                    "--quiet"
                    "--norestart"
                    "--productid $MSVisualStudioEditionInstall"
                    "--channelid VisualStudio.16.Release"
                    "--wait"
                )
            }
            Else {
                $Options = @(
                    "--quiet"
                    "--norestart"
                    "--productid $MSVisualStudioEditionInstall"
                    "--channelid VisualStudio.16.Release"
                    "--wait"
                )
            }
            DS_WriteLog "I" "Install $Product $MSVisualStudioEditionClear edition" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $MSVisualStudioEditionClear edition version $Version"
                If ($WhatIf -eq '0') {
                    $null = Start-Process -FilePath "$PSScriptRoot\$Product\VS-Setup.exe" -ArgumentList $Options -PassThru -NoNewWindow
                    while (Get-Process -Name setup -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio 2019") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio 2019" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio 2019.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio 2019.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio Installer.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio Installer.lnk" -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Blend for Visual Studio 2019.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Blend for Visual Studio 2019.lnk" -Force}
                    }
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product $MSVisualStudioEditionClear Edition finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSVisualStudioEditionClear edition (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSVisualStudioEditionClear edition (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Start-Sleep -Seconds 20
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Microsoft Visual Studio Code
    If ($MSVisualStudioCode -eq 1) {
        $Product = "Microsoft Visual Studio Code"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MSVisualStudioCodeD.Version
        }
        $MSVisualStudioCodeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MSVisualStudioCodeV) {
            $MSVisualStudioCodeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$MSVisualStudioCodeV) {
            $MSVisualStudioCodeV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Visual Studio Code*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MSVisualStudioCodeInstall = "VSCode-Setup-" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear" + "." + "exe"
        $MSVisualStudioCodeProcess = "VSCode-Setup-" + "$MSVisualStudioCodeChannelClear" + "-$MSVisualStudioCodePlatformClear"
        Write-Host -ForegroundColor Magenta "Install $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MSVisualStudioCodeV"
        If ($MSVisualStudioCodeV -ne $Version) {
            Write-Host -ForegroundColor Green "Update available"
            DS_WriteLog "I" "Install $Product $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear" $LogFile
            $Options = @(
                "/VERYSILENT"
                "/MERGETASKS=!runcode"
            )
            Try {
                Write-Host "Starting install of $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear version $Version"
                If ($WhatIf -eq '0') {
                    $null = Start-Process "$PSScriptRoot\$Product\$MSVisualStudioCodeInstall" -ArgumentList $Options -NoNewWindow -PassThru
                    while (Get-Process -Name $MSVisualStudioCodeProcess -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Visual Studio Code*") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Visual Studio Code*" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio Code*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Visual Studio Code*" -Recurse -Force}
                    }
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MSVisualStudioCodeChannelClear channel $MSVisualStudioCodeArchitectureClear $MSVisualStudioCodeModeClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install MindView
    If ($MindView7 -eq 1) {
        $Product = "MindView"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MindView7LanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $MindView7D.Version
        }
        $MindView7V = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*MindView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$MindView7V) {
            $MindView7V = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*MindView*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MindView7Installer = "MindView-" + "$MindView7LanguageClear" + "." + "exe"
        $MindView7Process = "MindView-" + "$MindView7LanguageClear"
        Write-Host -ForegroundColor Magenta "Install $Product $MindView7LanguageClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MindView7V"
        If ($MindView7V -lt $Version) {
            Write-Host -ForegroundColor Green "Update available"
            DS_WriteLog "I" "Install $Product $Product $MindView7LanguageClear" $LogFile
            $Options = @(
                "/quiet"
            )
            Try {
                Write-Host "Starting install of $Product $MindView7LanguageClear version $Version"
                If ($WhatIf -eq '0') {
                    $null = Start-Process "$PSScriptRoot\$Product\$MindView7Installer" -ArgumentList $Options -NoNewWindow -PassThru
                    while (Get-Process -Name $MindView7Process -ErrorAction SilentlyContinue) { Start-Sleep -Seconds 10 }
                    If (Test-Path -Path "$env:PUBLIC\Desktop\MindView*.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\MindView*.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\MindView*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\MindView*" -Recurse -Force}
                    }
                }
                Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                DS_WriteLog "I" "Installation $Product $MindView7LanguageClear finished!" $LogFile
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $MindView7LanguageClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $MindView7LanguageClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Mozilla Firefox
    If ($Firefox -eq 1) {
        $Product = "Mozilla Firefox"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$FirefoxChannelClear" + "$FirefoxArchitectureClear" + "$FFLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $FirefoxD.Version
        }
        $FirefoxV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Firefox*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $FirefoxLog = "$LogTemp\Firefox.log"
        If (!$FirefoxV) {
            $FirefoxV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Firefox*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $FirefoxInstaller = "Firefox_Setup_" + "$FirefoxChannelClear" + "$FirefoxArchitectureClear" + "_$FFLanguageClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$FirefoxInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $FirefoxV"
        If ($FirefoxV -ne $Version) {
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/q"
                "DESKTOP_SHORTCUT=false"
                "TASKBAR_SHORTCUT=false"
                "INSTALL_MAINTENANCE_SERVICE=false"
                "PREVENT_REBOOT_REQUIRED=true"
                "/L*V $FirefoxLog"
            )
            DS_WriteLog "I" "Install $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Firefox.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Firefox.lnk" -Force}
                    }
                }
                Get-Content $FirefoxLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $FirefoxLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $FirefoxChannelClear $FFLanguageLongClear $FirefoxArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            Write-Host "Customize $Product"
            Try {
                # Disable Microsoft Edge auto update
                Write-Host "Customize $Product registry"
                If ($WhatIf -eq '0') {
                    If (!(Test-Path -Path HKLM:SOFTWARE\Policies\Mozilla\Firefox)) {
                        New-Item -Path HKLM:SOFTWARE\Policies\Mozilla\Firefox -ErrorAction SilentlyContinue | Out-Null
                        New-ItemProperty -Path HKLM:SOFTWARE\Policies\Mozilla\Firefox -Name DisableAppUpdate -Value 1 -PropertyType DWORD -ErrorAction SilentlyContinue | Out-Null
                    }
                    Else {
                        $FFUpdateState = Get-ItemProperty -path "HKLM:SOFTWARE\Policies\Mozilla\Firefox" | Select-Object -Expandproperty "DisableAppUpdate"
                        If ($FFUpdateState -ne "0") {Set-ItemProperty -Path HKLM:SOFTWARE\Policies\Mozilla\Firefox -Name DisableAppUpdate -Value 1 | Out-Null}
                    }
                }
                Write-Host -ForegroundColor Green "Customize $Product registry finished!"
                Write-Host -ForegroundColor Green "Customize $Product finished!"
            } Catch {
                Write-Host -ForegroundColor Red "Error customizing (Error: $($Error[0]))"
                DS_WriteLog "E" "Error customizing (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Mozilla Thunderbird
    If ($MozillaThunderbird -eq 1) {
        $Product = "Mozilla Thunderbird"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$MozillaThunderbirdArchitectureClear" + "_$MozillaThunderbirdLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -EA SilentlyContinue
        If (!($Version)) {
            $Version = $MozillaThunderbirdD.Version
        }
        $MozillaThunderbirdV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Thunderbird*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $MozillaThunderbirdLog = "$LogTemp\MozillaThunderbird.log"
        If (!$MozillaThunderbirdV) {
            $MozillaThunderbirdV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Thunderbird*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $MozillaThunderbirdInstaller = "Thunderbird_Setup_" + "$MozillaThunderbirdArchitectureClear" + "_$MozillaThunderbirdLanguageClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$MozillaThunderbirdInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $MozillaThunderbirdV"
        If ($MozillaThunderbirdV -ne $Version) {
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/q"
                "DESKTOP_SHORTCUT=false"
                "TASKBAR_SHORTCUT=false"
                "INSTALL_MAINTENANCE_SERVICE=false"
                "PREVENT_REBOOT_REQUIRED=true"
                "/L*V $MozillaThunderbirdLog"
            )
            DS_WriteLog "I" "Install $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Mozilla Thunderbird.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Mozilla Thunderbird.lnk" -Force}
                    }
                }
                Get-Content $MozillaThunderbirdLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $MozillaThunderbirdLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $MozillaThunderbirdLanguageLongClear $MozillaThunderbirdArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install mRemoteNG
    If ($mRemoteNG -eq 1) {
        $Product = "mRemoteNG"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $mRemoteNGD.Version
        }
        $mRemoteNGV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "mRemoteNG"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$mRemoteNGV) {
            $mRemoteNGV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "mRemoteNG"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $mRemoteLog = "$LogTemp\mRemote.log"
        If ($mRemoteNGV) {$mRemoteNGV = $mRemoteNGV -replace ".{6}$"}
        $InstallMSI = "$PSScriptRoot\$Product\mRemoteNG.msi"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $mRemoteNGV"
        If ($mRemoteNGV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $mRemoteLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                }
                Get-Content $mRemoteLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $mRemoteLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
            If ($WhatIf -eq '0') {
                If (Test-Path -Path "$env:PUBLIC\Desktop\mRemoteNG.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\mRemoteNG.lnk" -Force}
                If ($CleanUpStartMenu) {
                    If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\mRemoteNG") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\mRemoteNG" -Recurse -Force}
                }
            }
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Nmap
    If ($Nmap -eq 1) {
        $Product = "Nmap"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $NMapD.Version
        }
        $NmapV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Nmap*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$NmapV) {
            $NmapV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Nmap*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $NmapInstaller = "Nmap-setup.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $NmapV"
        If ($NmapV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$NmapInstaller"
                }
                $p = Get-Process Nmap-setup -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Nmap") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Nmap" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile       
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Notepad ++
    If ($NotePadPlusPlus -eq 1) {
        $Product = "NotepadPlusPlus"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$NotepadPlusPlusArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $NotepadD.Version
        }
        $Notepad = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Notepad++*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$Notepad) {
            $Notepad = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Notepad++*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $NotepadPlusPlusInstaller = "NotePadPlusPlus_" + "$NotepadPlusPlusArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $NotepadPlusPlusArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $Notepad"
        If ($Notepad -lt $Version) {
            DS_WriteLog "I" "Install $Product $NotepadPlusPlusArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $NotepadPlusPlusArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$NotepadPlusPlusInstaller" -ArgumentList /S -NoNewWindow
                }
                $p = Get-Process NotePadPlusPlus_$NotepadPlusPlusArchitectureClear -ErrorAction SilentlyContinue
		        If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Notepad++.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Notepad++.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $NotepadPlusPlusArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $NotepadPlusPlusArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install OpenJDK
    If ($OpenJDK -eq 1) {
        $Product = "OpenJDK"
        If ($openJDK_Architecture -eq 3) {
            $openJDKArchitectureClear = "x64"
            $openJDKArchitecture2Clear = "x86"
        }
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$openJDKArchitectureClear" + "_$OpenJDKPackageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $OpenJDKD.Version
        }
        If ($OpenJDKPackageClear -eq "8") {
            If ($openJDKArchitectureClear -eq "x86") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            } else {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
            }
            $OpenJDKSplit = $OpenJDKV.split(".")
            $OpenJDKStrings = ([regex]::Matches($OpenJDKV, "\." )).count
            $OpenJDKStringsNotLast = $OpenJDKStrings
            $OpenJDKStringsNotLast --
            $OpenJDKStringPenultimate = ([regex]::Matches($OpenJDKSplit[$OpenJDKStringsNotLast], "." )).count
            If ($OpenJDKStringPenultimate -eq "4") {
                $OpenJDKDR = $OpenJDKSplit[$OpenJDKStringsNotLast]
                $OpenJDKDR = $OpenJDKDR[0] + $OpenJDKDR[1] + $OpenJDKDR[2] + "." + $OpenJDKDR[3]
                $OpenJDKSplit[$OpenJDKStringsNotLast] = $OpenJDKDR
            }
            Switch ($OpenJDKStrings) {
                1 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[3]
                }
            }
            If ($Version) {$Version = $Version -replace "-"}
            If ($Version) {$Version = $Version -replace "\.0"}
            If ($Version -like "*b0*") {$Version = $Version -replace "b0"}
        }
        If ($OpenJDKPackageClear -eq "11") {
            $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$OpenJDKV) {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If ($Version) {$Version = $Version -replace ".-"}
        }
        If ($OpenJDKPackageClear -eq "17") {
            $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$OpenJDKV) {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            $OpenJDKSplit = $OpenJDKV.split(".")
            $OpenJDKStrings = ([regex]::Matches($OpenJDKV, "\." )).count
            $OpenJDKDR = $OpenJDKSplit[1]
            $OpenJDKDR = $OpenJDKDR[1] + "." + $OpenJDKDR[2] + "." + $OpenJDKDR[3]
            $OpenJDKSplit[1] = $OpenJDKDR
            Switch ($OpenJDKStrings) {
                1 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1]
                }
                2 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2]
                }
                3 {
                    $OpenJDKV = $OpenJDKSplit[0] + "." + $OpenJDKSplit[1] + "." + $OpenJDKSplit[2] + "." + $OpenJDKSplit[3]
                }
            }
            If ($Version) {$Version = $Version -replace('-','.')}
            If ($Version) {$Version = $Version -replace('.0.1.','.001')}
        }
        $openJDKLog = "$LogTemp\OpenJDK.log"
        $OpenJDKInstaller = "OpenJDK_" + "$openJDKArchitectureClear" + "_$OpenJDKPackageClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$OpenJDKInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product release $OpenJDKPackageClear $openJDKArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $OpenJDKV"
        If ($OpenJDKV -lt $Version) {
            DS_WriteLog "I" "Install $Product release $OpenJDKPackageClear $openJDKArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "INSTALLLEVEL=3"
                "UPDATE_NOTIFIER=0"
                "/L*V $openJDKLog"
            )
            Try {
                Write-Host "Starting install of $Product release $OpenJDKPackageClear $openJDKArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                }
                Get-Content $openJDKLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $openJDKLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product release $OpenJDKPackageClear $openJDKArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*$openJDKArchitectureClear*$OpenJDKPackageClear*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        If ($openJDK_Architecture -eq 3) {
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$openJDKArchitecture2Clear" + "_$OpenJDKPackageClear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $OpenJDKD.Version
            }
            If ($OpenJDKPackageClear -eq "8") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 1.8*x86*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                If ($Version) {$Version = $Version -replace "-"}
                If ($Version) {$Version = $Version -replace "\.0"}
                If ($Version -like "*b0*") {$Version = $Version -replace "b0"}
            }
            If ($OpenJDKPackageClear -eq "11") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 11*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                If ($Version) {$Version = $Version -replace ".-"}
            }
            If ($OpenJDKPackageClear -eq "15") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 15*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 15*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                If ($Version) {$Version = $Version -replace ".-"}
            }
            If ($OpenJDKPackageClear -eq "17") {
                $OpenJDKV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$OpenJDKV) {
                    $OpenJDKV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenJDK 17*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                If ($Version) {$Version = $Version -replace('-','.')}
                If ($Version) {$Version = $Version -replace('.0.1.','.001')}
            }
            $openJDKLog = "$LogTemp\OpenJDK.log"
            $OpenJDKInstaller = "OpenJDK_" + "$openJDKArchitecture2Clear" + "_$OpenJDKPackageClear" + ".msi"
            $InstallMSI = "$PSScriptRoot\$Product\$OpenJDKInstaller"
            Write-Host -ForegroundColor Magenta "Install $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $OpenJDKV"
            If ($OpenJDKV -lt $Version) {
                DS_WriteLog "I" "Install $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/qn"
                    "INSTALLLEVEL=3"
                    "UPDATE_NOTIFIER=0"
                    "/L*V $openJDKLog"
                )
                Try {
                    Write-Host "Starting install of $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                        Start-Sleep 25
                    }
                    Get-Content $openJDKLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $openJDKLog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product release $OpenJDKPackageClear $openJDKArchitecture2Clear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*$openJDKArchitecture2Clear*$OpenJDKPackageClear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Open-Shell Menu
    If ($OpenShellMenu -eq 1) {
        $Product = "Open-Shell Menu"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $OpenShellMenuD.Version
        }
        $OpenShellMenuV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Open-Shell*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OpenShellMenuV) {
            $OpenShellMenuV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Open-Shell*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $OpenShellMenuInstaller = "OpenShellSetup.exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $OpenShellMenuV"
        If ($OpenShellMenuV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/quiet"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$OpenShellMenuInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process OpenShellSetup -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Open-Shell") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Open-Shell" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install OpenWebStart
    If ($OpenWebStart -eq 1) {
        $Product = "OpenWebStart"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OpenWebStartArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $OpenWebStartD.Version
        }
        $OpenWebStartV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenWebStart*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OpenWebStartV) {
            $OpenWebStartV = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*OpenWebStart*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $OpenWebStartInstaller = "OpenWebStart_" + "$OpenWebStartArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $OpenWebStartArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $OpenWebStartV"
        If ($OpenWebStartV -lt $Version) {
            DS_WriteLog "I" "Install $Product $OpenWebStartArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $OpenWebStartArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$OpenWebStartInstaller" -ArgumentList -q
                }
                $p = Get-Process OpenWebStart_$OpenWebStartArchitectureClear -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $OpenWebStartArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\OpenWebStart") {Remove-Item -Path "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\OpenWebStart" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $OpenWebStartArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $OpenWebStartArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Opera Browser
    If ($OperaBrowser -eq 1) {
        $Product = "Opera Browser"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OperaBrowserArchitectureClear" + "_$OperaBrowserChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $OperaBrowserD.Version
        }
        $OperaBrowserV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Opera*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OperaBrowserV) {
            $OperaBrowserV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Opera*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $OperaBrowserInstaller = "OperaBrowser_" + "$OperaBrowserArchitectureClear" + "_$OperaBrowserChannelClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $OperaBrowserV"
        If ($OperaBrowserV -lt $Version) {
            $Options = @(
                "/silent"
                "/allusers=1"
                "/launchopera=0"
                "/setdefaultbrowser=0"
            )
            DS_WriteLog "I" "Install $Product $OperaBrowserArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $OperaBrowserChannelClear $OperaBrowserArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$OperaBrowserInstaller" -ArgumentList $Options -ErrorAction Stop
                }
                $p = Get-Process OperaBrowser_$OperaBrowserArchitectureClear_$OperaBrowserChannelClear -ErrorAction SilentlyContinue
		        If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Opera-Browser.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Opera-Browser.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Opera*.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Opera*.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $OperaBrowserArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $OperaBrowserArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Oracle Java 8
    If ($OracleJava8 -eq 1) {
        $Product = "Oracle Java 8"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OracleJava8ArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $OracleJava8D.Version
        }
        $OracleJava = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8ArchitectureVersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$OracleJava) {
            $OracleJava = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8ArchitectureVersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($OracleJava) {
            $OracleJavaSplit = $OracleJava.split(".")
            $OracleJavaSplit2 = (Select-String '.{3}' -Input $OracleJavaSplit[2]).Matches.Value
            $OracleJava = "1." + $OracleJavaSplit[0] + "." + $OracleJavaSplit[1] + "_" + $OracleJavaSplit2 + "-b" + $OracleJavaSplit[3]
        }
        $OracleJavaInstaller = "OracleJava8_" + "$OracleJava8ArchitectureClear" +".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $OracleJava8ArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $OracleJava"
        If ($OracleJava -lt $Version) {
            DS_WriteLog "I" "Install $Product $OracleJava8ArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/s INSTALL_SILENT=Enable AUTO_UPDATE=Disable REBOOT=Disable SPONSORS=Disable REMOVEOUTOFDATEJRES=1 WEB_ANALYTICS=Disable NOSTARTMENU=1 WEB_JAVA=1 WEB_JAVA_SECURITY_LEVEL=H WEB_ANALYTICS=0"
            )
            Try {
                Write-Host "Starting install of $Product $OracleJava8ArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$OracleJavaInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process OracleJava8_$OracleJava8ArchitectureClear -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Java") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Java" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $OracleJava8ArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $OracleJava8ArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*$OracleJava8ArchitectureClear*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        If ($OracleJava8_Architecture -eq 3) {
            $VersionPath = "$PSScriptRoot\$Product\Version_" + "$OracleJava8Architecture2Clear" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $OracleJava8D.Version
            }
            $OracleJava = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8Architecture2VersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            If (!$OracleJava) {
                $OracleJava = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Java 8*$OracleJava8Architecture2VersionClear*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            }
            If ($OracleJava) {
                $OracleJavaSplit = $OracleJava.split(".")
                $OracleJavaSplit2 = (Select-String '.{3}' -Input $OracleJavaSplit[2]).Matches.Value
                $OracleJava = "1." + $OracleJavaSplit[0] + "." + $OracleJavaSplit[1] + "_" + $OracleJavaSplit2 + "-b" + $OracleJavaSplit[3]
            }
            $OracleJavaInstaller = "OracleJava8_" + "$OracleJava8Architecture2Clear" +".exe"
            Write-Host -ForegroundColor Magenta "Install $Product $OracleJava8Architecture2Clear"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $OracleJava"
            If ($OracleJava -lt $Version) {
                DS_WriteLog "I" "Install $Product $OracleJava8Architecture2Clear" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Options = @(
                    "/s INSTALL_SILENT=Enable AUTO_UPDATE=Disable REBOOT=Disable SPONSORS=Disable REMOVEOUTOFDATEJRES=1 WEB_ANALYTICS=Disable NOSTARTMENU=1 WEB_JAVA=1 WEB_JAVA_SECURITY_LEVEL=H WEB_ANALYTICS=0"
                )
                Try {
                    Write-Host "Starting install of $Product $OracleJava8Architecture2Clear version $Version"
                    If ($WhatIf -eq '0') {
                        Start-Process "$PSScriptRoot\$Product\$OracleJavaInstaller" -ArgumentList $Options -NoNewWindow
                    }
                    $p = Get-Process OracleJava8_$OracleJava8Architecture2Clear -ErrorAction SilentlyContinue
                    If ($p) {
                        $p.WaitForExit()
                        Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                        DS_WriteLog "I" "Installation $Product finished!" $LogFile
                    }
                    If ($WhatIf -eq '0') {
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Java") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Java" -Recurse -Force}
                        }
                    }
                } Catch {
                    Write-Host -ForegroundColor Red "Error installing $Product $OracleJava8Architecture2Clear (Error: $($Error[0]))"
                    DS_WriteLog "E" "Error installing $Product $OracleJava8Architecture2Clear (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
            If ($CleanUp -eq '1') {
                If ($WhatIf -eq '0') {
                    Remove-Item "$PSScriptRoot\$Product\*$OracleJava8Architecture2Clear*" -Recurse
                }
                Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
        }
    }

    #// Mark: Install Paint.Net
    If ($PaintDotNet -eq 1) {
        $Product = "Paint.Net"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PaintDotNetArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PaintDotNetD.Version
        }
        $PaintDotNetV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Paint.Net*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PaintDotNetV) {
            $PaintDotNetV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Paint.Net*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $PaintDotNetInstaller = "paint.net_" + "$PaintDotNetArchitectureClear" + ".msi"
        $PaintDotNetLog = "$LogTemp\PaintDotNet.log"
        $InstallMSI = "$PSScriptRoot\$Product\$PaintDotNetInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $PaintDotNetArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PaintDotNetV"
        If ($PaintDotNetV -lt $Version) {
            DS_WriteLog "I" "Install $Product $PaintDotNetArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $PaintDotNetLog"
            )
            Try {
                Write-Host "Starting install of $Product $PaintDotNetArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Paint.Net.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Paint.Net.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PaintDotNet*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PaintDotNet*" -Recurse -Force}
                    }
                }
                Get-Content $PaintDotNetLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $PaintDotNetLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $PaintDotNetArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install PDF24 Creator
    If ($PDF24Creator -eq 1) {
        $Product = "PDF24 Creator"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PDF24CreatorD.Version
        }
        $PDF24Split = $Version.split(".")
        $PDF24Strings = ([regex]::Matches($Version, "\." )).count
        $PDF24Pen = $PDF24Strings-1
        $PDF24StringPen = ([regex]::Matches($PDF24Split[$PDF24Pen], "." )).count
        If ($PDF24StringPen -lt "2") {
            $PDF24Split[$PDF24Pen] = "0" + $PDF24Split[$PDF24Pen]
        }
        Switch ($PDF24Strings) {
            1 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1]
            }
            2 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1] + "." + $PDF24Split[2]
            }
            3 {
                $Version = $PDF24Split[0] + "." + $PDF24Split[1] + "." + $PDF24Split[2] + "." + $PDF24Split[3]
            }
        }
        $PDF24CreatorV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PDF24 Creator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PDF24CreatorV) {
            $PDF24CreatorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PDF24 Creator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $PDF24RegSplit = $PDF24CreatorV.split(".")
        $PDF24RegStrings = ([regex]::Matches($PDF24CreatorV, "\." )).count
        $PDF24RegPen = $PDF24RegStrings-1
        $PDF24RegStringPen = ([regex]::Matches($PDF24RegSplit[$PDF24RegPen], "." )).count
        If ($PDF24RegStringPen -lt "2") {
            $PDF24RegSplit[$PDF24RegPen] = "0" + $PDF24RegSplit[$PDF24RegPen]
        }
        Switch ($PDF24RegStrings) {
            1 {
                $PDF24CreatorV = $PDF24RegSplit[0] + "." + $PDF24RegSplit[1]
            }
            2 {
                $PDF24CreatorV = $PDF24RegSplit[0] + "." + $PDF24RegSplit[1] + "." + $PDF24RegSplit[2]
            }
            3 {
                $PDF24CreatorV = $PDF24RegSplit[0] + "." + $PDF24RegSplit[1] + "." + $PDF24RegSplit[2] + "." + $PDF24RegSplit[3]
            }
        }
        $PDF24CreatorInstaller = "PDF24Creator.msi"
        $PDF24CreatorLog = "$LogTemp\PDF24Creator.log"
        $InstallMSI = "$PSScriptRoot\$Product\$PDF24CreatorInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PDF24CreatorV"
        If ($PDF24CreatorV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $PDF24CreatorLog"
                "DESKTOPICONS=No"
                "FAXPRINTER=No"
                "REGISTERREADER=No"
                "AUTOUPDATE=No"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If (Test-Path -Path "$env:PUBLIC\Desktop\PDF24.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\PDF24.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDF24*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDF24*" -Recurse -Force}
                    }
                }
                Get-Content $PDF24CreatorLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $PDF24CreatorLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install pdfforge PDFCreator
    If ($PDFForgeCreator -eq 1) {
        $Product = "pdfforge PDFCreator"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$pdfforgePDFCreatorChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PDFForgeCreatorD.Version
        }
        $PDFForgeCreatorV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFCreator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PDFForgeCreatorV) {
            $PDFForgeCreatorV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFCreator*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $PDFForgeCreatorInstaller = "PDFForgeCreatorWebSetup_" + "$pdfforgePDFCreatorChannelClear" + ".exe"
        $PDFForgeCreatorProcess = "PDFForgeCreatorWebSetup" + "$pdfforgePDFCreatorChannelClear"
        Write-Host -ForegroundColor Magenta "Install $Product $pdfforgePDFCreatorChannelClear edition"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PDFForgeCreatorV"
        If ($PDFForgeCreatorV -lt $Version) {
            DS_WriteLog "I" "Install $Product $pdfforgePDFCreatorChannelClear edition" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/NORESTART /NoIcons"
            )
            Try {
                Write-Host "Starting install of $Product $pdfforgePDFCreatorChannelClear edition version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$PDFForgeCreatorInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process $PDFForgeCreatorProcess -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $pdfforgePDFCreatorChannelClear edition finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDFCreator.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDFCreator.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $pdfforgePDFCreatorChannelClear edition (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $pdfforgePDFCreatorChannelClear edition (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install PDF Split & Merge
    If ($PDFsam -eq 1) {
        $Product = "PDF Split & Merge"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PDFsamD.Version
        }
        $PDFsamV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFsam*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $PDFsamLog = "$LogTemp\PDFsam.log"
        If (!$PDFsamV) {
            $PDFsamV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PDFsam*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($PDFsamV) {
            $PDFsamSplit = $PDFsamV.split(".")
            $PDFsamV = $PDFsamSplit[0] + "." + $PDFsamSplit[1] + "." + $PDFsamSplit[2]
        }
        $PDFsamInstaller = "PDFsam.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$PDFsamInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PDFsamV"
        If ($PDFsamV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $PDFsamLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If (Test-Path -Path "$env:PUBLIC\Desktop\PDFsam Basic.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\PDFsam Basic.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDFsam*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PDFsam*" -Recurse -Force}
                    }
                }
                Get-Content $PDFsamLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $PDFsamLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install PeaZip
    If ($PeaZip -eq 1) {
        $Product = "PeaZip"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PeaZipArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PeaZipD.Version
        }
        $PeaZipV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PeaZip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$PeaZipV) {
            $PeaZipV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "PeaZip*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $PeaZipInstaller = "PeaZip" + "$PeaZipArchitectureClear" + ".exe"
        $PeaZipProcess = "PeaZip" + "$PeaZipArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product $PeaZipArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PeaZipV"
        If ($PeaZipV -lt $Version) {
            DS_WriteLog "I" "Install $Product $PeaZipArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/VERYSILENT"
            )
            Try {
                Write-Host "Starting install of $Product $PeaZipArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$PeaZipInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process $PeaZipProcess -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $PeaZipArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PeaZip") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PeaZip" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $PeaZipArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $PeaZipArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install PuTTY
    If ($PuTTY -eq 1) {
        $Product = "PuTTY"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$PuTTYArchitectureClear" + "_$PuttyChannelClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $PuTTYD.Version
        }
        $PuTTYV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PuTTY*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $PuTTYLog = "$LogTemp\PuTTY.log"
        If (!$PuTTYV) {
            $PuTTYV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*PuTTY*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $PuTTYInstaller = "PuTTY-" + "$PuTTYArchitectureClear" + "-$PuttyChannelClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$PuTTYInstaller"
        If ($PuTTYV) {
            $PuTTYV = $PuTTYV.Split(".")
            $PuTTYV = $PuTTYV[0] + "." + $PuTTYV[1]
        }
        Write-Host -ForegroundColor Magenta "Install $Product $PuttyChannelClear $PuTTYArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $PuTTYV"
        If ($PuTTYV -ne $Version) {
            DS_WriteLog "I" "Install $Product $PuttyChannelClear $PuTTYArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $PuTTYLog"
            )
            Try {
                Write-Host "Starting install of $Product $PuttyChannelClear $PuTTYArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    Get-Content $PuTTYLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $PuTTYLog -ErrorAction SilentlyContinue
                    If (Test-Path -Path "$env:PUBLIC\Desktop\PuTTY.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\PuTTY.lnk" -Force}
                    If (Test-Path -Path "$env:PUBLIC\Desktop\PuTTY (64-bit).lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\PuTTY (64-bit).lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PuTTY*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\PuTTY*" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product $PuttyChannelClear $PuTTYArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Remote Desktop Manager
    If ($RemoteDesktopManager -eq 1) {
        Switch ($RemoteDesktopManagerType) {
            0 {
                $Product = "Remote Desktop Manager Free"
                # Check, if a new version is available
                $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $RemoteDesktopManagerFreeD
                }
                $RemoteDesktopManagerFree = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Remote Desktop Manager*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                $RemoteDesktopManagerLog = "$LogTemp\RemoteDesktopManager.log"
                $InstallMSI = "$PSScriptRoot\$Product\Setup.RemoteDesktopManagerFree.msi"
                Write-Host -ForegroundColor Magenta "Install $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $RemoteDesktopManagerFree"
                If ($RemoteDesktopManagerFree -lt $Version) {
                    DS_WriteLog "I" "Install $Product" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    $Arguments = @(
                        "/i"
                        "`"$InstallMSI`""
                        "/qn"
                        "/L*V $RemoteDesktopManagerLog"
                    )
                    Try {
                        Write-Host "Starting install of $Product version $Version"
                        If ($WhatIf -eq '0') {
                            Install-MSI $InstallMSI $Arguments
                            If ($CleanUpStartMenu) {
                                If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Remote Desktop Manager*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Remote Desktop Manager*" -Recurse -Force}
                            }
                        }
                        Get-Content $RemoteDesktopManagerLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                        Remove-Item $RemoteDesktopManagerLog -ErrorAction SilentlyContinue
                    } Catch {
                        DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile       
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
            1 {
                $Product = "Remote Desktop Manager Enterprise"
                # Check, if a new version is available
                $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $RemoteDesktopManagerEnterpriseD
                }
                $RemoteDesktopManagerEnterprise = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Remote Desktop Manager*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                $RemoteDesktopManagerLog = "$LogTemp\RemoteDesktopManager.log"
                $InstallMSI = "$PSScriptRoot\$Product\Setup.RemoteDesktopManagerEnterprise.msi"
                Write-Host -ForegroundColor Magenta "Install $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $RemoteDesktopManagerEnterprise"
                If ($RemoteDesktopManagerEnterprise -lt $Version) {
                    DS_WriteLog "I" "Install $Product" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    $Arguments = @(
                        "/i"
                        "`"$InstallMSI`""
                        "/qn"
                        "/L*V $RemoteDesktopManagerLog"
                    )
                    Try {
                        Write-Host "Starting install of $Product version $Version"
                        If ($WhatIf -eq '0') {
                            Install-MSI $InstallMSI $Arguments
                        }
                        Get-Content $RemoteDesktopManagerLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                        Remove-Item $RemoteDesktopManagerLog -ErrorAction SilentlyContinue
                    } Catch {
                        DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile       
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Install Screenpresso
    If ($Screenpresso -eq 1) {
        $Product = "Screenpresso"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ScreenpressoD.Version
        }
        $ScreenpressoV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ScreenpressoV) {
            $ScreenpressoV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$ScreenpressoV) {
            $ScreenpressoV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Screenpresso"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($ScreenpressoV) {
            $ScreenpressoV = $ScreenpressoV.Split(".")
            $ScreenpressoV = $ScreenpressoV[0] + "." + $ScreenpressoV[1] + "." + $ScreenpressoV[2]
        }
        $ScreenpressoLog = "$LogTemp\Screenpresso.log"
        $ScreenpressoInstaller = "Screenpresso.setup.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$ScreenpressoInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $ScreenpressoV"
        If ($ScreenpressoV -ne $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $ScreenpressoLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Screenpresso*") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Screenpresso*" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Screenpresso*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Screenpresso*" -Recurse -Force}
                    }
                }
                Get-Content $ScreenpressoLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $ScreenpressoLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }            
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install ShareX
    If ($ShareX -eq 1) {
        $Product = "ShareX"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $ShareXD.Version
        }
        $ShareXV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*ShareX*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$ShareXV) {
            $ShareXV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*ShareX*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $ShareXInstaller = "ShareX-setup" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $ShareXV"
        If ($ShareXV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/VERYSILENT"
                "/UPDATE"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$ShareXInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process ShareX-setup -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\ShareX") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\ShareX" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Slack
    If ($Slack -eq 1) {
        $Product = "Slack"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SlackArchitectureClear" + "_$SlackPlatformClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $SlackD.Version
        }
        $SlackV = (Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SlackV) {
            $SlackV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$SlackV) {
            $SlackV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Slack*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If (!$SlackV) {
        }
        Else {
            If ($SlackV.length -ne "6") {$SlackV = $SlackV -replace ".{2}$"}
        }
        $SlackLog = "$LogTemp\Slack.log"
        $SlackInstaller = "Slack.setup" + "_$SlackArchitectureClear" + "_$SlackPlatformClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$SlackInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $SlackArchitectureClear $SlackPlatformClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $SlackV"
        If ($SlackV -ne $Version) {
            DS_WriteLog "I" "Install $Product $SlackArchitectureClear $SlackPlatformClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/norestart"
                "/L*V $SlackLog"
            )
            Try {
                Write-Host "Starting install of $Product $SlackArchitectureClear $SlackPlatformClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Slack*") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Slack*" -Recurse -Force}
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Slack*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Slack*" -Recurse -Force}
                    }
                }
                Get-Content $SlackLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $SlackLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $SlackArchitectureClear $SlackPlatformClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }            
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Sumatra PDF
    If ($SumatraPDF -eq 1) {
        $Product = "Sumatra PDF"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$SumatraPDFArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $SumatraPDFD.Version
        }
        $SumatraPDFV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "SumatraPDF"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$SumatraPDFV) {
            $SumatraPDFV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "SumatraPDF"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $SumatraPDFInstaller = "SumatraPDF-Install-" + "$SumatraPDFArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $SumatraPDFArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $SumatraPDFV"
        If ($SumatraPDFV -ne $Version) {
            DS_WriteLog "I" "Install $Product $SumatraPDFArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "-quiet"
                "-s"
            )
            Try {
                Write-Host "Starting install of $Product $SumatraPDFArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$SumatraPDFInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    If ($WhatIf -eq '0') {
                        If (Test-Path "$Desktop\SumatraPDF.lnk") {Remove-Item -Path "$Desktop\SumatraPDF.lnk" -Force}
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\SumatraPDF.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\SumatraPDF.lnk" -Force}
                        }
                    }
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                }
                If (Test-Path -Path "$env:LOCALAPPDATA\SumatraPDF\SumatraPDF-settings.txt") {
                    # Disable auto update
                    Write-Host "Disable auto update"
                    Try {
                        If ($WhatIf -eq '0') {
                            (Get-Content "$env:LOCALAPPDATA\SumatraPDF\SumatraPDF-settings.txt" -ErrorAction SilentlyContinue) | ForEach-Object { $_ -replace "CheckForUpdates = true" , "CheckForUpdates = false" } | Set-Content "$env:LOCALAPPDATA\SumatraPDF\SumatraPDF-settings.txt"
                        }
                        Write-Host -ForegroundColor Green "Disable auto update $Product finished!"
                    } Catch {
                        Write-Host -ForegroundColor Red "Error disable auto update (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error disable auto update (Error: $($Error[0]))" $LogFile
                    }
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $SumatraPDFArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $SumatraPDFArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install TeamViewer
    If ($TeamViewer -eq 1) {
        $Product = "TeamViewer"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TeamViewerArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $TeamViewerD.Version
        }
        $TeamViewerV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TeamViewer*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TeamViewerV) {
            $TeamViewerV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "TeamViewer"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $TeamViewerInstaller = "TeamViewer-setup-" + "$TeamViewerArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $TeamViewerArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $TeamViewerV"
        If ($TeamViewerV -lt $Version) {
            DS_WriteLog "I" "Install $Product $TeamViewerArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/S"
            )
            Try {
                Write-Host "Starting install of $Product $TeamViewerArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$TeamViewerInstaller" -ArgumentList $Options -NoNewWindow
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                $p = Get-Process TeamViewer-setup -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                    If ($WhatIf -eq '0') {
                        If (Test-Path -Path "$env:PUBLIC\Desktop\Teamviewer.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Teamviewer.lnk" -Force}
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TeamViewer.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TeamViewer.lnk" -Force}
                        }
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $TeamViewerArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install TechSmith Camtasia
    If ($TechSmithCamtasia -eq 1) {
        $Product = "TechSmith Camtasia"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $TechSmithCamtasiaD.Version
        }
        $TechSmithCamtasiaV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Camtasia*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $TechSmithCamtasiaLog = "$LogTemp\TechSmithCamtasia.log"
        If (!$TechSmithCamtasiaV) {
            $TechSmithCamtasiaV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Camtasia*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($TechSmithCamtasiaV) {$TechSmithCamtasiaSplit = $TechSmithCamtasiaV.split(".")}
        If ($TechSmithCamtasiaSplit) {$TechSmithCamtasiaStrings = ([regex]::Matches($TechSmithCamtasiaV, "\." )).count}
        Switch ($TechSmithCamtasiaStrings) {
            1 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1]
            }
            2 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1] + "." + $TechSmithCamtasiaSplit[2]
            }
            3 {
                $TechSmithCamtasiaVN = $TechSmithCamtasiaSplit[0] + "." + $TechSmithCamtasiaSplit[1] + "." + $TechSmithCamtasiaSplit[2]
            }
        }
        $TechSmithCamtasiaInstaller = "camtasia-setup.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$TechSmithCamtasiaInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $TechSmithCamtasiaVN"
        If ($TechSmithCamtasiaVN -ne $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $TechSmithCamtasiaLog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    Get-Content $TechSmithCamtasiaLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $TechSmithCamtasiaLog -ErrorAction SilentlyContinue
                    If (Test-Path -Path "$env:PUBLIC\Desktop\Camtasia*.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Camtasia*.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TechSmith") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TechSmith" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install TechSmith SnagIt
    If ($TechSmithSnagIt -eq 1) {
        $Product = "TechSmith SnagIt"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TechSmithSnagItArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $TechSmithSnagitD.Version
        }
        $TechSmithSnagItV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "SnagIt*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $TechSmithSnagItLog = "$LogTemp\TechSmithSnagIt.log"
        If (!$TechSmithSnagItV) {
            $TechSmithSnagItV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "SnagIt*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $TechSmithSnagItInstaller = "snagit-setup_" + "$TechSmithSnagItArchitectureClear" + ".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$TechSmithSnagItInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $TechSmithSnagItArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $TechSmithSnagItV"
        If ($TechSmithSnagItV -ne $Version) {
            DS_WriteLog "I" "Install $Product $TechSmithSnagItArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $TechSmithSnagItLog"
            )
            Try {
                Write-Host "Starting install of $Product $TechSmithSnagItArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Start-Sleep 25
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TechSmith") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TechSmith" -Recurse -Force}
                    }
                }
                Get-Content $TechSmithSnagItLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                Remove-Item $TechSmithSnagItLog -ErrorAction SilentlyContinue
            } Catch {
                DS_WriteLog "E" "Error installing $Product $TechSmithSnagItArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Total Commander
    If ($TotalCommander -eq 1) {
        $Product = "Total Commander"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$TotalCommanderArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $TotalCommanderD.Version
        }
        $TotalCommanderV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Total Commander*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$TotalCommanderV) {
            $TotalCommanderV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "Total Commander*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $TotalCommanderInstaller = "TotalCommander_" + "$TotalCommanderArchitectureClear" + ".exe"
        $TotalCommanderProcess = "TotalCommander_" + "$TotalCommanderArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product $TotalCommanderArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $TotalCommanderV"
        If ($TotalCommanderV -lt $Version) {
            DS_WriteLog "I" "Install $Product $TotalCommanderArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/A1H1L1G1U1"
            )
            Try {
                Write-Host "Starting install of $Product $TotalCommanderArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$TotalCommanderInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process $TotalCommanderProcess -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $TotalCommanderArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Total Commander") {Remove-Item -Path "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Total Commander" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $TotalCommanderArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $TotalCommanderArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install TreeSize
    If ($TreeSize -eq 1) {
        Switch ($TreeSizeType) {
            0 {
                $Product = "TreeSize Free"
                # Check, if a new version is available
                $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $TreeSizeFreeD.Version
                }
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $TreeSizeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize Free*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$TreeSizeV) {
                    $TreeSizeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize Free*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                Write-Host -ForegroundColor Magenta "Install $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $TreeSizeV"
                If ($TreeSizeV -lt $Version) {
                    DS_WriteLog "I" "Install $Product" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product version $Version"
                        If ($WhatIf -eq '0') {
                            Start-Process "$PSScriptRoot\$Product\TreeSize_Free.exe" -ArgumentList /VerySilent -NoNewWindow
                        }
                        $p = Get-Process TreeSize_Free -ErrorAction SilentlyContinue
                        If ($p) {
                            $p.WaitForExit()
                            Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                            DS_WriteLog "I" "Installation $Product finished!" $LogFile
                        }
                        If ($WhatIf -eq '0') {
                            If ($CleanUpStartMenu) {
                                If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TreeSize*") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\TreeSize*" -Recurse -Force}
                            }
                        }
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
            1 {
                $Product = "TreeSize Professional"
                # Check, if a new version is available
                $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $TreeSizeProfD.Version
                }
                $VersionC = ([regex]::Matches($Version, "\." )).count
                If ($VersionC -ne 2){
                    $Version = $Version.Insert(3,'.')
                }
                $TreeSizeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize V*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$TreeSizeV) {
                    $TreeSizeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*TreeSize V*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                Write-Host -ForegroundColor Magenta "Install $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $TreeSizeV"
                If ($TreeSizeV -lt $Version) {
                    DS_WriteLog "I" "Install $Product" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    Try {
                        Write-Host "Starting install of $Product version $Version"
                        If ($WhatIf -eq '0') {
                            Start-Process "$PSScriptRoot\$Product\TreeSize_Professional.exe" -ArgumentList /VerySilent -NoNewWindow
                        }
                        $p = Get-Process TreeSize_Professional -ErrorAction SilentlyContinue
                        If ($p) {
                            $p.WaitForExit()
                            Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                            DS_WriteLog "I" "Installation $Product finished!" $LogFile
                        }
                    } Catch {
                        Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                        DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile       
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
                If ($CleanUp -eq '1') {
                    If ($WhatIf -eq '0') {
                        Remove-Item "$PSScriptRoot\$Product\*" -Recurse
                    }
                    Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
            }
        }
    }

    #// Mark: Install VLC Player
    If ($VLCPlayer -eq 1) {
        $Product = "VLC Player"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VLCPlayerArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $VLCD.Version
        }
        $VLC = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VLC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $VLCLog = "$LogTemp\VLC.log"
        If (!$VLC) {
            $VLC = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VLC*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($VLC) {$VLC = $VLC -replace ".{2}$"}
        $VLCInstaller = "VLC-Player_" + "$VLCPlayerArchitectureClear" +".msi"
        $InstallMSI = "$PSScriptRoot\$Product\$VLCInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product $VLCPlayerArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $VLC"
        If ($VLC -lt $Version) {
            DS_WriteLog "I" "Install $Product $VLCPlayerArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $VLCLog"
            )
            Try {
                Write-Host "Starting install of $Product $VLCPlayerArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Get-Content $VLCLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $VLCLog -ErrorAction SilentlyContinue
                    If (Test-Path -Path "$env:PUBLIC\Desktop\VLC media player.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\VLC media player.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\VideoLAN") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\VideoLAN" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "An error occurred installing $Product $VLCPlayerArchitectureClear (Error: $($Error[0]))" $LogFile 
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install VMwareTools
    If ($VMwareTools -eq 1) {
        $Product = "VMware Tools"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$VMwareToolsArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $VMwareToolsD.Version
        }
        $VMWT = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VMware Tools*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$VMWT) {
            $VMWT = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*VMware Tools*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($VMWT) {$VMWT = $VMWT -replace ".{9}$"}
        $VMwareToolsInstaller = "VMwareTools_" + "$VMwareToolsArchitectureClear" +".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $VMwareToolsArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $VMWT"
        If ($VMWT -lt $Version) {
            $Options = @(
                "/s"
                "/v"
                "/qn REBOOT=ReallySuppress"
            )
            DS_WriteLog "I" "Install $Product $VMwareToolsArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            Try {
                Write-Host "Starting install of $Product $VMwareToolsArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$VMwareToolsInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    Write-Host -ForegroundColor Yellow "System needs to reboot after installation!"
                    DS_WriteLog "I" "Installation $Product $VMwareToolsArchitectureClear finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    Write-Host -ForegroundColor Yellow "System needs to reboot after installation!"
                    DS_WriteLog "I" "Installation $Product $VMwareToolsArchitectureClear finished!" $LogFile
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $VMwareToolsArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $VMwareToolsArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install WinMerge
    If ($WinMerge -eq 1) {
        $Product = "WinMerge"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinMergeArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $WinMergeD.Version
        }
        $WinMergeV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinMerge*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WinMergeV) {
            $WinMergeV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinMerge*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $WinMergeInstaller = "WinMerge_" + "$WinMergeArchitectureClear" + ".exe"
        $WinMergeProcess = "WinMerge_" + "$WinMergeArchitectureClear"
        Write-Host -ForegroundColor Magenta "Install $Product $WinMergeArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $WinMergeV"
        If ($WinMergeV -lt $Version) {
            DS_WriteLog "I" "Install $Product $WinMergeArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/VERYSILENT"
            )
            Try {
                Write-Host "Starting install of $Product $WinMergeArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$WinMergeInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process $WinMergeProcess -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $WinMergeArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinMerge") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinMerge" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $WinMergeArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $WinMergeArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install WinRAR
    If ($WinRAR -eq 1) {
        $Product = "WinRAR"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $WinRARD.Version
        }
        $WinRARV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinRAR*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WinRARV) {
            $WinRARV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "WinRAR*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        If ($WinRARV) {$WinRARV = $WinRARV -replace "\.\d*$"}
        $WinRARInstaller = "WinRAR_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear" + ".exe"
        $WinRARProcess = "WinRAR_" + "$WinRARArchitectureClear" + "_$WinRARChannelClear" + "_$WinRARLanguageClear"
        Write-Host -ForegroundColor Magenta "Install $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $WinRARV"
        If ($WinRARV -lt $Version) {
            DS_WriteLog "I" "Install $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/S"
            )
            Try {
                Write-Host "Starting install of $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    Start-Process "$PSScriptRoot\$Product\$WinRARInstaller" -ArgumentList $Options -NoNewWindow
                }
                $p = Get-Process $WinRARProcess -ErrorAction SilentlyContinue
                If ($p) {
                    $p.WaitForExit()
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinRAR") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinRAR" -Recurse -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $WinRARChannelClear release $WinRARLanguageClear $WinRARArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install WinSCP
    If ($WinSCP -eq 1) {
        $Product = "WinSCP"
        # Check, if a new version is available
        $Version = Get-Content -Path "$PSScriptRoot\$Product\Version.txt" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $WinSCPD.Version
        }
        $WSCP = (Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*WinSCP*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $WSCP"
        If ($WSCP -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/VERYSILENT"
                "/ALLUSERS"
                "/NORESTART"
                "/NOCLOSEAPPLICATIONS"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\WinSCP.exe" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    If ($WhatIf -eq '0') {
                        If (Test-Path -Path "$env:PUBLIC\Desktop\WinSCP.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\WinSCP.lnk" -Force}
                        If ($CleanUpStartMenu) {
                            If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinSCP.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\WinSCP.lnk" -Force}
                        }
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Wireshark
    If ($Wireshark -eq 1) {
        $Product = "Wireshark"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version_" + "$WiresharkArchitectureClear" + ".txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $WiresharkD.Version
        }
        $WiresharkV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Wireshark*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        If (!$WiresharkV) {
            $WiresharkV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Wireshark*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $WiresharkInstaller = "Wireshark-" + "$WiresharkArchitectureClear" + ".exe"
        Write-Host -ForegroundColor Magenta "Install $Product $WiresharkArchitectureClear"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $WiresharkV"
        If ($WiresharkV -lt $Version) {
            DS_WriteLog "I" "Install $Product $WiresharkArchitectureClear" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Options = @(
                "/S"
                "/desktopicon=no"
                "/quicklaunchdicon=no"
            )
            Try {
                Write-Host "Starting install of $Product $WiresharkArchitectureClear version $Version"
                If ($WhatIf -eq '0') {
                    $inst = Start-Process -FilePath "$PSScriptRoot\$Product\$WiresharkInstaller" -ArgumentList $Options -PassThru -ErrorAction Stop
                }
                else{
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $WiresharkArchitectureClear finished!" $LogFile
                }
                If ($inst) {
                    Wait-Process -InputObject $inst
                    Write-Host -ForegroundColor Green "Install of the new version $Version finished!"
                    DS_WriteLog "I" "Installation $Product $WiresharkArchitectureClear finished!" $LogFile
                }
                If ($WhatIf -eq '0') {
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Wireshark.lnk") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Wireshark.lnk" -Force}
                    }
                }
            } Catch {
                Write-Host -ForegroundColor Red "Error installing $Product $WiresharkArchitectureClear (Error: $($Error[0]))"
                DS_WriteLog "E" "Error installing $Product $WiresharkArchitectureClear (Error: $($Error[0]))" $LogFile
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install XCA
    If ($XCA -eq 1) {
        $Product = "XCA"
        # Check, if a new version is available
        $VersionPath = "$PSScriptRoot\$Product\Version.txt"
        $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
        If (!($Version)) {
            $Version = $XCAD.Version
        }
        $XCAV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*XCA*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        $XCALog = "$LogTemp\XCA.log"
        If (!$XCAV) {
            $XCAV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*XCA*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
        }
        $XCAInstaller = "XCA.msi"
        $InstallMSI = "$PSScriptRoot\$Product\$XCAInstaller"
        Write-Host -ForegroundColor Magenta "Install $Product"
        Write-Host "Download Version: $Version"
        Write-Host "Current Version:  $XCAV"
        If ($XCAV -lt $Version) {
            DS_WriteLog "I" "Install $Product" $LogFile
            Write-Host -ForegroundColor Green "Update available"
            $Arguments = @(
                "/i"
                "`"$InstallMSI`""
                "/qn"
                "/L*V $XCALog"
            )
            Try {
                Write-Host "Starting install of $Product version $Version"
                If ($WhatIf -eq '0') {
                    Install-MSI $InstallMSI $Arguments
                    Get-Content $XCALog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $XCALog -ErrorAction SilentlyContinue
                    If (Test-Path -Path "$env:PUBLIC\Desktop\XCA.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\XCA.lnk" -Force}
                    If ($CleanUpStartMenu) {
                        If (Test-Path -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\XCA") {Remove-Item -Path "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\XCA" -Recurse -Force}
                    }
                }
            } Catch {
                DS_WriteLog "E" "An error occurred installing $Product (Error: $($Error[0]))" $LogFile 
            }
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
        # Stop, if no new version is available
        Else {
            Write-Host -ForegroundColor Cyan "No update available for $Product"
            Write-Output ""
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }

    #// Mark: Install Zoom
    If ($Zoom -eq 1) {
        If ($ZoomCitrixClient -eq 0) {
            If ($ZoomInstallerClear -eq 'Machine Based') {
                $Product = "Zoom VDI"
                # Check, if a new version is available
                $VersionPath = "$PSScriptRoot\$Product\Version.txt"
                $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $ZoomD.Version
                }
                $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Zoom Client for VDI*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                #If ($ZoomV.length -ne "5") {$ZoomV = $ZoomV -replace ".{4}$"}
                $ZoomLog = "$LogTemp\Zoom.log"
                $ZoomInstaller = "ZoomInstallerVDI.msi"
                $InstallMSI = "$PSScriptRoot\$Product\$ZoomInstaller"
                Write-Host -ForegroundColor Magenta "Install $Product"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $ZoomV"
                If ($ZoomV -lt $Version) {
                    DS_WriteLog "I" "Install $Product" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    $Arguments = @(
                        "/i"
                        "`"$InstallMSI`""
                        "/qn"
                        "/norestart"
                        "/L*V $ZoomLog"
                    )
                    Try {
                        Write-Host "Starting install of $Product version $Version"
                        If ($WhatIf -eq '0') {
                            Install-MSI $InstallMSI $Arguments
                            Start-Sleep 25
                            Get-Content $ZoomLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                            Remove-Item $ZoomLog -ErrorAction SilentlyContinue
                            If (Test-Path -Path "$env:PUBLIC\Desktop\Zoom VDI.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Zoom VDI.lnk" -Force}
                        }
                    } Catch {
                        DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
            }
            If ($ZoomInstallerClear -eq 'User Based') {
                $Product = "Zoom"
                # Check, if a new version is available
                $VersionPath = "$PSScriptRoot\$Product\Version_" + "$ZoomArchitectureClear" + ".txt"
                $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
                If (!($Version)) {
                    $Version = $ZoomD.Version
                }
                $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Zoom"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                If (!$ZoomV) {
                    $ZoomV = (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -eq "Zoom"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
                }
                $ZoomLog = "$LogTemp\Zoom.log"
                $ZoomInstaller = "ZoomInstallerFull" + "$ZoomArchitectureClear" + ".msi"
                $InstallMSI = "$PSScriptRoot\$Product\$ZoomInstaller"
                Write-Host -ForegroundColor Magenta "Install $Product $ZoomArchitectureClear"
                Write-Host "Download Version: $Version"
                Write-Host "Current Version:  $ZoomV"
                If ($ZoomV -lt $Version) {
                    DS_WriteLog "I" "Install $Product $ZoomArchitectureClear" $LogFile
                    Write-Host -ForegroundColor Green "Update available"
                    $Arguments = @(
                        "/i"
                        "`"$InstallMSI`""
                        "/qn"
                        "/norestart"
                        "/L*V $ZoomLog"
                    )
                    Try {
                        Write-Host "Starting install of $Product $ZoomArchitectureClear version $Version"
                        If ($WhatIf -eq '0') {
                            Install-MSI $InstallMSI $Arguments
                            Start-Sleep 25
                            Get-Content $ZoomLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                            Remove-Item $ZoomLog -ErrorAction SilentlyContinue
                            If (Test-Path -Path "$env:PUBLIC\Desktop\Zoom.lnk") {Remove-Item -Path "$env:PUBLIC\Desktop\Zoom.lnk" -Force}
                        }
                    } Catch {
                        DS_WriteLog "E" "Error installing $Product $ZoomArchitectureClear (Error: $($Error[0]))" $LogFile
                    }
                    DS_WriteLog "-" "" $LogFile
                    Write-Output ""
                }
                # Stop, if no new version is available
                Else {
                    Write-Host -ForegroundColor Cyan "No update available for $Product"
                    Write-Output ""
                }
            }
        }
    }
    If ($Zoom -eq 1) {
        If ($ZoomCitrixClient -eq 1) {
            $Product = "Zoom Citrix HDX Media Plugin"
            # Check, if a new version is available
            $VersionPath = "$PSScriptRoot\$Product\Version" + ".txt"
            $Version = Get-Content -Path "$VersionPath" -ErrorAction SilentlyContinue
            If (!($Version)) {
                $Version = $ZoomD.Version
            }
            $ZoomV = (Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName -like "*Zoom Plugin*"}).DisplayVersion | Sort-Object -Property Version -Descending | Select-Object -First 1
            #If ($ZoomV.length -ne "5") {$ZoomV = $ZoomV -replace ".{4}$"}
            $ZoomInstaller = "ZoomCitrixHDXMediaPlugin" + ".msi"
            $ZoomLog = "$LogTemp\Zoom.log"
            $InstallMSI = "$PSScriptRoot\$Product\$ZoomInstaller"
            Write-Host -ForegroundColor Magenta "Install $Product"
            Write-Host "Download Version: $Version"
            Write-Host "Current Version:  $ZoomV"
            If ($ZoomV -lt $Version) {
                DS_WriteLog "I" "Install $Product" $LogFile
                Write-Host -ForegroundColor Green "Update available"
                $Arguments = @(
                    "/i"
                    "`"$InstallMSI`""
                    "/qn"
                    "/norestart"
                    "/L*V $ZoomLog"
                )
                Try {
                    Write-Host "Starting install of $Product version $Version"
                    If ($WhatIf -eq '0') {
                        Install-MSI $InstallMSI $Arguments
                        Start-Sleep 25
                    }
                    Get-Content $ZoomLog -ErrorAction SilentlyContinue | Add-Content $LogFile -Encoding ASCII -ErrorAction SilentlyContinue
                    Remove-Item $ZoomLog -ErrorAction SilentlyContinue
                } Catch {
                    DS_WriteLog "E" "Error installing $Product (Error: $($Error[0]))" $LogFile
                }
                DS_WriteLog "-" "" $LogFile
                Write-Output ""
            }
            # Stop, if no new version is available
            Else {
                Write-Host -ForegroundColor Cyan "No update available for $Product"
                Write-Output ""
            }
        }
        If ($CleanUp -eq '1') {
            If ($WhatIf -eq '0') {
                Remove-Item "$PSScriptRoot\$Product\*" -Recurse
            }
            Write-Host -ForegroundColor Green "CleanUp for $Product install files successfully."
            DS_WriteLog "-" "" $LogFile
            Write-Output ""
        }
    }
    If ($Installer -eq 0) {
        Write-Host "Disable Change User Mode Install."
        Write-Output ""
        Change User /Execute | Out-Null
    }
}
#// Mark: Install Windows Update
# Logging
# Global variables
$WUFileName = ("Windows Update - $Date.log")
$WUFile = Join-path $LogDir $WUFileName

# Create new log file (overwrite existing one)
New-Item $WUFile -ItemType "file" -force | Out-Null

If ($WindowsUpdate -eq 1) {
    Write-Host -ForegroundColor Blue "Windows Updates"
    $WUList = Get-WUList
    If ($WUList){
        Write-Host -ForegroundColor Green "Start install Windows Updates."
        Get-WUList -MicrosoftUpdate -OutFile $WUFile
        Install-WindowsUpdate -MicrosoftUpdate -AcceptAll
        Write-Host -ForegroundColor Green "Install Windows Updates are done."
        Write-Host -ForegroundColor Green "Please restart the machine."
        Write-Output ""
    }
    Else {
        Write-Host -ForegroundColor Green "No updates needed."
        Write-Output ""
    }
}
$LASTEXITCODE = "0"
Set-Location $PSScriptRoot
Stop-Transcript | Out-Null
exit $LASTEXITCODE